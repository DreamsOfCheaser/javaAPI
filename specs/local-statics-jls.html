<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Local and Nested Static Declarations</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../resources/spec-changes.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Local and Nested Static Declarations</h1>
<p class="subtitle">Changes to the Java® Language Specification • Version 16.0.1+9-24</p>
</header>
<nav id="TOC" title="Table Of Contents">
<ul>
<li><a href="#jls-1">Chapter 1: Introduction</a><ul>
<li><a href="#jls-1.1">1.1 Organization of the Specification</a></li>
</ul></li>
<li><a href="#jls-6">Chapter 6: Names</a><ul>
<li><a href="#jls-6.1">6.1 Declarations</a></li>
<li><a href="#jls-6.3">6.3 Scope of a Declaration</a></li>
<li><a href="#jls-6.4">6.4 Shadowing and Obscuring</a><ul>
<li><a href="#jls-6.4.2">6.4.2 Obscuring</a></li>
</ul></li>
<li><a href="#jls-6.5">6.5 Determining the Meaning of a Name</a><ul>
<li><a href="#jls-6.5.2">6.5.2 Reclassification of Contextually Ambiguous Names</a></li>
<li><a href="#jls-6.5.5">6.5.5 Meaning of Type Names</a><ul>
<li><a href="#jls-6.5.5.1">6.5.5.1 Simple Type Names</a></li>
</ul></li>
<li><a href="#jls-6.5.6">6.5.6 Meaning of Expression Names</a><ul>
<li><a href="#jls-6.5.6.1">6.5.6.1 Simple Expression Names</a></li>
</ul></li>
<li><a href="#jls-6.5.7">6.5.7 Meaning of Method Names</a><ul>
<li><a href="#jls-6.5.7.1">6.5.7.1 Simple Method Names</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-6.7">6.7 Fully Qualified Names and Canonical Names</a></li>
</ul></li>
<li><a href="#jls-8">Chapter 8: Classes</a><ul>
<li><a href="#jls-8.1">8.1 Class Declarations</a><ul>
<li><a href="#jls-8.1.1">8.1.1 Class Modifiers</a><ul>
<li><a href="#jls-8.1.1.1">8.1.1.1 <code>abstract</code> Classes</a></li>
<li><a href="#jls-8.1.1.2">8.1.1.2 <code>final</code> Classes</a></li>
<li><a href="#jls-8.1.1.3">8.1.1.3 <code>strictfp</code> Classes</a></li>
<li><a href="#jls-8.1.1.4"><strong>8.1.1.4 <code>static</code> Classes</strong></a></li>
</ul></li>
<li><a href="#jls-8.1.2">8.1.2 Generic Classes and Type Parameters</a></li>
<li><a href="#jls-8.1.3">8.1.3 Inner Classes and Enclosing Instances</a></li>
</ul></li>
<li><a href="#jls-8.3">8.3 Field Declarations</a><ul>
<li><a href="#jls-8.3.1">8.3.1 Field Modifiers</a><ul>
<li><a href="#jls-8.3.1.1">8.3.1.1 <code>static</code> Fields</a></li>
</ul></li>
<li><a href="#jls-8.3.2">8.3.2 Field Initialization</a></li>
</ul></li>
<li><a href="#jls-8.4">8.4 Method Declarations</a><ul>
<li><a href="#jls-8.4.1">8.4.1 Formal Parameters</a></li>
<li><a href="#jls-8.4.3">8.4.3 Method Modifiers</a><ul>
<li><a href="#jls-8.4.3.2">8.4.3.2 <code>static</code> Methods</a></li>
</ul></li>
<li><a href="#jls-8.4.4">8.4.4 Generic Methods</a></li>
</ul></li>
<li><a href="#jls-8.5">8.5 Member Class and Interface Declarations</a><ul>
<li><a href="#jls-8.5.1"><del>8.5.1 Static Member Class and Interface Declarations</del></a></li>
</ul></li>
<li><a href="#jls-8.7">8.7 Static Initializers</a></li>
<li><a href="#jls-8.8">8.8 Constructor Declarations</a><ul>
<li><a href="#jls-8.8.1">8.8.1 Formal Parameters</a></li>
<li><a href="#jls-8.8.4">8.8.4 Generic Constructors</a></li>
<li><a href="#jls-8.8.7">8.8.7 Constructor Body</a><ul>
<li><a href="#jls-8.8.7.1">8.8.7.1 Explicit Constructor Invocations</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-8.9">8.9 Enum Classes</a></li>
</ul></li>
<li><a href="#jls-9">Chapter 9: Interfaces</a><ul>
<li><a href="#jls-9.1">9.1 Interface Declarations</a><ul>
<li><a href="#jls-9.1.1">9.1.1 Interface Modifiers</a><ul>
<li><a href="#jls-9.1.1.1">9.1.1.1 <code>abstract</code> Interfaces</a></li>
<li><a href="#jls-9.1.1.2">9.1.1.2 <code>strictfp</code> Interfaces</a></li>
<li><a href="#jls-9.1.1.3"><strong>9.1.1.3 <code>static</code> Interfaces</strong></a></li>
</ul></li>
<li><a href="#jls-9.1.2">9.1.2 Generic Interfaces and Type Parameters</a></li>
</ul></li>
<li><a href="#jls-9.4">9.4 Method Declarations</a><ul>
<li><a href="#jls-9.4.3">9.4.3 Interface Method Body</a></li>
</ul></li>
<li><a href="#jls-9.6">9.6 Annotation Interfaces</a></li>
</ul></li>
<li><a href="#jls-13">Chapter 13: Binary Compatibility</a><ul>
<li><a href="#jls-13.1">13.1 The Form of a Binary</a></li>
</ul></li>
<li><a href="#jls-14">Chapter 14: Blocks and Statements</a><ul>
<li><a href="#jls-14.2">14.2 Blocks</a></li>
<li><a href="#jls-14.3">14.3 Local Class <strong>and Interface</strong> Declarations</a></li>
<li><a href="#jls-14.4">14.4 Local Variable Declaration Statements</a><ul>
<li><a href="#jls-14.4.1">14.4.1 Local Variable Declarators and Types</a></li>
</ul></li>
<li><a href="#jls-14.14">14.14 The <code>for</code> Statement</a><ul>
<li><a href="#jls-14.14.1">14.14.1 The basic <code>for</code> Statement</a></li>
<li><a href="#jls-14.14.2">14.14.2 The enhanced <code>for</code> statement</a></li>
</ul></li>
<li><a href="#jls-14.20">14.20 The <code>try</code> statement</a><ul>
<li><a href="#jls-14.20.3">14.20.3 <code>try</code>-with-resources</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-15">Chapter 15: Expressions</a><ul>
<li><a href="#jls-15.8">15.8 Primary Expressions</a><ul>
<li><a href="#jls-15.8.3">15.8.3 <code>this</code></a></li>
<li><a href="#jls-15.8.4">15.8.4 Qualified <code>this</code></a></li>
</ul></li>
<li><a href="#jls-15.9">15.9 Class Instance Creation Expressions</a><ul>
<li><a href="#jls-15.9.2">15.9.2 Determining Enclosing Instances</a></li>
</ul></li>
<li><a href="#jls-15.11">15.11 Field Access Expressions</a><ul>
<li><a href="#jls-15.11.2">15.11.2 Accessing Superclass Members using <code>super</code></a></li>
</ul></li>
<li><a href="#jls-15.12">15.12 Method Invocation Expressions</a><ul>
<li><a href="#jls-15.12.1">15.12.1 Compile-Time Step 1: Determine Type to Search</a></li>
<li><a href="#jls-15.12.3">15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?</a></li>
</ul></li>
<li><a href="#jls-15.13">15.13 Method Reference Expressions</a><ul>
<li><a href="#jls-15.13.1">15.13.1 Compile-Time Declaration of a Method Reference</a></li>
</ul></li>
<li><a href="#jls-15.27">15.27 Lambda Expressions</a><ul>
<li><a href="#jls-15.27.1">15.27.1 Lambda Parameters</a></li>
<li><a href="#jls-15.27.2">15.27.2 Lambda Body</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-16">Chapter 16: Definite Assignment</a><ul>
<li><a href="#jls-16.2">16.2 Definite Assignment and Statements</a><ul>
<li><a href="#jls-16.2.3">16.2.3 Local Class <del>Declaration Statements</del> <strong>and Interface Declarations</strong></a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a href="https://docs.oracle.com/javase/specs/jls/se14/html">Java Language Specification</a> as modified by <a href="class-terminology-jls.html">Consistent Class and Interface Terminology</a> to support <code>static</code> declarations in two new positions:</p>
<ul>
<li><p>Local, implicitly-<code>static</code> interfaces and enum classes (<a href="#jls-14.3">14.3</a>)</p></li>
<li><p><code>static</code> members of inner classes (<a href="#jls-8.1.3">8.1.3</a>)</p></li>
</ul>
<p>Nested static declarations have no access to enclosing instances, local variables, or type parameters. This is addressed in the rules for references to variables (<a href="#jls-6.5.6.1">6.5.6.1</a>), types (<a href="#jls-6.5.5.1">6.5.5.1</a>), methods (<a href="#jls-15.12.3">15.12.3</a>), and <code>this</code> (<a href="#jls-15.8.3">15.8.3</a>, <a href="#jls-15.9.2">15.9.2</a>, <a href="#jls-15.11.2">15.11.2</a>, etc.) to handle references from new contexts.</p>
<p>These enhancements are part of the Records feature. See the <a href="https://openjdk.java.net/jeps/8242303">JEP Draft</a> for additional details.</p>
<p>Changes are described with respect to existing sections of the Java Language Specification. New text is indicated <strong>like this</strong> and deleted text is indicated <del>like this</del>. Explanation and discussion, as needed, is set aside in grey boxes.</p>
<h2 id="jls-1">Chapter 1: Introduction</h2>
<h3 id="jls-1.1">1.1 Organization of the Specification</h3>
<p>...</p>
<p>Chapter 6 describes declarations and names, and how to determine what names mean (that is, which declaration a name denotes). The Java programming language does not require classes and interfaces, or their members, to be declared before they are used. Declaration order is significant only for local variables, local classes <strong>and interfaces</strong>, and the order of field initializers in a class or interface. Recommended naming conventions that make for more readable programs are described here.</p>
<p>...</p>
<h2 id="jls-6">Chapter 6: Names</h2>
<h3 id="jls-6.1">6.1 Declarations</h3>
<p>A <em>declaration</em> introduces an entity into a program and includes an identifier (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.8">3.8</a>) that can be used in a name to refer to this entity. The identifier is constrained to be a type identifier when the entity being introduced is a class, interface, or type parameter.</p>
<p>A declared entity is one of the following:</p>
<ul>
<li><p>A module, declared in a <code>module</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7">7.7</a>)</p></li>
<li><p>A package, declared in a <code>package</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4">7.4</a>)</p></li>
<li><p>An imported class or interface, declared in a single-type-import declaration or a type-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.1">7.5.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.2">7.5.2</a>)</p></li>
<li><p>An imported <code>static</code> member, declared in a single-static-import declaration or a static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.3">7.5.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>A class, declared by a normal class declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1">8.1</a>) or an enum declaration (<a href="#jls-8.9">8.9</a>)</p></li>
<li><p>An interface, declared by a normal interface declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1">9.1</a>) or an annotation declaration (<a href="#jls-9.6">9.6</a>)</p></li>
<li><p>A type parameter, declared as part of the declaration of a generic class, interface, method, or constructor (<a href="#jls-8.1.2">8.1.2</a>, <a href="#jls-9.1.2">9.1.2</a>, <a href="#jls-8.4.4">8.4.4</a>, <a href="#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>A member of a reference type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.2">8.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.2">9.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.9.3">8.9.3</a>, <a href="#jls-9.6">9.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.7">10.7</a>), one of the following:</p>
<ul>
<li><p>A member class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A member interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A field, one of the following:</p>
<ul>
<li><p>A field declared in a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3">8.3</a>)</p></li>
<li><p>A field declared in an interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a>)</p></li>
<li><p>The field <code>length</code>, which is implicitly a member of every array type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.7">10.7</a>)</p></li>
</ul></li>
<li><p>A method, one of the following:</p>
<ul>
<li><p>A method (<code>abstract</code> or otherwise) declared in a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p>A method (<code>abstract</code> or otherwise) declared in an interface (<a href="#jls-9.4">9.4</a>)</p></li>
</ul></li>
</ul></li>
<li><p>An enum constant (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p></li>
<li><p>A formal parameter of a method of a class or interface (<a href="#jls-8.4.1">8.4.1</a>), a constructor of a class (<a href="#jls-8.8.1">8.8.1</a>), or a lambda expression (<a href="#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>An exception parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="#jls-14.20">14.20</a>)</p></li>
<li><p>A local variable, one of the following:</p>
<ul>
<li><p>A local variable declared in a block (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>)</p></li>
<li><p>A local variable declared in a <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14">14.14</a>)</p></li>
</ul></li>
<li><p>A local class <strong>or interface</strong> (<a href="#jls-14.3">14.3</a>)<strong>, declared by one of the following:</strong></p>
<ul>
<li><p><strong>A normal class declaration</strong></p></li>
<li><p><strong>An enum declaration</strong></p></li>
<li><p><strong>An interface declaration</strong></p></li>
</ul></li>
</ul>
<p>Constructors (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.</p>
<p>...</p>
<h3 id="jls-6.3">6.3 Scope of a Declaration</h3>
<p>The <em>scope</em> of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is not shadowed (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>).</p>
<p>A declaration is said to be <em>in scope</em> at a particular point in a program if and only if the declaration's scope includes that point.</p>
<p>...</p>
<p>The scope of a local class <strong>or interface</strong> declaration immediately enclosed by a block (<a href="#jls-14.2">14.2</a>) is the rest of the immediately enclosing block, including <del>its own class declaration</del> <strong>the class or interface declaration itself</strong>.</p>
<p>The scope of a local class <strong>or interface</strong> declaration immediately enclosed by a switch block statement group (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.11">14.11</a>) is the rest of the immediately enclosing switch block statement group, including <del>its own class declaration</del> <strong>the class or interface declaration itself</strong>.</p>
<p>The scope of a local variable declaration in a block (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>) is the rest of the block in which the declaration appears, starting with its own initializer and including any further declarators to the right in the local variable declaration statement.</p>
<p>The scope of a local variable declared in the <em>ForInit</em> part of a basic <code>for</code> statement (<a href="#jls-14.14.1">14.14.1</a>) includes all of the following:</p>
<ul>
<li><p>Its own initializer</p></li>
<li><p>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement</p></li>
<li><p>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement</p></li>
<li><p>The contained <em>Statement</em></p></li>
</ul>
<p>The scope of a local variable declared in the <em>FormalParameter</em> part of an enhanced <code>for</code> statement (<a href="#jls-14.14.2">14.14.2</a>) is the contained <em>Statement</em>.</p>
<p>The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="#jls-14.20">14.20</a>) is the entire block associated with the <code>catch</code>.</p>
<p>The scope of a variable declared in the <em>ResourceSpecification</em> of a <code>try</code>-with-resources statement (<a href="#jls-14.20.3">14.20.3</a>) is from the declaration rightward over the remainder of the <em>ResourceSpecification</em> and the entire <code>try</code> block associated with the <code>try</code>-with-resources statement.</p>
<blockquote>
<p>The translation of a <code>try</code>-with-resources statement implies the rule above.</p>
</blockquote>
<p>...</p>
<h3 id="jls-6.4">6.4 Shadowing and Obscuring</h3>
<p>A local variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>), formal parameter (<a href="#jls-8.4.1">8.4.1</a>, <a href="#jls-15.27.1">15.27.1</a>), exception parameter (<a href="#jls-14.20">14.20</a>), <del>and</del> <strong>or</strong> local class <strong>or interface</strong> (<a href="#jls-14.3">14.3</a>) can only be referred to using a simple name, not a qualified name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.2">6.2</a>).</p>
<p>Some declarations are not permitted within the scope of a local variable, formal parameter, exception parameter, or local class <strong>or interface</strong> declaration because it would be impossible to distinguish between the declared entities using only simple names.</p>
<blockquote>
<p>For example, if the name of a formal parameter of a method could be redeclared as the name of a local variable in the method body, then the local variable would shadow the formal parameter and there would be no way to refer to the formal parameter - an undesirable outcome.</p>
</blockquote>
<p>It is a compile-time error if the name of a formal parameter is used to declare a new variable within the body of the method, constructor, or lambda expression, unless the new variable is declared within a class <strong>or interface</strong> declaration contained by the method, constructor, or lambda expression.</p>
<p>It is a compile-time error if the name of a local variable <em>v</em> is used to declare a new variable within the scope of <em>v</em>, unless the new variable is declared within a class <del>whose declaration is</del> <strong>or interface declaration appearing</strong> within the scope of <em>v</em>.</p>
<p>It is a compile-time error if the name of an exception parameter is used to declare a new variable within the <em>Block</em> of the <code>catch</code> clause, unless the new variable is declared within a class <strong>or interface</strong> declaration contained by the <em>Block</em> of the <code>catch</code> clause.</p>
<p>It is a compile-time error if the name of a local class <strong>or interface</strong> <em>C</em> is used to declare a new local class <strong>or interface</strong> within the scope of <em>C</em>, unless the new local class <strong>or interface</strong> is declared within <del>another class whose declaration is</del> <strong>a class or interface declaration appearing</strong> within the scope of <em>C</em>.</p>
<blockquote>
<p>These rules allow redeclaration of a variable<strong>,</strong> <del>or</del> local class<strong>, or local interface</strong> in nested class <strong>or interface</strong> declarations that occur in the scope of the variable<strong>,</strong> <del>or</del> local class<strong>, or local interface</strong>; such nested class <strong>or interface</strong> declarations may be local <del>classes</del> <strong>class or interface declarations</strong> (<a href="#jls-14.3">14.3</a>) or anonymous <del>classes</del> <strong>class declarations</strong> (<del><a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a></del> <strong><a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.5">15.9.5</a></strong>). Thus, the declaration of a formal parameter, local variable, <del>or</del> local class<strong>, or local interface</strong> may be shadowed in a class <strong>or interface</strong> declaration nested within a method, constructor, or lambda expression; and the declaration of an exception parameter may be shadowed in a class <strong>or interface</strong> declaration nested within the <em>Block</em> of the <code>catch</code> clause.</p>
</blockquote>
<blockquote>
<p>There are two design alternatives for handling name clashes created by lambda parameters and other variables declared in lambda expressions. One is to mimic class declarations: like local classes, lambda expressions introduce a new &quot;level&quot; for names, and all variable names outside the expression can be redeclared. Another is a &quot;local&quot; strategy: like <code>catch</code> clauses, <code>for</code> loops, and blocks, lambda expressions operate at the same &quot;level&quot; as the enclosing context, and local variables outside the expression cannot be shadowed. The above rules use the local strategy; there is no special dispensation that allows a variable declared in a lambda expression to shadow a variable declared in an enclosing method.</p>
</blockquote>
<blockquote>
<p><del>Note that the rule for local classes does not make an exception for a class of the same name declared within the local class itself. However, this case is prohibited by a separate rule: a class cannot have the same name as a class that encloses it (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1">8.1</a>).</del></p>
</blockquote>
<div class="editorial">
<p>Rephrased the rule so that it doesn't require extensive explanation of the world &quot;another&quot;. (The bottom line is that, whatever we say here, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1">8.1</a> has already decided that this choice of names is an error.)</p>
</div>
<div class="example">
<p>Example 6.4-1. Attempted Shadowing Of A Local Variable</p>
<p>Because a declaration of an identifier as a local variable of a method, constructor, or initializer block must not appear within the scope of a parameter or local variable of the same name, a compile-time error occurs for the following program:</p>
<pre><code>class Test1 {
    public static void main(String[] args) {
        int i;
        for (int i = 0; i &lt; 10; i++)
            System.out.println(i);
    }
}</code></pre>
<p>This restriction helps to detect some otherwise very obscure bugs. A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables. Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well.</p>
<p>Hence, the following program compiles without error:</p>
<pre><code>class Test2 {
    public static void main(String[] args) {
        int i;
        class Local {
            {
                for (int i = 0; i &lt; 10; i++)
                    System.out.println(i);
            }
        }
        new Local();
    }
}</code></pre>
<p>On the other hand, local variables with the same name may be declared in two separate blocks or <code>for</code> statements, neither of which contains the other:</p>
<pre><code>class Test3 {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++)
            System.out.print(i + &quot; &quot;);
        for (int i = 10; i &gt; 0; i--)
            System.out.print(i + &quot; &quot;);
        System.out.println();
    }
}</code></pre>
<p>This program compiles without error and, when executed, produces the output:</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1</code></pre>
</div>
<h4 id="jls-6.4.2">6.4.2 Obscuring</h4>
<p>...</p>
<blockquote>
<p>Obscuring involving field names is rare; however:</p>
</blockquote>
<blockquote>
<ul>
<li><p>If a field name obscures a package name, then an <code>import</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5">7.5</a>) can usually be used to make available the type names declared in that package.</p></li>
<li><p>If a field name obscures a type name, then a fully qualified name for the type can be used unless the type name denotes a local class <strong>or interface</strong> (<a href="#jls-14.3">14.3</a>).</p></li>
<li><p>Field names cannot obscure method names.</p></li>
<li><p>If a field name is shadowed by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.</p></li>
</ul>
</blockquote>
<p>...</p>
<h3 id="jls-6.5">6.5 Determining the Meaning of a Name</h3>
<h4 id="jls-6.5.2">6.5.2 Reclassification of Contextually Ambiguous Names</h4>
<p>An <em>AmbiguousName</em> is then reclassified as follows.</p>
<p>If the <em>AmbiguousName</em> is a simple name, consisting of a single <em>Identifier</em>:</p>
<ul>
<li><p>If the <em>Identifier</em> appears within the scope (<a href="#jls-6.3">6.3</a>) of a <del>local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>) or parameter declaration (<a href="#jls-8.4.1">8.4.1</a>, <a href="#jls-8.8.1">8.8.1</a>, <a href="#jls-14.20">14.20</a>) or field declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3">8.3</a>)</del> <strong>variable</strong> with that name, then the <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</p></li>
<li><p><del>Otherwise, if a field of that name is declared in the compilation unit (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.3">7.3</a>) containing the <em>Identifier</em> by a single-static-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.3">7.5.3</a>), or by a static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.4">7.5.4</a>) then the <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</del></p>
<div class="editorial">
<p>An imported field is specified to be in scope. It doesn't require an additional rule.</p>
</div></li>
<li><p>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and appears within the scope (<a href="#jls-6.3">6.3</a>) of a <del>top level class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8">8</a>) or interface type declaration (<a href="#jls-9">9</a>), a local class declaration (<a href="#jls-14.3">14.3</a>) or member type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>)</del> <strong>class, interface, or type parameter</strong> with that name, then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p>
<div class="editorial">
<p>Bug fix: this rule was never updated to account for type parameters.</p>
</div></li>
<li><p><del>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and a type of that name is declared in the compilation unit (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.3">7.3</a>) containing the <em>Identifier</em>, either by a single-type-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.1">7.5.1</a>), or by a type-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.2">7.5.2</a>), or by a single-static-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.3">7.5.3</a>), or by a static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.4">7.5.4</a>), then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</del></p>
<div class="editorial">
<p>An imported type is specified to be in scope. It doesn't require an additional rule.</p>
</div></li>
<li><p>Otherwise, the <em>AmbiguousName</em> is reclassified as a <em>PackageName</em>. A later step determines whether or not a package of that name actually exists.</p></li>
</ul>
<p>If the <em>AmbiguousName</em> is a qualified name, consisting of a name, a &quot;<code>.</code>&quot;, and an <em>Identifier</em>, then the name to the left of the &quot;<code>.</code>&quot; is first reclassified, for it is itself an <em>AmbiguousName</em>. There is then a choice:</p>
<ul>
<li><p>If the name to the left of the &quot;<code>.</code>&quot; is reclassified as a <em>PackageName</em>, then:</p>
<ul>
<li><p>If the <em>Identifier</em> is a valid <em>TypeIdentifier</em>, and there is a package whose name is the name to the left of the &quot;<code>.</code>&quot;, and that package contains a declaration of a type whose name is the same as the <em>Identifier</em>, then this <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, this <em>AmbiguousName</em> is reclassified as a <em>PackageName</em>. A later step determines whether or not a package of that name actually exists.</p></li>
</ul></li>
<li><p>If the name to the left of the &quot;<code>.</code>&quot; is reclassified as a <em>TypeName</em>, then:</p>
<ul>
<li><p>If the <em>Identifier</em> is the name of a method or field of the type denoted by <em>TypeName</em>, then this <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</p></li>
<li><p>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and is the name of a member type of the type denoted by <em>TypeName</em>, then this <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the name to the left of the &quot;<code>.</code>&quot; is reclassified as an <em>ExpressionName</em>, then this <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>. A later step determines whether or not a member with the name <em>Identifier</em> actually exists.</p></li>
</ul>
<blockquote>
<p>The requirement that a potential type name be &quot;a valid <em>TypeIdentifier</em>&quot; prevents treating <code>var</code> and <code>yield</code> as a type name. It is usually redundant, because the rules for declarations already prevent the introduction of types named <code>var</code> and <code>yield</code>. However, in some cases, a compiler may find a binary class named <code>var</code> or <code>yield</code>, and we want to be clear that such classes can never be named. The simplest solution is to consistently check for a valid <em>TypeIdentifier</em>.</p>
</blockquote>
<div class="example">
<p>Example 6.5.2-1. Reclassification of Contextually Ambiguous Names</p>
<p>Consider the following contrived &quot;library code&quot;:</p>
<pre><code>package org.rpgpoet;
import java.util.Random;
public interface Music { Random[] wizards = new Random[4]; }</code></pre>
<p>and then consider this example code in another package:</p>
<pre><code>package bazola;
class Gabriel {
    static int n = org.rpgpoet.Music.wizards.length;
}</code></pre>
<p>First of all, the name <code>org.rpgpoet.Music.wizards.length</code> is classified as an <em>ExpressionName</em> because it functions as a <em>PostfixExpression</em>. Therefore, each of the names:</p>
<pre><code>org.rpgpoet.Music.wizards
org.rpgpoet.Music
org.rpgpoet
org</code></pre>
<p>is initially classified as an <em>AmbiguousName</em>. These are then reclassified:</p>
<ul>
<li><p>The simple name <code>org</code> is reclassified as a <em>PackageName</em> (since there is no variable or type named org in scope).</p></li>
<li><p>Next, assuming that there is no class or interface named <code>rpgpoet</code> in any compilation unit of package <code>org</code> (and we know that there is no such class or interface because package <code>org</code> has a subpackage named <code>rpgpoet</code>), the qualified name <code>org.rpgpoet</code> is reclassified as a <em>PackageName</em>.</p></li>
<li><p>Next, because package <code>org.rpgpoet</code> has an accessible (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>) interface type named <code>Music</code>, the qualified name <code>org.rpgpoet.Music</code> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Finally, because the name <code>org.rpgpoet.Music</code> is a <em>TypeName</em>, the qualified name <code>org.rpgpoet.Music.wizards</code> is reclassified as an <em>ExpressionName</em>.</p></li>
</ul>
</div>
<h4 id="jls-6.5.5">6.5.5 Meaning of Type Names</h4>
<h5 id="jls-6.5.5.1">6.5.5.1 Simple Type Names</h5>
<p>If a type name consists of a single <em>Identifier</em>, then the identifier must occur in the scope of exactly one declaration of a class, interface, or type parameter with this name (<a href="#jls-6.3">6.3</a>), or a compile-time error occurs.</p>
<div class="inserted">
<p>If the declaration denotes a type parameter of a class or interface <em>C</em> (<a href="#jls-8.1.2">8.1.2</a>, <a href="#jls-9.1.2">9.1.2</a>), then both of the following must be true:</p>
<ul>
<li><p>The type name does not appear in a static context (<a href="#jls-8.1.3">8.1.3</a>).</p>
<blockquote>
<p>For example, the type name must not appear in the body of a static method declared by <em>C</em>.</p>
</blockquote></li>
<li><p>If the type name appears in a nested class or interface declaration in <em>C</em>, then the immediately enclosing class or interface declaration of the type name specifies an inner class (<a href="#jls-8.1.3">8.1.3</a>) of <em>C</em>.</p>
<blockquote>
<p>For example, the type name must not appear in the body of an instance method of a static class nested within <em>C</em>.</p>
</blockquote></li>
</ul>
<p>Otherwise, a compile-time error occurs.</p>
<p>If the declaration denotes a type parameter of a method or constructor <em>m</em> (<a href="#jls-8.4.4">8.4.4</a>, <a href="#jls-8.8.4">8.8.4</a>) declared by a class or interface <em>C</em>, then both of the following must be true:</p>
<ul>
<li><p>The type name does not appear in a static context except by virtue of being enclosed by <em>m</em>.</p>
<blockquote>
<p>For example, the type name must not appear in the body of a static method of a local class declared in the body of <em>m</em>.</p>
</blockquote></li>
<li><p>If the type name appears in a nested class or interface declaration of <em>C</em>, then the immediately enclosing class or interface declaration of the type name specifies an inner (<a href="#jls-8.1.3">8.1.3</a>) local or anonymous class declared in the body of <em>m</em>, or an inner class of an inner local or anonymous class declared in the body of <em>m</em>.</p>
<blockquote>
<p>For example, the type name must not appear in the body of a default method of a local interface declared in the body of <em>m</em>.</p>
</blockquote></li>
</ul>
<p>Otherwise, a compile-time error occurs.</p>
</div>
<p>The meaning of the type name is <del>that</del> <strong>the in-scope</strong> class, interface, or type parameter.</p>
<div class="inserted">
<div class="example">
<p>Example 6.5.5.1-1. References to Type Parameters</p>
<pre><code>class Box&lt;T&gt; {

    T val;

    T get() {
        return val;
    }

    static Box&lt;T&gt; empty() { // compile-time error
        return new Box&lt;&gt;(null);
    }

    static &lt;U&gt; Box&lt;U&gt; make(U val) {
        interface Checker {
            void check(U val); // compile-time error
        }
        class NullChecker implements Checker {
            void check(U val) {
                if (val == null) {
                    throw new IllegalArgumentException();
                }
            }
        }
        new NullChecker().check(val);
        return new Box&lt;U&gt;(val);
    }
}</code></pre>
<p>The class type parameter <code>T</code> is in scope throughout the declaration of class <code>Box</code>; however, using the name <code>T</code> in the static method declaration <code>empty</code> is illegal.</p>
<p>Similarly, the method type parameter <code>U</code> is in scope throughout the declaration of method <code>make</code>; however, using the name <code>U</code> in the (implicitly static) local interface declaration <code>Checker</code> is illegal.</p>
</div>
</div>
<h4 id="jls-6.5.6">6.5.6 Meaning of Expression Names</h4>
<h5 id="jls-6.5.6.1">6.5.6.1 Simple Expression Names</h5>
<p>If an expression name consists of a single <em>Identifier</em>, then there must be exactly one declaration denoting either a local variable, formal parameter, <strong>exception parameter,</strong> or field in scope at the point at which the <em>Identifier</em> occurs. Otherwise, a compile-time error occurs.</p>
<p>If the declaration denotes an instance variable <strong>of a class <em>C</em></strong> (<a href="#jls-8.3.1.1">8.3.1.1</a>), <del>the expression name must appear within an instance method (<a href="#jls-8.4.3.2">8.4.3.2</a>), instance variable initializer (<a href="#jls-8.3.2">8.3.2</a>), instance initializer (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.6">8.6</a>), or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>). If the expression name appears within a <code>static</code> type declaration, class method, class variable initializer, or static initializer (<a href="#jls-8.7">8.7</a>),</del> then <strong>both of the following must be true:</strong></p>
<div class="inserted">
<ul>
<li><p>The expression name does not appear in a static context (<a href="#jls-8.1.3">8.1.3</a>).</p>
<blockquote>
<p>For example, the expression name must not appear in the body of a static method declared by <em>C</em>.</p>
</blockquote></li>
<li><p>If the expression name appears in a nested class or interface declaration in <em>C</em>, then the immediately enclosing class or interface declaration of the expression name specifies an inner class (<a href="#jls-8.1.3">8.1.3</a>) of <em>C</em>.</p>
<blockquote>
<p>For example, the expression name must not appear in the body of an instance method of a static class nested within <em>C</em>.</p>
</blockquote></li>
</ul>
</div>
<p><strong>Otherwise,</strong> a compile-time error occurs.</p>
<div class="inserted">
<p>If the declaration denotes a local variable, formal parameter, or exception parameter, let <em>X</em> be the innermost method declaration, constructor declaration, instance initializer, static initializer, field declaration, or explicit constructor invocation statement enclosing the variable declaration, and let <em>C</em> be the immediately enclosing type declaration of <em>X</em>. Then both of the following must be true:</p>
<ul>
<li><p>The expression name does not appear in a static context except by virtue of being enclosed by <em>X</em>, and</p>
<blockquote>
<p>For example, the expression name must not appear in the body of a static method of a local class declared in the body of <em>m</em>.</p>
</blockquote></li>
<li><p>If the expression name appears in a nested class or interface declaration in <em>C</em>, then the immediately enclosing class or interface declaration of the expression name specifies an inner (<a href="#jls-8.1.3">8.1.3</a>) local or anonymous class declared in <em>X</em>, or an inner class of an inner local or anonymous class declared in <em>X</em>.</p>
<blockquote>
<p>For example, the expression name must not appear in the body of a default method of a local interface declared in the body of <em>m</em>.</p>
</blockquote></li>
</ul>
<p>Otherwise, a compile-time error occurs.</p>
<p>In addition, if the declaration denotes a local variable, formal parameter, or exception parameter that is neither <code>final</code> nor effectively final (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>), it is a compile-time error if the expression name appears within an inner class or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27">15.27</a>) contained by <em>X</em>.</p>
</div>
<p>If the declaration declares a <code>final</code> variable which is definitely assigned before the simple expression, the meaning of the name is the value of that variable. Otherwise, the meaning of the expression name is the variable declared by the declaration.</p>
<p>If the expression name appears in an assignment context, invocation context, or casting context, then the type of the expression name is the declared type of the field, local variable, or parameter after capture conversion (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>).</p>
<p>Otherwise, the type of the expression name is the declared type of the field, local variable or parameter.</p>
<blockquote>
<p>That is, if the expression name appears &quot;on the right hand side&quot;, its type is subject to capture conversion. If the expression name is a variable that appears &quot;on the left hand side&quot;, its type is not subject to capture conversion.</p>
</blockquote>
<div class="example">
<p>Example 6.5.6.1-1. Simple Expression Names</p>
<pre><code>class Test {
    static int v;
    static final int f = 3;
    public static void main(String[] args) {
        int i;
        i = 1;
        v = 2;
        f = 33;  // compile-time error
        System.out.println(i + &quot; &quot; + v + &quot; &quot; + f);
    }
}</code></pre>
<p>In this program, the names used as the left-hand-sides in the assignments to <code>i</code>, <code>v</code>, and <code>f</code> denote the local variable <code>i</code>, the field <code>v</code>, and the value of <code>f</code> (not the variable <code>f</code>, because <code>f</code> is a <code>final</code> variable). The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side. If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:</p>
<pre><code>1 2 3</code></pre>
</div>
<div class="inserted">
<div class="example">
<p>Example 6.5.6.1-2. References to Instance Variables</p>
<pre><code>class InstanceVariableTest {
    static String a;
    String b;

    String concat() {
        return a + b;
    }

    static String staticConcat() {
        return a + b; // compile-time error
    }

    int index() {
        interface I {
            class Matcher {

                void check() {
                    if (a == null ||
                        b == null) { // compile-time error
                        throw new IllegalArgumentException();
                    }                        
                }

                int match(String s, String t) {
                    return s.indexOf(t);
                }
            }
        }
        
        I.Matcher matcher = new I.Matcher();
        matcher.check();
        matcher.match(a, b);
    }

}</code></pre>
<p>The fields <code>a</code> and <code>b</code> are in scope throughout the body of class <code>InstanceVariableTest</code>. However, using the name <code>b</code> in the static context of the <code>staticConcat</code> method, or in the nested class declaration <code>Matcher</code> that is not an inner class of <code>InstanceVariableTest</code>, is illegal.</p>
</div>
<div class="example">
<p>Example 6.5.6.1-3. References to Local Variables and Formal Parameters</p>
<pre><code>class LocalVariableTest {

    public static void main(String[] args) {
        String first = args[0];

        class Checker {
            
            void checkWhitespace(int x) {
                String arg = args[x];
                if (!arg.trim().equals(arg)) {
                    throw new IllegalArgumentException();
                }
            }

            static void checkFlag(int x) {
                String arg = args[x]; // compile-time error
                if (!arg.startsWith(&quot;-&quot;)) {
                    throw new IllegalArgumentException();
                }
            }

            static void checkFirst() {
                 Runnable r = new Runnable() {
                     public void run() {
                         if (first == null) { // compile-time error
                             throw new IllegalArgumentException();
                         }
                     }
                 };
                 r.run();
             }
        }
        
        final Checker c = new Checker();
        c.checkFirst();
        for (int i = 1; i &lt; args.length; i++) {
            Runnable r = () -&gt; {
                c.checkWhitespace(i); // compile-time error
                c.checkFlag(i); // compile-time error
            }
        }
    }
}</code></pre>
<p>The formal parameter <code>args</code> is in scope throughout the body of method <code>main</code>. <code>args</code> is effectively final, so the name <code>args</code> can be used in the instance method <code>checkWhitespace</code> of local class <code>Checker</code>. However, using the name <code>args</code> in the static context of the <code>checkFlag</code> method of local class <code>Checker</code> is illegal.</p>
<p>The local variable <code>first</code> is in scope for the remainder of the body of method <code>main</code>. <code>first</code> is also effectively final. However, the anonymous class in <code>checkFirst</code> is not an inner class of <code>Checker</code>, so using the name <code>first</code> in the anonymous class body is illegal.</p>
<p>The local variable <code>c</code> is in scope for the last few lines of the body of method <code>main</code>, and is declared <code>final</code>, so the name <code>c</code> can be used in the body of the lambda expression.</p>
<p>The local variable <code>i</code> is in scope throughout the <code>for</code> loop. However, <code>i</code> is <em>not</em> effectively final, so using the name <code>i</code> in the body of the lambda expression is illegal.</p>
</div>
</div>
<h4 id="jls-6.5.7">6.5.7 Meaning of Method Names</h4>
<h5 id="jls-6.5.7.1">6.5.7.1 Simple Method Names</h5>
<p>A simple method name appears in the context of a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>). The simple method name consists of a single <em>Identifier</em> which specifies the name of the method to be invoked. The rules of method invocation <strong>(<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>)</strong> require that the <em>Identifier</em> <del>either</del> denotes a method that is in scope at the point of the method invocation<del>, or denotes a method imported by a single-static-import declaration or static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.3">7.5.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.5.4">7.5.4</a>)</del>. <strong>The rules also prohibit (<a href="#jls-15.12.3">15.12.3</a>) a reference to an instance method occurring in a static context (<a href="#jls-8.1.3">8.1.3</a>) or from a nested class or interface other than an inner class of the class or interface declaring <em>m</em>.</strong></p>
<div class="editorial">
<p>The details of the restriction on references to instance methods appear in <a href="#jls-15.12.3">15.12.3</a>, but it's useful to mention them here, for consistency with <a href="#jls-6.5.5.1">6.5.5.1</a> and <a href="#jls-6.5.6.1">6.5.6.1</a>.</p>
<p>The clause about imports is unnecessary: the scoping rules (<a href="#jls-6.3">6.3</a>) already establish that such methods are in scope.</p>
</div>
<div class="example">
<p>Example 6.5.7.1-1. Simple Method Names</p>
<p>The following program demonstrates the role of scoping when determining which method to invoke.</p>
<pre><code>class Super {
    void f2(String s)       {}
    void f3(String s)       {}
    void f3(int i1, int i2) {}
}

class Test {
    void f1(int i) {}
    void f2(int i) {}
    void f3(int i) {}

    void m() {
        new Super() {
            {
                f1(0);  // OK, resolves to Test.f1(int)
                f2(0);  // compile-time error
                f3(0);  // compile-time error
            }
        };
    }
}</code></pre>
<p>For the invocation <code>f1(0)</code>, only one method named <code>f1</code> is in scope. It is the method <code>Test.f1(int)</code>, whose declaration is in scope throughout the body of <code>Test</code> including the anonymous class declaration. <a href="#jls-15.12.1">15.12.1</a> chooses to search in class <code>Test</code> since the anonymous class declaration has no member named <code>f1</code>. Eventually, <code>Test.f1(int)</code> is resolved.</p>
<p>For the invocation <code>f2(0)</code>, two methods named <code>f2</code> are in scope. First, the declaration of the method <code>Super.f2(String)</code> is in scope throughout the anonymous class declaration. Second, the declaration of the method <code>Test.f2(int)</code> is in scope throughout the body of <code>Test</code> including the anonymous class declaration. (Note that neither declaration shadows the other, because at the point where each is declared, the other is not in scope.) <a href="#jls-15.12.1">15.12.1</a> chooses to search in class <code>Super</code> because it has a member named <code>f2</code>. However, <code>Super.f2(String)</code> is not applicable to <code>f2(0)</code>, so a compile-time error occurs. Note that class <code>Test</code> is not searched.</p>
<p>For the invocation <code>f3(0)</code>, three methods named <code>f3</code> are in scope. First and second, the declarations of the methods <code>Super.f3(String)</code> and <code>Super.f3(int,int)</code> are in scope throughout the anonymous class declaration. Third, the declaration of the method <code>Test.f3(int)</code> is in scope throughout the body of <code>Test</code> including the anonymous class declaration. <a href="#jls-15.12.1">15.12.1</a> chooses to search in class <code>Super</code> because it has a member named <code>f3</code>. However, <code>Super.f3(String)</code> and <code>Super.f3(int,int)</code> are not applicable to <code>f3(0)</code>, so a compile-time error occurs. Note that class <code>Test</code> is not searched.</p>
<p>Choosing to search a nested class's superclass hierarchy before the lexically enclosing scope is called the &quot;comb rule&quot; (<a href="#jls-15.12.1">15.12.1</a>).</p>
</div>
<h3 id="jls-6.7">6.7 Fully Qualified Names and Canonical Names</h3>
<p>Every primitive type, named package, top level class, and top level interface has a <em>fully qualified name</em>:</p>
<ul>
<li><p>The fully qualified name of a primitive type is the keyword for that primitive type, namely <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, or <code>boolean</code>.</p></li>
<li><p>The fully qualified name of a named package that is not a subpackage of a named package is its simple name.</p></li>
<li><p>The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by &quot;<code>.</code>&quot;, followed by the simple (member) name of the subpackage.</p></li>
<li><p>The fully qualified name of a top level class or top level interface that is declared in an unnamed package is the simple name of the class or interface.</p></li>
<li><p>The fully qualified name of a top level class or top level interface that is declared in a named package consists of the fully qualified name of the package, followed by &quot;<code>.</code>&quot;, followed by the simple name of the class or interface.</p></li>
</ul>
<p>Each member class, member interface, and array type <em>may</em> have a fully qualified name:</p>
<ul>
<li><p>A member class or member interface <em>M</em> of another class or interface <em>C</em> has a fully qualified name if and only if <em>C</em> has a fully qualified name.</p>
<p>In that case, the fully qualified name of <em>M</em> consists of the fully qualified name of <em>C</em>, followed by &quot;<code>.</code>&quot;, followed by the simple name of <em>M</em>.</p></li>
<li><p>An array type has a fully qualified name if and only if its element type has a fully qualified name.</p>
<p>In that case, the fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by &quot;<code>[]</code>&quot;.</p></li>
</ul>
<p>A local class<strong>, local interface,</strong> or anonymous class does not have a fully qualified name.</p>
<p>Every primitive type, named package, top level class, and top level interface has a <em>canonical name</em>:</p>
<ul>
<li>For every primitive type, named package, top level class, and top level interface, the canonical name is the same as the fully qualified name.</li>
</ul>
<p>Each member class, member interface, and array type <em>may</em> have a canonical name:</p>
<ul>
<li><p>A member class or member interface <em>M</em> declared in another class or interface <em>C</em> has a canonical name if and only if <em>C</em> has a canonical name.</p>
<p>In that case, the canonical name of <em>M</em> consists of the canonical name of <em>C</em>, followed by &quot;<code>.</code>&quot;, followed by the simple name of <em>M</em>.</p></li>
<li><p>An array type has a canonical name if and only if its component type has a canonical name.</p>
<p>In that case, the canonical name of the array type consists of the canonical name of the component type of the array type followed by &quot;<code>[]</code>&quot;.</p></li>
</ul>
<p>A local class<strong>, local interface,</strong> or anonymous class does not have a canonical name.</p>
<div class="example">
<p>Example 6.7-1. Fully Qualified Names</p>
<ul>
<li><p>The fully qualified name of the type <code>long</code> is &quot;<code>long</code>&quot;.</p></li>
<li><p>The fully qualified name of the package <code>java.lang</code> is &quot;<code>java.lang</code>&quot; because it is subpackage <code>lang</code> of package <code>java</code>.</p></li>
<li><p>The fully qualified name of the class <code>Object</code>, which is defined in the package <code>java.lang</code>, is &quot;<code>java.lang.Object</code>&quot;.</p></li>
<li><p>The fully qualified name of the interface <code>Enumeration</code>, which is defined in the package <code>java.util</code>, is &quot;<code>java.util.Enumeration</code>&quot;.</p></li>
<li><p>The fully qualified name of the type &quot;array of <code>double</code>&quot; is &quot;<code>double[]</code>&quot;.</p></li>
<li><p>The fully qualified name of the type &quot;array of array of array of array of <code>String</code>&quot; is &quot;<code>java.lang.String[][][][]</code>&quot;.</p></li>
</ul>
<p>In the code:</p>
<pre><code>package points;
class Point    { int x, y; }
class PointVec { Point[] vec; }</code></pre>
<p>the fully qualified name of the type <code>Point</code> is &quot;<code>points.Point</code>&quot;; the fully qualified name of the type <code>PointVec</code> is &quot;<code>points.PointVec</code>&quot;; and the fully qualified name of the type of the field <code>vec</code> of class <code>PointVec</code> is &quot;<code>points.Point[]</code>&quot;.</p>
</div>
<div class="example">
<p>Example 6.7-2. Fully Qualified Names v. Canonical Name</p>
<p>The difference between a fully qualified name and a canonical name can be seen in code such as:</p>
<pre><code>package p;
class O1 { class I {} }
class O2 extends O1 {}</code></pre>
<p>Both <code>p.O1.I</code> and <code>p.O2.I</code> are fully qualified names that denote the member class <code>I</code>, but only <code>p.O1.I</code> is its canonical name.</p>
</div>
<h2 id="jls-8">Chapter 8: Classes</h2>
<h3 id="jls-8.1">8.1 Class Declarations</h3>
<h4 id="jls-8.1.1">8.1.1 Class Modifiers</h4>
<p>A class declaration may include <em>class modifiers</em>.</p>
<dl>
<dt><em>ClassModifier:</em></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code> <code>protected</code> <code>private</code>
</dd>
<dd><code>abstract</code> <code>static</code> <code>final</code> <code>strictfp</code>
</dd>
</dl>
<p>The rules for annotation modifiers on a class declaration are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>The access modifier <code>public</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>) pertains only to top level classes (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.6">7.6</a>) and member classes (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>).</p>
<p>The <strong>access</strong> modifiers <code>protected</code><del>,</del> <strong>and</strong> <code>private</code><del>, and <code>static</code></del> pertain only to member classes.</p>
<p><strong>The modifier <code>static</code> pertains only to member classes and local classes (<a href="#jls-14.3">14.3</a>).</strong></p>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<blockquote>
<p>If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>ClassModifier</em>.</p>
</blockquote>
<h5 id="jls-8.1.1.1">8.1.1.1 <code>abstract</code> Classes</h5>
<p>An <code>abstract</code> class is a class that is incomplete, or to be considered incomplete.</p>
<p>It is a compile-time error if an attempt is made to create an instance of an <code>abstract</code> class using a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.1">15.9.1</a>).</p>
<p>...</p>
<h5 id="jls-8.1.1.2">8.1.1.2 <code>final</code> Classes</h5>
<p>A class can be declared <code>final</code> if its definition is complete and no subclasses are desired or required.</p>
<p>It is a compile-time error if the name of a <code>final</code> class appears in the <code>extends</code> clause (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.4">8.1.4</a>) of another class declaration; this implies that a <code>final</code> class cannot have any subclasses.</p>
<p>It is a compile-time error if a class is declared both <code>final</code> and <code>abstract</code>, because the implementation of such a class could never be completed (<a href="#jls-8.1.1.1">8.1.1.1</a>).</p>
<p>Because a <code>final</code> class never has any subclasses, the methods of a <code>final</code> class are never overridden (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.8.1">8.4.8.1</a>).</p>
<h5 id="jls-8.1.1.3">8.1.1.3 <code>strictfp</code> Classes</h5>
<p>The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double</code> expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.4">15.4</a>).</p>
<p>This implies that all methods declared in the class, and all nested classes and interfaces declared in the class, are implicitly <code>strictfp</code>.</p>
<h5 id="jls-8.1.1.4"><strong>8.1.1.4 <code>static</code> Classes</strong></h5>
<div class="inserted">
<p>The <code>static</code> keyword indicates that a nested class is not an inner class (<a href="#jls-8.1.3">8.1.3</a>). The class has no immediately enclosing instance and cannot directly reference enclosing type variables (<a href="#jls-6.5.5.1">6.5.5.1</a>); enclosing instance variables, local variables, formal parameters, or exception parameters (<a href="#jls-6.5.6.1">6.5.6.1</a>); or enclosing instance methods (<a href="#jls-15.12.3">15.12.3</a>).</p>
<p>A local class declaration may not use the <code>static</code> keyword (<a href="#jls-14.3">14.3</a>).</p>
<p>Nested enum classes are implicitly declared <code>static</code>. A member enum class may redundantly specify the <code>static</code> modifier; a local enum class may not (<a href="#jls-8.9">8.9</a>).</p>
</div>
<h4 id="jls-8.1.2">8.1.2 Generic Classes and Type Parameters</h4>
<p>A class is <em>generic</em> if it declares one or more type variables (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>).</p>
<p>These type variables are known as the <em>type parameters</em> of the class. The type parameter section follows the class name and is delimited by angle brackets.</p>
<dl>
<dt><em>TypeParameters:</em></dt>
<dd><code>&lt;</code> <em>TypeParameterList</em> <code>&gt;</code>
</dd>
<dt><em>TypeParameterList:</em></dt>
<dd><em>TypeParameter</em> {<code>,</code> <em>TypeParameter</em>}
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>TypeParameter:</em></dt>
<dd>{<em>TypeParameterModifier</em>} <em>TypeIdentifier</em> [<em>TypeBound</em>]
</dd>
<dt><em>TypeParameterModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
<dt><em>TypeBound:</em></dt>
<dd><code>extends</code> <em>TypeVariable</em>
</dd>
<dd><code>extends</code> <em>ClassOrInterfaceType</em> {<em>AdditionalBound</em>}
</dd>
<dt><em>AdditionalBound:</em></dt>
<dd><code>&amp;</code> <em>InterfaceType</em>
</dd>
</dl>
</blockquote>
<p>The rules for annotation modifiers on a type parameter declaration are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>In a class's type parameter section, a type variable <em>T</em> <em>directly depends</em> on a type variable <em>S</em> if <em>S</em> is the bound of <em>T</em>, while <em>T</em> <em>depends</em> on <em>S</em> if either <em>T</em> directly depends on <em>S</em> or <em>T</em> directly depends on a type variable <em>U</em> that depends on <em>S</em> (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself.</p>
<p>The scope and shadowing of a class's type parameter is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to a class's type parameter from a static context or a nested class are restricted, as specified in <a href="#jls-6.5.5.1">6.5.5.1</a>.</strong></p>
<p>A generic class declaration defines a set of parameterized types (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5">4.5</a>), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time.</p>
<blockquote>
<p>For instance, executing the code:</p>
<pre><code>Vector&lt;String&gt;  x = new Vector&lt;String&gt;();
Vector&lt;Integer&gt; y = new Vector&lt;Integer&gt;();
boolean b = x.getClass() == y.getClass();</code></pre>
<p>will result in the variable <code>b</code> holding the value <code>true</code>.</p>
</blockquote>
<p>It is a compile-time error if a generic class is a direct or indirect subclass of <code>Throwable</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.1.1">11.1.1</a>).</p>
<blockquote>
<p>This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes.</p>
</blockquote>
<div class="deleted">
<p>It is a compile-time error to refer to a type parameter of a generic class <em>C</em> in any of the following:</p>
<ul>
<li><p>the declaration of a <code>static</code> member of <em>C</em> (<a href="#jls-8.3.1.1">8.3.1.1</a>, <a href="#jls-8.4.3.2">8.4.3.2</a>, <a href="#jls-8.5.1">8.5.1</a>).</p></li>
<li><p>the declaration of a <code>static</code> member of any type declaration nested within <em>C</em>.</p></li>
<li><p>a static initializer of <em>C</em> (<a href="#jls-8.7">8.7</a>), or</p></li>
<li><p>a static initializer of any class declaration nested within <em>C</em>.</p></li>
</ul>
</div>
<div class="editorial">
<p>These restrictions are now specified in <a href="#jls-6.5.5.1">6.5.5.1</a>, directly at the point where the reference occurs.</p>
</div>
<div class="example">
<p>Example 8.1.2-1. Mutually Recursive Type Variable Bounds</p>
<pre><code>interface ConvertibleTo&lt;T&gt; {
    T convert();
}
class ReprChange&lt;T extends ConvertibleTo&lt;S&gt;,
                 S extends ConvertibleTo&lt;T&gt;&gt; {
    T t;
    void set(S s) { t = s.convert();    }
    S get()       { return t.convert(); }
}</code></pre>
</div>
<div class="example">
<p>Example 8.1.2-2. Nested Generic Classes</p>
<pre><code>class Seq&lt;T&gt; {
    T      head;
    Seq&lt;T&gt; tail;

    Seq() { this(null, null); }
    Seq(T head, Seq&lt;T&gt; tail) {
        this.head = head;
        this.tail = tail;
    }
    boolean isEmpty() { return tail == null; }

    class Zipper&lt;S&gt; {
        Seq&lt;Pair&lt;T,S&gt;&gt; zip(Seq&lt;S&gt; that) {
            if (isEmpty() || that.isEmpty()) {
                return new Seq&lt;Pair&lt;T,S&gt;&gt;();
            } else {
                Seq&lt;T&gt;.Zipper&lt;S&gt; tailZipper =
                    tail.new Zipper&lt;S&gt;();
                return new Seq&lt;Pair&lt;T,S&gt;&gt;(
                    new Pair&lt;T,S&gt;(head, that.head),
                    tailZipper.zip(that.tail));
            }
        }
    }
}
class Pair&lt;T, S&gt; {
    T fst; S snd;
    Pair(T f, S s) { fst = f; snd = s; }
}
class Test {
    public static void main(String[] args) {
        Seq&lt;String&gt; strs =
            new Seq&lt;String&gt;(
                &quot;a&quot;,
                new Seq&lt;String&gt;(&quot;b&quot;,
                                new Seq&lt;String&gt;()));
        Seq&lt;Number&gt; nums =
            new Seq&lt;Number&gt;(
                new Integer(1),
                new Seq&lt;Number&gt;(new Double(1.5),
                                new Seq&lt;Number&gt;()));

        Seq&lt;String&gt;.Zipper&lt;Number&gt; zipper =
            strs.new Zipper&lt;Number&gt;();

        Seq&lt;Pair&lt;String,Number&gt;&gt; combined =
            zipper.zip(nums);
    }
}</code></pre>
</div>
<h4 id="jls-8.1.3">8.1.3 Inner Classes and Enclosing Instances</h4>
<p>An <em>inner class</em> is a nested class that is not explicitly or implicitly declared <code>static</code>.</p>
<p>An inner class may be a non-<code>static</code> member class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>), a <strong>non-<code>static</code></strong> local class (<a href="#jls-14.3">14.3</a>), or an anonymous class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.5">15.9.5</a>). <del>A member class of an interface is implicitly <code>static</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>) so is never considered to be an inner class.</del> <strong>Nested interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1">9.1</a>), nested enum classes (<a href="#jls-8.9">8.9</a>), member annotation interfaces (<a href="#jls-9.6">9.6</a>), and member classes of interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>) are implicitly <code>static</code>, so are never considered to be inner classes.</strong></p>
<div class="deleted">
<p>It is a compile-time error if an inner class declares a static initializer (<a href="#jls-8.7">8.7</a>).</p>
<p>It is a compile-time error if an inner class declares a member that is explicitly or implicitly <code>static</code>, unless the member is a constant variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>An inner class may inherit <code>static</code> members that are not constant variables even though it cannot declare them.</p>
<p>A nested class that is not an inner class may declare <code>static</code> members freely, in accordance with the usual rules of the Java programming language.</p>
<div class="example">
<p>Example 8.1.3-1. Inner Class Declarations and Static Members</p>
<pre><code>class HasStatic {
    static int j = 100;
}
class Outer {
    class Inner extends HasStatic {
        static final int x = 3;  // OK: constant variable
        static int y = 4;  // Compile-time error: an inner class
    }
    static class NestedButNotInner{
        static int z = 5;    // OK: not an inner class
    }
    interface NeverInner {}  // Interfaces are never inner
}</code></pre>
</div>
</div>
<div class="editorial">
<p>By eliminating these rules, we permit arbitrary <code>static</code> member declarations within inner classes.</p>
</div>
<p>A statement or expression <em>occurs in a static context</em> if and only if the innermost method <strong>declaration</strong>, constructor <strong>declaration</strong>, instance initializer, static initializer, field <del>initializer</del> <strong>declaration</strong>, or explicit constructor invocation statement enclosing the statement or expression is a static method <strong>declaration</strong>, a static initializer, <del>the variable initializer of a static variable</del> <strong>a <code>static</code> field declaration</strong>, or an explicit constructor invocation statement (<a href="#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>An inner class <em>C</em> is a <em>direct inner class of a class or interface O</em> if <em>O</em> is the immediately enclosing class or interface declaration of <em>C</em> and the declaration of <em>C</em> does not occur in a static context.</p>
<blockquote>
<p>If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface.</p>
</blockquote>
<p>A class <em>C</em> is an <em>inner class of class or interface O</em> if it is either a direct inner class of <em>O</em> or an inner class of an inner class of <em>O</em>.</p>
<blockquote>
<p>It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body (<a href="#jls-9.4">9.4</a>).</p>
</blockquote>
<p>A class or interface <em>O</em> is the <em>zeroth lexically enclosing type declaration of itself</em>.</p>
<p>A class <em>O</em> is the <em>n'th lexically enclosing type declaration of a class C</em> if it is the immediately enclosing type declaration of the <em>n-1</em>'th lexically enclosing type declaration of <em>C</em>.</p>
<p>An instance <em>i</em> of a direct inner class <em>C</em> of a class or interface <em>O</em> is associated with an instance of <em>O</em>, known as the <em>immediately enclosing instance of i</em>. The immediately enclosing instance of an object, if any, is determined when the object is created (<a href="#jls-15.9.2">15.9.2</a>).</p>
<p>An object <em>o</em> is the <em>zeroth lexically enclosing instance of itself</em>.</p>
<p>An object <em>o</em> is the <em>n'th lexically enclosing instance of an instance i</em> if it is the immediately enclosing instance of the <em>n-1</em>'th lexically enclosing instance of <em>i</em>.</p>
<p>An instance of <del>a</del> <strong>an inner</strong> local class or an anonymous class whose declaration occurs in a static context has no lexically enclosing instances.</p>
<p>For every superclass <em>S</em> of <em>C</em> which is itself a direct inner class of a class or interface <em>SO</em>, there is an instance of <em>SO</em> associated with <em>i</em>, known as the <em>immediately enclosing instance of i with respect to S</em>. The immediately enclosing instance of an object with respect to its class's direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement (<a href="#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used.</p>
<p><del>Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared <code>final</code> or be effectively final (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>), or a compile-time error occurs where the use is attempted.</del></p>
<p>Any local variable used but not declared in an inner class must be definitely assigned (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-16.html">16</a>) before the body of the inner class, or a compile-time error occurs.</p>
<blockquote>
<p><del>Similar rules on variable use apply in the body of a lambda expression (<a href="#jls-15.27.2">15.27.2</a>).</del></p>
</blockquote>
<p>A blank <code>final</code> field (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs.</p>
<div class="editorial">
<p>The restrictions on references to non-<code>final</code> variables are now specified in <a href="#jls-6.5.6.1">6.5.6.1</a>, directly at the point where the reference occurs.</p>
<p>The rules about definite assignment are probably redundant, but that's beyond the scope of this change.</p>
</div>
<div class="example">
<p>Example 8.1.3-2. Inner Class Declarations</p>
<pre><code>class Outer {
    int i = 100;
    static void classMethod() {
        final int l = 200;
        class LocalInStaticContext {
            int k = i;  // Compile-time error
            int m = l;  // OK
        }
    }
    void foo() {
        class Local {  // A local class
            int j = i;
        }
    }
}</code></pre>
<p>The declaration of class <code>LocalInStaticContext</code> occurs in a static context due to being within the static method <code>classMethod</code>. Instance variables of class <code>Outer</code> are not available within the body of a static method. In particular, instance variables of <code>Outer</code> are not available inside the body of <code>LocalInStaticContext</code>. However, local variables from the surrounding method may be referred to without error (provided they are declared <code>final</code> or are effectively final).</p>
<p>Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class <code>Local</code> above has an enclosing instance of class <code>Outer</code>. As a further example:</p>
<pre><code>class WithDeepNesting {
    boolean toBe;
    WithDeepNesting(boolean b) { toBe = b; }

    class Nested {
        boolean theQuestion;
        class DeeplyNested {
            DeeplyNested(){
                theQuestion = toBe || !toBe;
            }
        }
    }
}</code></pre>
<p>Here, every instance of <code>WithDeepNesting.Nested.DeeplyNested</code> has an enclosing instance of class <code>WithDeepNesting.Nested</code> (its immediately enclosing instance) and an enclosing instance of class <code>WithDeepNesting</code> (its 2nd lexically enclosing instance).</p>
</div>
<h3 id="jls-8.3">8.3 Field Declarations</h3>
<h4 id="jls-8.3.1">8.3.1 Field Modifiers</h4>
<h5 id="jls-8.3.1.1">8.3.1.1 <code>static</code> Fields</h5>
<p>If a field is declared <code>static</code>, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A <code>static</code> field, sometimes called a class variable, is incarnated when the class is initialized (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.4">12.4</a>).</p>
<p><strong>A static field declaration introduces a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<p>A field that is not declared <code>static</code> (sometimes called a non-<code>static</code> field) is called an <em>instance variable</em>. Whenever a new instance of a class is created (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.5">12.5</a>), a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses.</p>
<p><strong>References to an instance variable from a static context or a nested class are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<div class="example">
<p>Example 8.3.1.1-1. <code>static</code> Fields</p>
<pre><code>class Point {
    int x, y, useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}
class Test {
    public static void main(String[] args) {
        Point p = new Point(1,1);
        Point q = new Point(2,2);
        p.x = 3;
        p.y = 3;
        p.useCount++;
        p.origin.useCount++;
        System.out.println(&quot;(&quot; + q.x + &quot;,&quot; + q.y + &quot;)&quot;);
        System.out.println(q.useCount);
        System.out.println(q.origin == Point.origin);
        System.out.println(q.origin.useCount);
    }
}</code></pre>
<p>This program prints:</p>
<pre><code>(2,2)
0
true
1</code></pre>
<p>showing that changing the fields <code>x</code>, <code>y</code>, and <code>useCount</code> of <code>p</code> does not affect the fields of <code>q</code>, because these fields are instance variables in distinct objects. In this example, the class variable <code>origin</code> of the class <code>Point</code> is referenced both using the class name as a qualifier, in <code>Point.origin</code>, and using variables of the class type in field access expressions (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11">15.11</a>), as in <code>p.origin</code> and <code>q.origin</code>. These two ways of accessing the <code>origin</code> class variable access the same object, evidenced by the fact that the value of the reference equality expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.21.3">15.21.3</a>):</p>
<pre><code>q.origin==Point.origin</code></pre>
<p>is true. Further evidence is that the incrementation:</p>
<pre><code>p.origin.useCount++;</code></pre>
<p>causes the value of <code>q.origin.useCount</code> to be <code>1</code>; this is so because <code>p.origin</code> and <code>q.origin</code> refer to the same variable.</p>
</div>
<div class="example">
<p>Example 8.3.1.1-2. Hiding of Class Variables</p>
<pre><code>class Point {
    static int x = 2;
}
class Test extends Point {
    static double x = 4.7;
    public static void main(String[] args) {
        new Test().printX();
    }
    void printX() {
        System.out.println(x + &quot; &quot; + super.x);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>4.7 2</code></pre>
<p>because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. Within the declaration of class <code>Test</code>, the simple name <code>x</code> refers to the field declared within class <code>Test</code>. Code in class <code>Test</code> may refer to the field <code>x</code> of class <code>Point</code> as <code>super.x</code> (or, because <code>x</code> is <code>static</code>, as <code>Point.x</code>). If the declaration of <code>Test.x</code> is deleted:</p>
<pre><code>class Point {
    static int x = 2;
}
class Test extends Point {
    public static void main(String[] args) {
        new Test().printX();
    }
    void printX() {
        System.out.println(x + &quot; &quot; + super.x);
    }
}</code></pre>
<p>then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>; instead, the simple name <code>x</code> now refers to the field <code>Point.x</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. Therefore, the output from this variant program is:</p>
<pre><code>2 2</code></pre>
</div>
<div class="example">
<p>Example 8.3.1.1-3. Hiding of Instance Variables</p>
<pre><code>class Point {
    int x = 2;
}
class Test extends Point {
    double x = 4.7;
    void printBoth() {
        System.out.println(x + &quot; &quot; + super.x);
    }
    public static void main(String[] args) {
        Test sample = new Test();
        sample.printBoth();
        System.out.println(sample.x + &quot; &quot; + ((Point)sample).x);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>4.7 2
4.7 2</code></pre>
<p>because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. It must be noted, however, that while the field <code>x</code> of class <code>Point</code> is not inherited by class <code>Test</code>, it is nevertheless <em>implemented</em> by instances of class <code>Test</code>. In other words, every instance of class <code>Test</code> contains two fields, one of type <code>int</code> and one of type <code>double</code>. Both fields bear the name <code>x</code>, but within the declaration of class <code>Test</code>, the simple name <code>x</code> always refers to the field declared within class <code>Test</code>. Code in instance methods of class <code>Test</code> may refer to the instance variable <code>x</code> of class <code>Point</code> as <code>super.x</code>.</p>
<p>Code that uses a field access expression to access field <code>x</code> will access the field named <code>x</code> in the class indicated by the type of reference expression. Thus, the expression <code>sample.x</code> accesses a <code>double</code> value, the instance variable declared in class <code>Test</code>, because the type of the variable <code>sample</code> is <code>Test</code>, but the expression <code>((Point)sample).x</code> accesses an <code>int</code> value, the instance variable declared in class <code>Point</code>, because of the cast to type <code>Point</code>.</p>
<p>If the declaration of <code>x</code> is deleted from class <code>Test</code>, as in the program:</p>
<pre><code>class Point {
    static int x = 2;
}
class Test extends Point {
    void printBoth() {
        System.out.println(x + &quot; &quot; + super.x);
    }
    public static void main(String[] args) {
        Test sample = new Test();
        sample.printBoth();
        System.out.println(sample.x + &quot; &quot; + ((Point)sample).x);
    }
}</code></pre>
<p>then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>. Within instance methods in the declaration of class <code>Test</code>, the simple name <code>x</code> now refers to the field declared within class <code>Point</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. The expression <code>sample.x</code> still refers to the field <code>x</code> within type <code>Test</code>, but that field is now an inherited field, and so refers to the field <code>x</code> declared in class <code>Point</code>. The output from this variant program is:</p>
<pre><code>2 2
2 2</code></pre>
</div>
<h4 id="jls-8.3.2">8.3.2 Field Initialization</h4>
<p>If a declarator in a field declaration has a <em>variable initializer</em>, then the declarator has the semantics of an assignment (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.26">15.26</a>) to the declared variable.</p>
<p>If the declarator is for a class variable (that is, a <code>static</code> field), then <del>the following rules apply to its initializer:</del> <strong>at run time, the initializer is evaluated and the assignment performed exactly once, when the class is initialized (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.4.2">12.4.2</a>).</strong></p>
<div class="deleted">
<ul>
<li><p>It is a compile-time error if a reference by simple name to any instance variable occurs in the initializer.</p></li>
<li><p>It is a compile-time error if the keyword <code>this</code> (<a href="#jls-15.8.3">15.8.3</a>) or the keyword <code>super</code> (<a href="#jls-15.11.2">15.11.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>) occurs in the initializer.</p></li>
<li><p>At run time, the initializer is evaluated and the assignment performed exactly once, when the class is initialized (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.4.2">12.4.2</a>).</p>
<p>Note that <code>static</code> fields that are constant variables (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>) are initialized before other <code>static</code> fields (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.4.2">12.4.2</a>). This also applies in interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3.1">9.3.1</a>). When such fields are referenced by simple name, they will never be observed to have their default initial values (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.5">4.12.5</a>).</p></li>
</ul>
</div>
<blockquote>
<p><strong>Note that <code>static</code> fields that are constant variables (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>) are initialized before other <code>static</code> fields (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.4.2">12.4.2</a>). This also applies in interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3.1">9.3.1</a>). When such fields are referenced by simple name, they will never be observed to have their default initial values (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.5">4.12.5</a>).</strong></p>
</blockquote>
<div class="editorial">
<p>The restrictions on references appear in <a href="#jls-6.5.6.1">6.5.6.1</a>, <a href="#jls-15.8.3">15.8.3</a>, <a href="#jls-15.11.2">15.11.2</a>, and <a href="#jls-15.12.3">15.12.3</a>, directly at the point where the reference occurs.</p>
</div>
<p>If the declarator is for an instance variable (that is, a field that is not <code>static</code>), then <del>the following rules apply to its initializer:</del> <strong>at run time, the initializer is evaluated and the assignment performed each time an instance of the class is created (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.5">12.5</a>).</strong></p>
<div class="deleted">
<ul>
<li><p>The initializer may refer by simple name to any class variable declared in or inherited by the class, even one whose declaration occurs to the right of the initializer (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.5">3.5</a>).</p></li>
<li><p>The initializer may refer to the current object using the keyword <code>this</code> (<a href="#jls-15.8.3">15.8.3</a>) or the keyword <code>super</code> (<a href="#jls-15.11.2">15.11.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>).</p></li>
<li><p>At run time, the initializer is evaluated and the assignment performed each time an instance of the class is created (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.5">12.5</a>).</p></li>
</ul>
</div>
<p>References from variable initializers to fields that may not yet be initialized are <del>subject to additional restrictions</del> <strong>restricted</strong>, as specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3.3">8.3.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-16.html">16</a>.</p>
<p>Exception checking for a variable initializer in a field declaration is specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.2.3">11.2.3</a>.</p>
<blockquote>
<p>Variable initializers are also used in local variable declaration statements (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>), where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.</p>
</blockquote>
<div class="example">
<p>Example 8.3.2-1. Field Initialization</p>
<pre><code>class Point {
    int x = 1, y = 5;
}
class Test {
    public static void main(String[] args) {
        Point p = new Point();
        System.out.println(p.x + &quot;, &quot; + p.y);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>1, 5</code></pre>
<p>because the assignments to <code>x</code> and <code>y</code> occur whenever a new <code>Point</code> is created.</p>
</div>
<div class="example">
<p>Example 8.3.2-2. Forward Reference to a Class Variable</p>
<pre><code>class Test {
    float f = j;
    static int j = 1;
}</code></pre>
<p>This program compiles without error; it initializes <code>j</code> to <code>1</code> when class <code>Test</code> is initialized, and initializes <code>f</code> to the current value of <code>j</code> every time an instance of class <code>Test</code> is created.</p>
</div>
<h3 id="jls-8.4">8.4 Method Declarations</h3>
<h4 id="jls-8.4.1">8.4.1 Formal Parameters</h4>
<p>The <em>formal parameters</em> of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers. Each parameter specifier consists of a type (optionally preceded by the <code>final</code> modifier and/or one or more annotations) and an identifier (optionally followed by brackets) that specifies the name of the parameter.</p>
<p>If a method or constructor has no formal parameters, and no receiver parameter, then an empty pair of parentheses appears in the declaration of the method or constructor.</p>
<dl>
<dt><em>FormalParameterList:</em></dt>
<dd><em>FormalParameter</em> {<code>,</code> <em>FormalParameter</em>}
</dd>
<dt><em>FormalParameter:</em></dt>
<dd>{<em>VariableModifier</em>} <em>UnannType</em> <em>VariableDeclaratorId</em>
</dd>
<dd><em>VariableArityParameter</em>
</dd>
<dt><em>VariableArityParameter:</em></dt>
<dd>{<em>VariableModifier</em>} <em>UnannType</em> {<em>Annotation</em>} <code>...</code> <em>Identifier</em>
</dd>
<dt><em>VariableModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
<dd><code>final</code>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3">8.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3">4.3</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>VariableDeclaratorId:</em></dt>
<dd><em>Identifier</em> [<em>Dims</em>]
</dd>
<dt><em>Dims:</em></dt>
<dd>{<em>Annotation</em>} <code>[</code> <code>]</code> {{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<p>A formal parameter of a method or constructor may be a <em>variable arity parameter</em>, indicated by an ellipsis following the type. At most one variable arity parameter is permitted for a method or constructor. It is a compile-time error if a variable arity parameter appears anywhere in the list of parameter specifiers except the last position.</p>
<blockquote>
<p>In the grammar for <em>VariableArityParameter</em>, note that the ellipsis (<code>...</code>) is a token unto itself (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.11">3.11</a>). It is possible to put whitespace between it and the type, but this is discouraged as a matter of style.</p>
</blockquote>
<p>If the last formal parameter is a variable arity parameter, the method is a <em>variable arity method</em>. Otherwise, it is a <em>fixed arity method</em>.</p>
<p>The rules for annotation modifiers on a formal parameter declaration and on a receiver parameter are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>It is a compile-time error if <code>final</code> appears more than once as a modifier for a formal parameter declaration.</p>
<p>The scope and shadowing of a formal parameter is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to a formal parameter from a nested class or a lambda expression are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<p>It is a compile-time error for a method or constructor to declare two formal parameters with the same name. (That is, their declarations mention the same <em>Identifier</em>.)</p>
<p>It is a compile-time error if a formal parameter that is declared <code>final</code> is assigned to within the body of the method or constructor.</p>
<p>The declared type of a formal parameter depends on whether it is a variable arity parameter:</p>
<ul>
<li><p>If the formal parameter is not a variable arity parameter, then the declared type is denoted by <em>UnannType</em> if no bracket pairs appear in <em>UnannType</em> and <em>VariableDeclaratorId</em>, and specified by <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.2">10.2</a> otherwise.</p></li>
<li><p>If the formal parameter is a variable arity parameter, then the declared type is an array type specified by <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.2">10.2</a>.</p></li>
</ul>
<p>If the declared type of a variable arity parameter has a non-reifiable element type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.7">4.7</a>), then a compile-time unchecked warning occurs for the declaration of the variable arity method, unless the method is annotated with <code>@SafeVarargs</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.6.4.7">9.6.4.7</a>) or the warning is suppressed by <code>@SuppressWarnings</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.6.4.5">9.6.4.5</a>).</p>
<p>When the method or constructor is invoked (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The <em>Identifier</em> that appears in the <em>FormalParameter</em> may be used as a simple name in the body of the method or constructor to refer to the formal parameter.</p>
<p>Invocations of a variable arity method may contain more actual argument expressions than formal parameters. All the actual argument expressions that do not correspond to the formal parameters preceding the variable arity parameter will be evaluated and the results stored into an array that will be passed to the method invocation (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.4.2">15.12.4.2</a>).</p>
<p>A method's or constructor's formal parameter of type <code>float</code> always contains an element of the float value set (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.2.3">4.2.3</a>); similarly, a method's or constructor's formal parameter of type <code>double</code> always contains an element of the double value set. It is not permitted for a method's or constructor's formal parameter of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a method's or constructor's formal parameter of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.</p>
<p>Where an actual argument expression corresponding to a parameter variable is not FP-strict (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.4">15.4</a>), evaluation of that actual argument expression is permitted to use intermediate values drawn from the appropriate extended-exponent value sets. Prior to being stored in the parameter variable, the result of such an expression is mapped to the nearest value in the corresponding standard value set by being subjected to invocation conversion (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.3">5.3</a>).</p>
<blockquote>
<p>Here are some examples of receiver parameters in instance methods and inner classes' constructors:</p>
<pre><code>class Test {
    Test(/* ?? ?? */) {}
      // No receiver parameter is permitted in the constructor of
      // a top level class, as there is no conceivable type or name.

    void m(Test this) {}
      // OK: receiver parameter in an instance method

    static void n(Test this) {}
      // Illegal: receiver parameter in a static method                         

    class A {
        A(Test Test.this) {}
          // OK: the receiver parameter represents the instance
          // of Test which immediately encloses the instance
          // of A being constructed.

        void m(A this) {}
          // OK: the receiver parameter represents the instance
          // of A for which A.m() is invoked.

        class B {
            B(Test.A A.this) {}
              // OK: the receiver parameter represents the instance
              // of A which immediately encloses the instance of B
              // being constructed.

            void m(Test.A.B this) {}
              // OK: the receiver parameter represents the instance
              // of B for which B.m() is invoked.
        }
    }
}</code></pre>
<p><code>B</code>'s constructor and instance method show that the type of the receiver parameter may be denoted with a qualified <em>TypeName</em> like any other type; but that the name of the receiver parameter in an inner class's constructor must use the simple name of the enclosing class.</p>
</blockquote>
<h4 id="jls-8.4.3">8.4.3 Method Modifiers</h4>
<h5 id="jls-8.4.3.2">8.4.3.2 <code>static</code> Methods</h5>
<p>A method that is declared <code>static</code> is called a <em>class method</em>.</p>
<p><del>It is a compile-time error to use the name of a type parameter of any surrounding declaration in the header or body of a class method.</del></p>
<p>A class method is always invoked without reference to a particular object. <del>It is a compile-time error to attempt to refer to the current object using the keyword <code>this</code> (<a href="#jls-15.8.3">15.8.3</a>) or the keyword <code>super</code> (<a href="#jls-15.11.2">15.11.2</a>).</del></p>
<p><strong>A static method declaration introduces a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<div class="editorial">
<p>The restrictions on references appear in <a href="#jls-6.5.5.1">6.5.5.1</a>, <a href="#jls-15.8.3">15.8.3</a>, <a href="#jls-15.11.2">15.11.2</a>, and <a href="#jls-15.12.3">15.12.3</a>, directly at the point where the reference occurs.</p>
</div>
<p>A method that is not declared <code>static</code> is called an <em>instance method</em>, and sometimes called a non-<code>static</code> method.</p>
<p>An instance method is always invoked with respect to an object, which becomes the current object to which the keywords <code>this</code> and <code>super</code> refer during execution of the method body <strong>(<a href="#jls-15.8.3">15.8.3</a>, <a href="#jls-15.11.2">15.11.2</a>)</strong>.</p>
<p><strong>References to an instance method from a static context or a nested class are restricted, as specified in <a href="#jls-15.12.3">15.12.3</a>.</strong></p>
<h4 id="jls-8.4.4">8.4.4 Generic Methods</h4>
<p>A method is <em>generic</em> if it declares one or more type variables (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>).</p>
<p>These type variables are known as the <em>type parameters</em> of the method. The form of the type parameter section of a generic method is identical to the type parameter section of a generic class (<a href="#jls-8.1.2">8.1.2</a>).</p>
<p>A generic method declaration defines a set of methods, one for each possible invocation of the type parameter section by type arguments. Type arguments may not need to be provided explicitly when a generic method is invoked, as they can often be inferred (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-18.html">18</a>).</p>
<p>The scope and shadowing of a method's type parameter is specified in <a href="#jls-6.3">6.3</a> <strong>and <a href="#jls-6.4">6.4</a></strong>.</p>
<p><strong>References to a method's type parameter from a nested class are restricted, as specified in <a href="#jls-6.5.5.1">6.5.5.1</a>.</strong></p>
<p>Two methods or constructors <em>M</em> and <em>N</em> have the <em>same type parameters</em> if both of the following are true:</p>
<ul>
<li><p><em>M</em> and <em>N</em> have same number of type parameters (possibly zero).</p></li>
<li><p>Where <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em> are the type parameters of <em>M</em> and <em>B<sub>1</sub></em>, ..., <em>B<sub>n</sub></em> are the type parameters of <em>N</em>, let <em>θ=[B<sub>1</sub>:=A<sub>1</sub>, ..., B<sub>n</sub>:=A<sub>n</sub>]</em>. Then, for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>), the bound of <em>A<sub>i</sub></em> is the same type as <em>θ</em> applied to the bound of <em>B<sub>i</sub></em>.</p></li>
</ul>
<p>Where two methods or constructors <em>M</em> and <em>N</em> have the same type parameters, a type mentioned in <em>N</em> can be <em>adapted to the type parameters</em> of <em>M</em> by applying <em>θ</em>, as defined above, to the type.</p>
<h3 id="jls-8.5">8.5 Member Class and Interface Declarations</h3>
<h4 id="jls-8.5.1"><del>8.5.1 Static Member Class and Interface Declarations</del></h4>
<div class="deleted">
<p>The <code>static</code> keyword may modify the declaration of a member class <em>C</em> within the body of a non-inner class or interface <em>T</em>. Its effect is to declare that <em>C</em> is not an inner class. Just as a <code>static</code> method of <em>T</em> has no current instance of <em>T</em> in its body, <em>C</em> also has no current instance of <em>T</em>, nor does it have any lexically enclosing instances.</p>
<p>It is a compile-time error if a <code>static</code> class contains a usage of a non-<code>static</code> member of an enclosing class.</p>
<p>A member interface is implicitly <code>static</code> (<a href="#jls-9.1.1">9.1.1</a>). It is permitted for the declaration of a member interface to redundantly specify the <code>static</code> modifier.</p>
</div>
<div class="editorial">
<p>This section has been replaced by <a href="#jls-8.1.1.4">8.1.1.4</a>, which is applicable to both member classes and local enum classes.</p>
<p>Discussions about implicit modifiers occur where the relevant syntax is specified (<a href="#jls-8.9">8.9</a>, <a href="#jls-9.1.1">9.1.1</a>, <a href="#jls-9.6">9.6</a>).</p>
</div>
<h3 id="jls-8.7">8.7 Static Initializers</h3>
<p>A <em>static initializer</em> declared in a class is executed when the class is initialized (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.4.2">12.4.2</a>). Together with any field initializers for class variables (<a href="#jls-8.3.2">8.3.2</a>), static initializers may be used to initialize the class variables of the class.</p>
<dl>
<dt><em>StaticInitializer:</em></dt>
<dd><code>static</code> <em>Block</em>
</dd>
</dl>
<p>It is a compile-time error if a static initializer cannot complete normally (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.21">14.21</a>).</p>
<p>It is a compile-time error if a <code>return</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.17">14.17</a>) appears anywhere within a static initializer.</p>
<p><del>It is a compile-time error if the keyword <code>this</code> (<a href="#jls-15.8.3">15.8.3</a>) or the keyword <code>super</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11">15.11</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>) or any type variable declared outside the static initializer, appears anywhere within a static initializer.</del></p>
<p><strong>A static initializer introduces a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<div class="editorial">
<p>The restrictions on references appear in <a href="#jls-6.5.5.1">6.5.5.1</a>, <a href="#jls-15.8.3">15.8.3</a>, <a href="#jls-15.11.2">15.11.2</a>, and <a href="#jls-15.12.3">15.12.3</a>, directly at the point where the reference occurs.</p>
</div>
<p>Restrictions on how a static initializer may refer to class variables, even when the class variables are in scope, are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3.3">8.3.3</a>.</p>
<p>Exception checking for a static initializer is specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.2.3">11.2.3</a>.</p>
<h3 id="jls-8.8">8.8 Constructor Declarations</h3>
<h4 id="jls-8.8.1">8.8.1 Formal Parameters</h4>
<p>The formal parameters of a constructor are identical in syntax and semantics to those of a method (<a href="#jls-8.4.1">8.4.1</a>).</p>
<p>The constructor of a non-<code>private</code> inner member class implicitly declares, as the first formal parameter, a variable representing the immediately enclosing instance of the class (<a href="#jls-15.9.2">15.9.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.3">15.9.3</a>).</p>
<blockquote>
<p>The rationale for why only this kind of class has an implicitly declared constructor parameter is subtle. The following explanation may be helpful:</p>
</blockquote>
<blockquote>
<ol type="1">
<li><p>In a class instance creation expression for a non-<code>private</code> inner member class, <a href="#jls-15.9.2">15.9.2</a> specifies the immediately enclosing instance of the member class. The member class may have been emitted by a compiler which is different than the compiler of the class instance creation expression. Therefore, there must be a standard way for the compiler of the creation expression to pass a reference (representing the immediately enclosing instance) to the member class's constructor. Consequently, the Java programming language deems in this section that a non-<code>private</code> inner member class's constructor implicitly declares an initial parameter for the immediately enclosing instance. <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.3">15.9.3</a> specifies that the instance is passed to the constructor.</p></li>
<li><p>In a class instance creation expression for <del>a</del> <strong>an inner</strong> local class <del>(not in a static context)</del> or <strong>an</strong> anonymous class <strong>(not in a static context)</strong>, <a href="#jls-15.9.2">15.9.2</a> specifies the immediately enclosing instance of the local/anonymous class. The local/anonymous class is necessarily emitted by the same compiler as the class instance creation expression. That compiler can represent the immediately enclosing instance how ever it wishes. There is no need for the Java programming language to implicitly declare a parameter in the local/anonymous class's constructor.</p></li>
<li><p>In a class instance creation expression for an anonymous class, and where the anonymous class's superclass is <del>either inner or local</del> <strong>an inner class</strong> (not in a static context), <a href="#jls-15.9.2">15.9.2</a> specifies the anonymous class's immediately enclosing instance with respect to the superclass. This instance must be transmitted from the anonymous class to its superclass, where it will serve as the immediately enclosing instance. Since the superclass may have been emitted by a compiler which is different than the compiler of the class instance creation expression, it is necessary to transmit the instance in a standard way, by passing it as the first argument to the superclass's constructor. Note that the anonymous class itself is necessarily emitted by the same compiler as the class instance creation expression, so it would be possible for the compiler to transmit the immediately enclosing instance with respect to the superclass to the anonymous class how ever it wishes, before the anonymous class passes the instance to the superclass's constructor. However, for consistency, the Java programming language deems in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a> that, in some circumstances, an anonymous class's constructor implicitly declares an initial parameter for the immediately enclosing instance with respect to the superclass.</p></li>
</ol>
</blockquote>
<blockquote>
<p>The fact that a non-<code>private</code> inner member class may be accessed by a different compiler than compiled it, whereas <del>a</del> <strong>an inner</strong> local or anonymous class is always accessed by the same compiler that compiled it, explains why the binary name of a non-<code>private</code> inner member class is defined to be predictable but the binary name of <del>a</del> <strong>an inner</strong> local or anonymous class is not (<a href="#jls-13.1">13.1</a>).</p>
</blockquote>
<h4 id="jls-8.8.4">8.8.4 Generic Constructors</h4>
<p>A constructor is <em>generic</em> if it declares one or more type variables (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>).</p>
<p>These type variables are known as the <em>type parameters</em> of the constructor. The form of the type parameter section of a generic constructor is identical to the type parameter section of a generic class (<a href="#jls-8.1.2">8.1.2</a>).</p>
<p>It is possible for a constructor to be generic independently of whether the class the constructor is declared in is itself generic.</p>
<p>A generic constructor declaration defines a set of constructors, one for each possible invocation of the type parameter section by type arguments. Type arguments may not need to be provided explicitly when a generic constructor is invoked, as they can often by inferred (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-18.html">18</a>).</p>
<p>The scope and shadowing of a constructor's type parameter is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to a constructor's type parameter from an explicit constructor invocation statement or a nested class are restricted, as specified in <a href="#jls-6.5.5.1">6.5.5.1</a>.</strong></p>
<h4 id="jls-8.8.7">8.8.7 Constructor Body</h4>
<h5 id="jls-8.8.7.1">8.8.7.1 Explicit Constructor Invocations</h5>
<dl>
<dt><em>ExplicitConstructorInvocation:</em></dt>
<dd>[<em>TypeArguments</em>] <code>this</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd>[<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd><em>ExpressionName</em> <code>.</code> [<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd><em>Primary</em> <code>.</code> [<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>TypeArguments:</em></dt>
<dd><code>&lt;</code> <em>TypeArgumentList</em> <code>&gt;</code>
</dd>
<dt><em>ArgumentList:</em></dt>
<dd><em>Expression</em> {<code>,</code> <em>Expression</em>}
</dd>
</dl>
</blockquote>
<p>Explicit constructor invocation statements are divided into two kinds:</p>
<ul>
<li><p><em>Alternate constructor invocations</em> begin with the keyword <code>this</code> (possibly prefaced with explicit type arguments). They are used to invoke an alternate constructor of the same class.</p></li>
<li><p><em>Superclass constructor invocations</em> begin with either the keyword <code>super</code> (possibly prefaced with explicit type arguments) or a <em>Primary</em> expression or an <em>ExpressionName</em>. They are used to invoke a constructor of the direct superclass. They are further divided:</p>
<ul>
<li><p><em>Unqualified superclass constructor invocations</em> begin with the keyword <code>super</code> (possibly prefaced with explicit type arguments).</p></li>
<li><p><em>Qualified superclass constructor invocations</em> begin with a <em>Primary</em> expression or an <em>ExpressionName</em>. They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass (<a href="#jls-8.1.3">8.1.3</a>). This may be necessary when the superclass is an inner class.</p></li>
</ul></li>
</ul>
<p><del>An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods or inner classes declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs.</del></p>
<blockquote>
<p><del>This prohibition on using the current instance explains why an explicit constructor invocation statement is deemed to occur in a static context (<a href="#jls-8.1.3">8.1.3</a>).</del></p>
</blockquote>
<p><strong>An explicit constructor invocation statement introduces a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<div class="editorial">
<p>The restrictions on references appear in <a href="#jls-6.5.6.1">6.5.6.1</a>, <a href="#jls-15.8.3">15.8.3</a>, <a href="#jls-15.9.2">15.9.2</a>, <a href="#jls-15.11.2">15.11.2</a>, and <a href="#jls-15.12.3">15.12.3</a>, directly at the point where the reference occurs.</p>
<p>The actual restriction is on implicit or explicit use of <code>this</code>—so, for example, it's fine to refer to an instance variable of another class instance passed in as a parameter, or to cast to an inner class type.</p>
<p>We should explore what <code>javac</code> does here, because the rule is not clearly stated.</p>
</div>
<p>If <em>TypeArguments</em> is present to the left of <code>this</code> or <code>super</code>, then it is a compile-time error if any of the type arguments are wildcards (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a>).</p>
<p>Let <em>C</em> be the class being instantiated, and let <em>S</em> be the direct superclass of <em>C</em>.</p>
<p>If a superclass constructor invocation statement is unqualified, then:</p>
<ul>
<li><p>If <em>S</em> is an inner member class, but <em>S</em> is not a member of a class enclosing <em>C</em>, then a compile-time error occurs.</p>
<p><strong>Otherwise, let <em>O</em> be the innermost enclosing class of <em>C</em> of which <em>S</em> is a member. <em>C</em> must be an inner class of <em>O</em> (<a href="#jls-8.1.3">8.1.3</a>), or a compile-time error occurs.</strong></p></li>
<li><p><strong>If <em>S</em> is an inner local class, and <em>S</em> does not occur in a static context, let <em>O</em> be the immediately enclosing class or interface declaration of <em>S</em>. <em>C</em> must be an inner class of <em>O</em> (<a href="#jls-8.1.3">8.1.3</a>), or a compile-time error occurs.</strong></p></li>
</ul>
<p>If a superclass constructor invocation statement is qualified, then:</p>
<ul>
<li><p>If <em>S</em> is not an inner class, or if the declaration of <em>S</em> occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, let <em>p</em> be the <em>Primary</em> expression or the <em>ExpressionName</em> immediately preceding &quot;<code>.super</code>&quot;, and let <em>O</em> be the immediately enclosing class of <em>S</em>. It is a compile-time error if the type of <em>p</em> is not <em>O</em> or a subclass of <em>O</em>, or if the type of <em>p</em> is not accessible (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>).</p></li>
</ul>
<p>The exception types that an explicit constructor invocation statement can throw are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.2.2">11.2.2</a>.</p>
<p>Evaluation of an alternate constructor invocation statement proceeds by first evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.</p>
<p>Evaluation of a superclass constructor invocation statement proceeds as follows:</p>
<ol type="1">
<li><p>Let <em>i</em> be the instance being created. The immediately enclosing instance of <em>i</em> with respect to <em>S</em> (if any) must be determined:</p>
<ul>
<li><p>If <em>S</em> is not an inner class, or if the declaration of <em>S</em> occurs in a static context, then no immediately enclosing instance of <em>i</em> with respect to <em>S</em> exists.</p></li>
<li><p><del>If</del> <strong>Otherwise, if</strong> the superclass constructor invocation is unqualified, then <em>S</em> is necessarily <del>a</del> <strong>an inner</strong> local class or an inner member class.</p>
<p>If <em>S</em> is <del>a</del> <strong>an inner</strong> local class, then let <em>O</em> be the immediately enclosing class or interface declaration of <em>S</em>.</p>
<p>If <em>S</em> is an inner member class, then let <em>O</em> be the innermost enclosing class of <em>C</em> of which <em>S</em> is a member.</p>
<p>Let <em>n</em> be an integer (<em>n</em> <em>≥</em> 1) such that <em>O</em> is the <em>n</em>'th lexically enclosing class or interface declaration of <em>C</em>.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p>
<blockquote>
<p>While it may be the case that <em>S</em> is a member of <em>C</em> due to inheritance, the zeroth lexically enclosing instance of <code>this</code> (that is, <code>this</code> itself) is never used as the immediately enclosing instance of <em>i</em> with respect to <em>S</em>.</p>
</blockquote></li>
<li><p><del>If</del> <strong>Otherwise, if</strong> the superclass constructor invocation is qualified, then the <em>Primary</em> expression or the <em>ExpressionName</em> immediately preceding &quot;<code>.super</code>&quot;, <em>p</em>, is evaluated.</p>
<p>If <em>p</em> evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the superclass constructor invocation completes abruptly.</p>
<p>Otherwise, the result of this evaluation is the immediately enclosing instance of <em>i</em> with respect to <em>S</em>.</p></li>
</ul></li>
<li><p>After determining the immediately enclosing instance of <em>i</em> with respect to <em>S</em> (if any), evaluation of the superclass constructor invocation statement proceeds by evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.</p></li>
<li><p>Finally, if the superclass constructor invocation statement completes normally, then all instance variable initializers of <em>C</em> and all instance initializers of <em>C</em> are executed. If an instance initializer or instance variable initializer <em>I</em> textually precedes another instance initializer or instance variable initializer <em>J</em>, then <em>I</em> is executed before <em>J</em>.</p>
<p>Execution of instance variable initializers and instance initializers is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided implicitly. (An alternate constructor invocation does not perform this additional implicit execution.)</p></li>
</ol>
<div class="example">
<p>Example 8.8.7.1-1. Restrictions on Explicit Constructor Invocation Statements</p>
<p>If the first constructor of <code>ColoredPoint</code> in the example from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.7">8.8.7</a> were changed as follows:</p>
<pre><code>class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
    static final int WHITE = 0, BLACK = 1;
    int color;
    ColoredPoint(int x, int y) {
        this(x, y, color);  // Changed to color from WHITE
    }
    ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = color;
    }
}</code></pre>
<p>then a compile-time error would occur, because the instance variable <code>color</code> cannot be used by a explicit constructor invocation statement.</p>
</div>
<div class="example">
<p>Example 8.8.7.1-2. Qualified Superclass Constructor Invocation</p>
<p>In the code below, <code>ChildOfInner</code> has no lexically enclosing class or interface declaration, so an instance of <code>ChildOfInner</code> has no enclosing instance. However, the superclass of <code>ChildOfInner</code> (<code>Inner</code>) has a lexically enclosing class declaration (<code>Outer</code>), and an instance of <code>Inner</code> must have an enclosing instance of <code>Outer</code>. The enclosing instance of <code>Outer</code> is set when an instance of <code>Inner</code> is created. Therefore, when we create an instance of <code>ChildOfInner</code>, which is implicitly an instance of <code>Inner</code>, we must provide the enclosing instance of <code>Outer</code> via a qualified superclass invocation statement in <code>ChildOfInner</code>'s constructor. The instance of <code>Outer</code> is called the immediately enclosing instance of <code>ChildOfInner</code> with respect to <code>Inner</code>.</p>
<pre><code>class Outer {
    class Inner {}
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner() { (new Outer()).super(); }
}</code></pre>
<p>Perhaps surprisingly, the same instance of <code>Outer</code> may serve as the immediately enclosing instance of <code>ChildOfInner</code> with respect to <code>Inner</code> <em>for multiple instances of <code>ChildOfInner</code></em>. These instances of <code>ChildOfInner</code> are implicitly linked to the same instance of <code>Outer</code>. The program below achieves this by passing an instance of <code>Outer</code> to the constructor of <code>ChildOfInner</code>, which uses the instance in a qualified superclass constructor invocation statement. The rules for an explicit constructor invocation statement do not prohibit using formal parameters of the constructor that contains the statement.</p>
<pre><code>class Outer {
    int secret = 5;
    class Inner {
        int  getSecret()      { return secret; }
        void setSecret(int s) { secret = s; }
    }
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner(Outer x) { x.super(); }
}

public class Test {
    public static void main(String[] args) {
        Outer x = new Outer();
        ChildOfInner a = new ChildOfInner(x);
        ChildOfInner b = new ChildOfInner(x);
        System.out.println(b.getSecret());
        a.setSecret(6);
        System.out.println(b.getSecret());
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>5
6</code></pre>
<p>The effect is that manipulation of instance variables in the common instance of <code>Outer</code> is visible through references to different instances of <code>ChildOfInner</code>, even though such references are not aliases in the conventional sense.</p>
</div>
<h3 id="jls-8.9">8.9 Enum Classes</h3>
<p>An <em>enum declaration</em> specifies a new <em>enum class</em>, a special kind of class that defines a small set of named class instances.</p>
<dl>
<dt><em>EnumDeclaration:</em></dt>
<dd>{<em>ClassModifier</em>} <code>enum</code> <em>TypeIdentifier</em> [<em>ClassImplements</em>] <em>EnumBody</em>
</dd>
</dl>
<p>An enum declaration may specify a top level enum class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.6">7.6</a>)<strong>,</strong> <del>or</del> a member enum class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>)<strong>, or a local enum class (<a href="#jls-14.3">14.3</a>)</strong>.</p>
<p>It is a compile-time error if an enum declaration has the modifier <code>abstract</code> or <code>final</code>.</p>
<p>An enum declaration is implicitly <code>final</code> unless it contains at least one enum constant that has a class body (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.9.1">8.9.1</a>).</p>
<p>A <del>member</del> <strong>nested</strong> enum class is implicitly <code>static</code>. It is permitted for the declaration of a member enum class to redundantly specify the <code>static</code> modifier. <strong>A local enum declaration may not redundantly specify the <code>static</code> modifier (<a href="#jls-14.3">14.3</a>).</strong></p>
<div class="deleted">
<blockquote>
<p>This implies that it is impossible to declare an enum class as a member of an inner class (<a href="#jls-8.1.3">8.1.3</a>), because an inner class cannot have <code>static</code> members except for constant variables.</p>
</blockquote>
</div>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for an enum declaration, or if an enum declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>An enum declaration does not have an <code>extends</code> clause. The direct superclass type of an enum class <em>E</em> is <code>Enum&lt;</code><em>E</em><code>&gt;</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.4">8.1.4</a>).</p>
<p>An enum class has no instances other than those defined by its enum constants. It is a compile-time error to attempt to explicitly instantiate an enum class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.1">15.9.1</a>).</p>
<blockquote>
<p>In addition to the compile-time error, three further mechanisms ensure that no instances of an enum class exist beyond those defined by its enum constants:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The <code>final</code> <code>clone</code> method in <code>Enum</code> ensures that enum constants can never be cloned.</p></li>
<li><p>Reflective instantiation of enum classes is prohibited.</p></li>
<li><p>Special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization.</p></li>
</ul>
</blockquote>
<h2 id="jls-9">Chapter 9: Interfaces</h2>
<p>An interface declaration introduces a new interface that can be implemented by one or more classes. Programs can use interfaces to provide a common supertype for otherwise-unrelated classes.</p>
<p>Interfaces have no instance variables, and typically declare one or more <code>abstract</code> methods; otherwise unrelated classes can implement an interface by providing implementations for its <code>abstract</code> methods. Interfaces may not be directly instantiated.</p>
<p>A <em>top level interface</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.6">7.6</a>) is an interface that is declared at the top level of a compilation unit.</p>
<p>A <em>nested interface</em> is any interface whose declaration occurs <del>as a <em>member interface</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>)</del> <strong>within the body</strong> of another class or interface. <strong>A nested interface may be a <em>member interface</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>) or a <em>local interface</em> (<a href="#jls-14.3">14.3</a>).</strong></p>
<p>An <em>annotation interface</em> (<a href="#jls-9.6">9.6</a>) is an interface declared with special syntax, intended to be implemented by reflective representations of <em>annotations</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7">9.7</a>).</p>
<p>This chapter discusses the common semantics of all interfaces. Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs.</p>
<p>An interface may be declared to be a <em>direct extension</em> of one or more other interfaces, meaning that it inherits all the member classes and interfaces, instance methods, and <code>static</code> fields of the interfaces it extends, except for any members that it may override or hide.</p>
<p>A class may be declared to <em>directly implement</em> one or more interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.5">8.1.5</a>), meaning that any instance of the class implements all the <code>abstract</code> methods specified by the interface or interfaces. A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do. This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing a superclass.</p>
<p>A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface. It is not sufficient that the class happen to implement all the <code>abstract</code> methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.</p>
<h3 id="jls-9.1">9.1 Interface Declarations</h3>
<h4 id="jls-9.1.1">9.1.1 Interface Modifiers</h4>
<p>An interface declaration may include <em>interface modifiers</em>.</p>
<dl>
<dt><em>InterfaceModifier:</em></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code> <code>protected</code> <code>private</code>
</dd>
<dd><code>abstract</code> <code>static</code> <code>strictfp</code>
</dd>
</dl>
<p>The rules for annotation modifiers on an interface declaration are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p><strong>The access modifier <code>public</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>) pertains only to top level interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.6">7.6</a>) and member interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>).</strong></p>
<p>The <strong>access</strong> modifiers <code>protected</code><del>,</del> <strong>and</strong> <code>private</code><del>, and <code>static</code></del> pertain only to member interfaces <del>(<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>)</del>.</p>
<p><strong>The modifier <code>static</code> pertains only to member interfaces and local interfaces (<a href="#jls-14.3">14.3</a>).</strong></p>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<blockquote>
<p>If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>InterfaceModifier</em>.</p>
</blockquote>
<h5 id="jls-9.1.1.1">9.1.1.1 <code>abstract</code> Interfaces</h5>
<p>Every interface is implicitly <code>abstract</code>.</p>
<blockquote>
<p>This modifier is obsolete and should not be used in new programs.</p>
</blockquote>
<h5 id="jls-9.1.1.2">9.1.1.2 <code>strictfp</code> Interfaces</h5>
<p>The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double</code> expressions within the interface declaration be explicitly FP-strict (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.4">15.4</a>).</p>
<p>This implies that all methods declared in the interface, and all nested types declared in the interface, are implicitly <code>strictfp</code>.</p>
<h5 id="jls-9.1.1.3"><strong>9.1.1.3 <code>static</code> Interfaces</strong></h5>
<div class="inserted">
<p>A nested interface declaration is implicitly <code>static</code>. It is permitted for the declaration of a member interface to redundantly specify the <code>static</code> modifier. A local interface declaration may not redundantly specify the <code>static</code> modifier (<a href="#jls-14.3">14.3</a>).</p>
<p>Because a nested interface is <code>static</code>, it has no immediately enclosing instance and cannot directly reference enclosing type variables (<a href="#jls-6.5.5.1">6.5.5.1</a>); enclosing instance variables, local variables, formal parameters, or exception parameters (<a href="#jls-6.5.6.1">6.5.6.1</a>); or enclosing instance methods (<a href="#jls-15.12.3">15.12.3</a>).</p>
</div>
<h4 id="jls-9.1.2">9.1.2 Generic Interfaces and Type Parameters</h4>
<p>An interface is <em>generic</em> if it declares one or more type variables (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>).</p>
<p>These type variables are known as the <em>type parameters</em> of the interface. The type parameter section follows the interface name and is delimited by angle brackets.</p>
<blockquote>
<p>The following productions from <a href="#jls-8.1.2">8.1.2</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>TypeParameters:</em></dt>
<dd><code>&lt;</code> <em>TypeParameterList</em> <code>&gt;</code>
</dd>
<dt><em>TypeParameterList:</em></dt>
<dd><em>TypeParameter</em> {<code>,</code> <em>TypeParameter</em>}
</dd>
<dt><em>TypeParameter:</em></dt>
<dd>{<em>TypeParameterModifier</em>} <em>TypeIdentifier</em> [<em>TypeBound</em>]
</dd>
<dt><em>TypeParameterModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
<dt><em>TypeBound:</em></dt>
<dd><code>extends</code> <em>TypeVariable</em>
</dd>
<dd><code>extends</code> <em>ClassOrInterfaceType</em> {<em>AdditionalBound</em>}
</dd>
<dt><em>AdditionalBound:</em></dt>
<dd><code>&amp;</code> <em>InterfaceType</em>
</dd>
</dl>
</blockquote>
<p>The rules for annotation modifiers on a type parameter declaration are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>In an interface's type parameter section, a type variable <em>T</em> <em>directly depends</em> on a type variable <em>S</em> if <em>S</em> is the bound of <em>T</em>, while <em>T</em> <em>depends</em> on <em>S</em> if either <em>T</em> directly depends on <em>S</em> or <em>T</em> directly depends on a type variable <em>U</em> that depends on <em>S</em> (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself.</p>
<p>The scope and shadowing of an interface's type parameter is specified in <a href="#jls-6.3">6.3</a> <strong>and <a href="#jls-6.4">6.4</a></strong>.</p>
<p><del>It is a compile-time error to refer to a type parameter of a generic interface <em>I</em> anywhere in the declaration of a <code>static</code> member of <em>I</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a>, <a href="#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>).</del></p>
<p><strong>References to an interface's type parameter from a static context or a nested class are restricted, as specified in <a href="#jls-6.5.5.1">6.5.5.1</a>.</strong></p>
<p>A generic interface declaration defines a set of parameterized types (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5">4.5</a>), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time.</p>
<h3 id="jls-9.4">9.4 Method Declarations</h3>
<dl>
<dt><em>InterfaceMethodDeclaration:</em></dt>
<dd>{<em>InterfaceMethodModifier</em>} <em>MethodHeader</em> <em>MethodBody</em>
</dd>
<dt><em>InterfaceMethodModifier:</em></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code> <code>private</code>
</dd>
<dd><code>abstract</code> <code>default</code> <code>static</code> <code>strictfp</code>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.5">8.4.5</a>, and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.7">8.4.7</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>MethodHeader:</em></dt>
<dd><em>Result</em> <em>MethodDeclarator</em> [<em>Throws</em>]
</dd>
<dd><em>TypeParameters</em> {<em>Annotation</em>} <em>Result</em> <em>MethodDeclarator</em> [<em>Throws</em>]
</dd>
<dt><em>Result:</em></dt>
<dd><em>UnannType</em>
</dd>
<dd><code>void</code>
</dd>
<dt><em>MethodDeclarator:</em></dt>
<dd><em>Identifier</em> <code>(</code> [<em>ReceiverParameter</em> <code>,</code>] [<em>FormalParameterList</em>] <code>)</code> [<em>Dims</em>]
</dd>
<dt><em>MethodBody:</em></dt>
<dd><em>Block</em>
</dd>
<dd><code>;</code>
</dd>
</dl>
</blockquote>
<p>The rules for annotation modifiers on an interface method declaration are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>A method in the body of an interface may be declared <code>public</code> or <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>). If no access modifier is given, the method is implicitly <code>public</code>. It is permitted, but discouraged as a matter of style, to redundantly specify the <code>public</code> modifier for a method declaration in an interface.</p>
<p>A <em>default method</em> is an instance method declared in an interface with the <code>default</code> modifier. Its body is always represented by a block, which provides a default implementation for any class that implements the interface without overriding the method. Default methods are distinct from concrete methods (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.3.1">8.4.3.1</a>), which are declared in classes, and from <code>private</code> interface methods, which are neither inherited nor overridden.</p>
<p>An interface can declare <code>static</code> methods, which are invoked without reference to a particular object. <code>static</code> interface methods are distinct from default<strong>, <code>abstract</code>, and <code>private</code></strong> methods, which are instance methods.</p>
<p><del>It is a compile-time error to use the name of a type parameter of any surrounding declaration in the header or body of a <code>static</code> method of an interface.</del></p>
<div class="editorial">
<p>This restriction is now specified in <a href="#jls-6.5.5.1">6.5.5.1</a>, directly at the point where the reference occurs.</p>
</div>
<p><strong>A static method declaration introduces a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<p><strong>References to an instance method from a static context or a nested class are restricted, as specified in <a href="#jls-15.12.3">15.12.3</a>.</strong></p>
<p>The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double</code> expressions within the body of a default or <code>static</code> method be explicitly FP-strict (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.4">15.4</a>).</p>
<p>An interface method lacking a <code>private</code>, <code>default</code>, or <code>static</code> modifier is implicitly <code>abstract</code>. Its body is represented by a semicolon, not a block. It is permitted, but discouraged as a matter of style, to redundantly specify the <code>abstract</code> modifier for such a method declaration.</p>
<blockquote>
<p>Note that an interface method may not be declared with <code>protected</code> or package access, or with the modifiers <code>final</code>, <code>synchronized</code>, or <code>native</code>.</p>
</blockquote>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for an interface method declaration, or if an interface method declaration has more than one of the access modifiers <code>public</code> and <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>It is a compile-time error if an interface method declaration has more than one of the keywords <code>abstract</code>, <code>default</code>, or <code>static</code>.</p>
<p>It is a compile-time error if an interface method declaration that contains the keyword <code>private</code> also contains the keyword <code>abstract</code> or <code>default</code>. It is permitted for an interface method declaration to contain both <code>private</code> and <code>static</code>.</p>
<p>It is a compile-time error if an interface method declaration that contains the keyword <code>abstract</code> also contains the keyword <code>strictfp</code>.</p>
<p>It is a compile-time error for the body of an interface to declare, explicitly or implicitly, two methods with override-equivalent signatures (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>). However, an interface may inherit several <code>abstract</code> methods with such signatures (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4.1">9.4.1</a>).</p>
<p>A method declared in an interface may be generic. The rules for type parameters of a generic method in an interface are the same as for a generic method in a class (<a href="#jls-8.4.4">8.4.4</a>).</p>
<h4 id="jls-9.4.3">9.4.3 Interface Method Body</h4>
<p>A default method has a block body. This block of code provides an implementation of the method in the event that a class implements the interface but does not provide its own implementation of the method.</p>
<p>A <code>private</code> or <code>static</code> method also has a block body, which provides the implementation of the method.</p>
<p>It is a compile-time error if an interface method declaration is <code>abstract</code> (explicitly or implicitly) and has a block for its body.</p>
<p>It is a compile-time error if an interface method declaration is <code>default</code>, <code>private</code>, or <code>static</code>, and has a semicolon for its body.</p>
<p><del>It is a compile-time error for the body of a <code>static</code> method to attempt to reference the current object using the keyword <code>this</code> or the keyword <code>super</code>.</del></p>
<div class="editorial">
<p>This restriction is specified in <a href="#jls-15.8.3">15.8.3</a>, <a href="#jls-15.11.2">15.11.2</a>, and <a href="#jls-15.12.3">15.12.3</a>, directly at the point where the reference occurs.</p>
</div>
<p>The rules for <code>return</code> statements in a method body are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.17">14.17</a>.</p>
<p>If a method is declared to have a return type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.5">8.4.5</a>), then a compile-time error occurs if the body of the method can complete normally (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.1">14.1</a>).</p>
<h3 id="jls-9.6">9.6 Annotation Interfaces</h3>
<p>An <em>annotation declaration</em> specifies a new <em>annotation interface</em>, a special kind of interface. To distinguish an annotation declaration from a normal interface declaration, the keyword <code>interface</code> is preceded by an at sign (<code>@</code>).</p>
<dl>
<dt><em>AnnotationDeclaration:</em></dt>
<dd>{<em>InterfaceModifier</em>} <code>@</code> <code>interface</code> <em>TypeIdentifier</em> <em>AnnotationInterfaceBody</em>
</dd>
</dl>
<blockquote>
<p>Note that the at sign (<code>@</code>) and the keyword <code>interface</code> are distinct tokens. It is possible to separate them with whitespace, but this is discouraged as a matter of style.</p>
</blockquote>
<p><strong>It is a compile-time error if an annotation declaration is nested within the body of a local class or interface declaration (<a href="#jls-14.3">14.3</a>), or within the body of an anonymous class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.5">15.9.5</a>).</strong></p>
<blockquote>
<p><strong>This rule ensures that an annotation interface always has a fully qualified name (<a href="#jls-6.7">6.7</a>).</strong></p>
</blockquote>
<p>The rules for annotation modifiers on an annotation declaration are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>The <em>TypeIdentifier</em> in an annotation declaration specifies the name of the annotation interface.</p>
<p>It is a compile-time error if an annotation interface has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The direct superinterface of every annotation interface is <code>java.lang.annotation.Annotation</code> ([9.1.3]).</p>
<blockquote>
<p>By virtue of the <em>AnnotationInterfaceDeclaration</em> syntax, an annotation interface declaration cannot be generic, and no <code>extends</code> clause is permitted.</p>
</blockquote>
<blockquote>
<p>A consequence of the fact that an annotation interface cannot explicitly declare a superclass type or superinterface type is that a subinterface of an annotation interface is never itself an annotation interface. Similarly, <code>java.lang.annotation.Annotation</code> is not itself an annotation interface.</p>
</blockquote>
<p>An annotation interface inherits several members from <code>java.lang.annotation.Annotation</code>, including the implicitly declared methods corresponding to the instance methods of <code>Object</code>, yet these methods do not define elements of the annotation interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.6.1">9.6.1</a>).</p>
<blockquote>
<p>Because these methods do not define elements of the annotation interface, it is illegal to use them in annotations of that type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7">9.7</a>). Without this rule, we could not ensure that elements were of the types representable in annotations, or that accessor methods for them would be available.</p>
</blockquote>
<p>Unless explicitly modified herein, all of the rules that apply to normal interface declarations apply to annotation declarations.</p>
<blockquote>
<p>For example, annotation interfaces share the same namespace as normal classes and interfaces; and annotation declarations have the same scope and accessibility as interface declarations.</p>
</blockquote>
<h2 id="jls-13">Chapter 13: Binary Compatibility</h2>
<h3 id="jls-13.1">13.1 The Form of a Binary</h3>
<p>Programs must be compiled either into the <code>class</code> file format specified by <em>The Java Virtual Machine Specification, Java SE 14 Edition</em>, or into a representation that can be mapped into that format by a class loader written in the Java programming language.</p>
<p>A <code>class</code> file corresponding to a class or interface declaration must have certain properties. A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility. The required properties are:</p>
<ol type="1">
<li><p>The class or interface must be named by its <em>binary name</em>, which must meet the following constraints:</p>
<ul>
<li><p>The binary name of a top level class or interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.6">7.6</a>) is its canonical name (<a href="#jls-6.7">6.7</a>).</p></li>
<li><p>The binary name of a member class or interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.5">9.5</a>) consists of the binary name of its immediately enclosing class or interface, followed by <code>$</code>, followed by the simple name of the member.</p></li>
<li><p>The binary name of a local class <strong>or interface</strong> (<a href="#jls-14.3">14.3</a>) consists of the binary name of its immediately enclosing class or interface, followed by <code>$</code>, followed by a non-empty sequence of digits, followed by the simple name of the local class.</p></li>
<li><p>The binary name of an anonymous class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.5">15.9.5</a>) consists of the binary name of its immediately enclosing class or interface, followed by <code>$</code>, followed by a non-empty sequence of digits.</p></li>
<li><p>The binary name of a type variable declared by a generic class or interface (<a href="#jls-8.1.2">8.1.2</a>, <a href="#jls-9.1.2">9.1.2</a>) is the binary name of its immediately enclosing class or interface, followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic method (<a href="#jls-8.4.4">8.4.4</a>) is the binary name of the class or interface declaring the method, followed by <code>$</code>, followed by the descriptor of the method (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic constructor (<a href="#jls-8.8.4">8.8.4</a>) is the binary name of the class declaring the constructor, followed by <code>$</code>, followed by the descriptor of the constructor (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
</ul></li>
</ol>
<p>...</p>
<h2 id="jls-14">Chapter 14: Blocks and Statements</h2>
<p>The sequence of execution of a program is controlled by <em>statements</em>, which are executed for their effect and do not have values.</p>
<p>Some statements <em>contain</em> other statements as part of their structure; such other statements are substatements of the statement. We say that statement <em>S</em> <em>immediately contains</em> statement <em>U</em> if there is no statement <em>T</em> different from <em>S</em> and <em>U</em> such that <em>S</em> contains <em>T</em> and <em>T</em> contains <em>U</em>. In the same manner, some statements contain expressions (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html">15</a>) as part of their structure.</p>
<p>The first section of this chapter discusses the distinction between normal and abrupt completion of statements (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.1">14.1</a>). Most of the remaining sections explain the various kinds of statements, describing in detail both their normal behavior and any special treatment of abrupt completion.</p>
<p>Blocks are explained first (<a href="#jls-14.2">14.2</a>), followed by local class <strong>and interface</strong> declarations (<a href="#jls-14.3">14.3</a>) and local variable declaration statements (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>).</p>
<p>Next a grammatical maneuver that sidesteps the familiar &quot;dangling else&quot; problem (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.5">14.5</a>) is explained.</p>
<p>The last section (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.22">14.22</a>) of this chapter addresses the requirement that every statement be <em>reachable</em> in a certain technical sense.</p>
<h3 id="jls-14.2">14.2 Blocks</h3>
<p>A <em>block</em> is a sequence of statements, local class <strong>and interface</strong> declarations, and local variable declaration statements within braces.</p>
<dl>
<dt><em>Block:</em></dt>
<dd><code>{</code> [<em>BlockStatements</em>] <code>}</code>
</dd>
<dt><em>BlockStatements:</em></dt>
<dd><em>BlockStatement</em> {<em>BlockStatement</em>}
</dd>
<dt><em>BlockStatement:</em></dt>
<dd><em>LocalVariableDeclarationStatement</em>
</dd>
<dd><del><em>ClassDeclaration</em></del>
</dd>
<dd><strong><em>LocalClassOrInterfaceDeclaration</em></strong>
</dd>
<dd><em>Statement</em>
</dd>
</dl>
<p>A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.</p>
<h3 id="jls-14.3">14.3 Local Class <strong>and Interface</strong> Declarations</h3>
<p>A <em>local class</em> <strong>or a <em>local interface</em></strong> is a nested class <strong>or interface</strong> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8">8</a><strong>, <a href="#jls-9">9</a></strong>) <del>that is not a member of any class and that has a name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.2">6.2</a>, <a href="#jls-6.7">6.7</a>)</del> <strong>whose declaration is immediately contained by a block (<a href="#jls-14.2">14.2</a>)</strong>.</p>
<div class="inserted">
<dl>
<dt><em>LocalClassOrInterfaceDeclaration:</em></dt>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>NormalInterfaceDeclaration</em>
</dd>
</dl>
</div>
<p><strong>A local class may be an enum class (<a href="#jls-8.9">8.9</a>). A local interface may <em>not</em> be an annotation interface (<a href="#jls-9.6">9.6</a>).</strong></p>
<p><del>All local classes are inner classes (<a href="#jls-8.1.3">8.1.3</a>).</del></p>
<p><strong>Local enum classes and local interfaces are implicitly <code>static</code> (<a href="#jls-8.1.1.4">8.1.1.4</a>, <a href="#jls-9.1.1.3">9.1.1.3</a>). A local class that is not implicitly <code>static</code> is an inner class (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<p><strong>A local class or interface is not a member of any package, class, or interface. Unlike an anonymous class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.5">15.9.5</a>), a local class or interface has a simple name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.2">6.2</a>, <a href="#jls-6.7">6.7</a>).</strong></p>
<p><del>Every local class declaration statement is immediately contained by a block (<a href="#jls-14.2">14.2</a>).</del> Local class <del>type declaration statements</del> <strong>and interface declarations</strong> may be intermixed freely with other kinds of statements in the <strong>enclosing</strong> block.</p>
<p>It is a compile-time error if a local class <strong>or interface</strong> <del>declaration contains</del> <strong>is declared with</strong> any of the access modifiers <code>public</code>, <code>protected</code>, or <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>), or the modifier <code>static</code> (<a href="#jls-8.1.1">8.1.1</a>).</p>
<p>The scope and shadowing of a local class <strong>or interface</strong> declaration is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<div class="example">
<p>Example 14.3-1. Local Class <strong>and Interface</strong> Declarations</p>
<p>Here is an example that illustrates several aspects of the rules given above:</p>
<pre><code>class Global {
    class Cyclic {}

    void foo() {
        new Cyclic(); // create a Global.Cyclic
        class Cyclic extends Cyclic {} // circular definition

        {
            class Local {}
            {
                class Local {} // compile-time error
            }
            class Local {} // compile-time error
            class AnotherLocal {
                void bar() {
                    class Local {} // ok
                }
            }
        }
        class Local {} // ok, not in scope of prior Local
    }
}</code></pre>
<p>The first statement of method <code>foo</code> creates an instance of the member class <code>Global.Cyclic</code> rather than an instance of the local class <code>Cyclic</code>, because the statement appears prior to the scope of the local class declaration.</p>
<p>The fact that the scope of a local class declaration encompasses its whole declaration (not only its body) means that the definition of the local class <code>Cyclic</code> is indeed cyclic because it extends itself rather than <code>Global.Cyclic</code>. Consequently, the declaration of the local class <code>Cyclic</code> is rejected at compile time.</p>
<p>Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of <code>Local</code> result in compile-time errors. However, <code>Local</code> can be redeclared in the context of another, more deeply nested, class such as <code>AnotherLocal</code>.</p>
<p>The final declaration of <code>Local</code> is legal, since it occurs outside the scope of any prior declaration of <code>Local</code>.</p>
</div>
<h3 id="jls-14.4">14.4 Local Variable Declaration Statements</h3>
<h4 id="jls-14.4.1">14.4.1 Local Variable Declarators and Types</h4>
<p>Each <em>declarator</em> in a local variable declaration declares one local variable, whose name is the <em>Identifier</em> that appears in the declarator.</p>
<p>If the optional keyword <code>final</code> appears at the start of the declaration, the variable being declared is a final variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>The declared type of a local variable is determined as follows:</p>
<ul>
<li><p>If <em>LocalVariableType</em> is an <em>UnannType</em>, and no bracket pairs appear in <em>UnannType</em> or <em>VariableDeclaratorId</em>, then <em>UnannType</em> denotes the type of the local variable.</p></li>
<li><p>If <em>LocalVariableType</em> is an <em>UnannType</em>, and bracket pairs appear in <em>UnannType</em> or <em>VariableDeclaratorId</em>, then the type of the local variable is specified by <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.2">10.2</a>.</p></li>
<li><p>If <em>LocalVariableType</em> is <code>var</code>, then let <em>T</em> be the type of the initializer expression when treated as if it did not appear in an assignment context, and were thus a standalone expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.2">15.2</a>). The type of the local variable is the upward projection of <em>T</em> with respect to all synthetic type variables mentioned by <em>T</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10.5">4.10.5</a>).</p>
<p>It is a compile-time error if <em>T</em> is the null type.</p>
<blockquote>
<p>Because the initializer is treated as if it did not appear in an assignment context, an error occurs if it is a lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27">15.27</a>) or a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.13">15.13</a>).</p>
</blockquote></li>
</ul>
<div class="example">
<p>Example 14.4.1-1. Type of Local Variables Declared With <code>var</code></p>
<p>The following code illustrates the typing of variables declared with <code>var</code>:</p>
<pre><code>var a = 1;                // a has type &#39;int&#39;
var b = java.util.List.of(1, 2);  // b has type &#39;List&lt;Integer&gt;&#39;
var c = &quot;x&quot;.getClass();   // c has type &#39;Class&lt;? extends String&gt;&#39;
                          // (see JLS 15.12.2.6)
var d = new Object() {};  // d has the type of the anonymous class
var e = (CharSequence &amp; Comparable&lt;String&gt;) &quot;x&quot;;
                          // e has type CharSequence &amp; Comparable&lt;String&gt;
var f = () -&gt; &quot;hello&quot;;    // Illegal: lambda not in an assignment context
var g = null;             // Illegal: null type</code></pre>
<p>Note that some variables declared with <code>var</code> cannot be declared with an explicit type, because the type of the variable is not denotable.</p>
</div>
<blockquote>
<p>Upward projection is applied to the type of the initializer when determining the type of the variable. If the type of the initializer contains capture variables, this projection maps the type of the initializer to a supertype that does not contain capture variables.</p>
</blockquote>
<blockquote>
<p>While it would be possible to allow the type of the variable to mention capture variables, by projecting them away we enforce an attractive invariant that the scope of a capture variable is never larger than the statement containing the expression whose type is captured. Informally, capture variables cannot &quot;leak&quot; into subsequent statements.</p>
</blockquote>
<p>A local variable of type <code>float</code> always contains a value that is an element of the float value set (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.2.3">4.2.3</a>); similarly, a local variable of type <code>double</code> always contains a value that is an element of the double value set. It is not permitted for a local variable of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a local variable of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.</p>
<p>The scope and shadowing of a local variable declaration is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to a local variable from a nested class or a lambda expression are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<h3 id="jls-14.14">14.14 The <code>for</code> Statement</h3>
<h4 id="jls-14.14.1">14.14.1 The basic <code>for</code> Statement</h4>
<p>The basic <code>for</code> statement executes some initialization code, then executes an <em>Expression</em>, a <em>Statement</em>, and some update code repeatedly until the value of the <em>Expression</em> is <code>false</code>.</p>
<dl>
<dt><em>BasicForStatement:</em></dt>
<dd><code>for</code> <code>(</code> [<em>ForInit</em>] <code>;</code> [<em>Expression</em>] <code>;</code> [<em>ForUpdate</em>] <code>)</code> <em>Statement</em>
</dd>
<dt><em>BasicForStatementNoShortIf:</em></dt>
<dd><code>for</code> <code>(</code> [<em>ForInit</em>] <code>;</code> [<em>Expression</em>] <code>;</code> [<em>ForUpdate</em>] <code>)</code> <em>StatementNoShortIf</em>
</dd>
<dt><em>ForInit:</em></dt>
<dd><em>StatementExpressionList</em>
</dd>
<dd><em>LocalVariableDeclaration</em>
</dd>
<dt><em>ForUpdate:</em></dt>
<dd><em>StatementExpressionList</em>
</dd>
<dt><em>StatementExpressionList:</em></dt>
<dd><em>StatementExpression</em> {<code>,</code> <em>StatementExpression</em>}
</dd>
</dl>
<p>The <em>Expression</em> must have type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.</p>
<p>The scope and shadowing of a local variable declared in the <em>ForInit</em> part of a basic <code>for</code> statement is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to a local variable from a nested class or a lambda expression are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<h4 id="jls-14.14.2">14.14.2 The enhanced <code>for</code> statement</h4>
<p>The enhanced <code>for</code> statement has the form:</p>
<dl>
<dt><em>EnhancedForStatement:</em></dt>
<dd><code>for</code> <code>(</code> {<em>VariableModifier</em>} <em>LocalVariableType</em> <em>VariableDeclaratorId</em><br />
<code>:</code> <em>Expression</em> <code>)</code><br />
<em>Statement</em>
</dd>
<dt><em>EnhancedForStatementNoShortIf:</em></dt>
<dd><code>for</code> <code>(</code> {<em>VariableModifier</em>} <em>LocalVariableType</em> <em>VariableDeclaratorId</em><br />
<code>:</code> <em>Expression</em> <code>)</code><br />
<em>StatementNoShortIf</em>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3">4.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3">8.3</a>, <a href="#jls-8.4.1">8.4.1</a>, and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>VariableModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
<dd><code>final</code>
</dd>
<dt><em>LocalVariableType:</em></dt>
<dd><em>UnannType</em>
</dd>
<dd><code>var</code>
</dd>
<dt><em>VariableDeclaratorId:</em></dt>
<dd><em>Identifier</em> [<em>Dims</em>]
</dd>
<dt><em>Dims:</em></dt>
<dd>{<em>Annotation</em>} <code>[</code> <code>]</code> {{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<p>The header of the enhanced <code>for</code> statement declares a local variable, whose name is the identifier given by <em>VariableDeclaratorId</em>.</p>
<p>If the keyword <code>final</code> appears at the start of the declaration, the variable being declared is a <code>final</code> variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>It is a compile-time error if the <em>LocalVariableType</em> is <code>var</code> and the <em>VariableDeclaratorId</em> has one or more bracket pairs.</p>
<p>The type of the <em>Expression</em> must be a subtype of the raw type <code>Iterable</code> or an array type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.1">10.1</a>), or a compile-time error occurs.</p>
<p>The type of the local variable is determined as follows:</p>
<ul>
<li><p>If <em>LocalVariableType</em> is an <em>UnannType</em>, and no bracket pairs appear in <em>UnannType</em> or <em>VariableDeclaratorId</em>, then <em>UnannType</em> denotes the type of the local variable.</p></li>
<li><p>If <em>LocalVariableType</em> is an <em>UnannType</em>, and bracket pairs appear in <em>UnannType</em> or <em>VariableDeclaratorId</em>, then the type of the local variable is specified by <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.2">10.2</a>.</p></li>
<li><p>If <em>LocalVariableType</em> is <code>var</code>, then let <em>T</em> be derived from the type of the <em>Expression</em>, as follows:</p>
<ul>
<li><p>If the <em>Expression</em> has an array type, then <em>T</em> is the component type of the array type.</p></li>
<li><p>Otherwise, if the <em>Expression</em> has a type that is a subtype of <code>Iterable&lt;</code><em>X</em><code>&gt;</code>, for some type <em>X</em>, then <em>T</em> is <em>X</em>.</p></li>
<li><p>Otherwise, the <em>Expression</em> has a type that is a subtype of the raw type <code>Iterable</code>, and <em>T</em> is <code>Object</code>.</p></li>
</ul>
<p>The type of the local variable is the upward projection of <em>T</em> with respect to all synthetic type variables mentioned by <em>T</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10.5">4.10.5</a>).</p></li>
</ul>
<p>The scope and shadowing of the local variable is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to the local variable from a nested class or a lambda expression are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<p>When an enhanced <code>for</code> statement is executed, the local variable is initialized, on each iteration of the loop, to successive elements of the array or <code>Iterable</code> produced by the expression. The precise meaning of the enhanced <code>for</code> statement is given by translation into a basic <code>for</code> statement, as follows:</p>
<p>...</p>
<h3 id="jls-14.20">14.20 The <code>try</code> statement</h3>
<p>A <code>try</code> statement executes a block. If a value is thrown and the <code>try</code> statement has one or more <code>catch</code> clauses that can catch it, then control will be transferred to the first such <code>catch</code> clause. If the <code>try</code> statement has a <code>finally</code> clause, then another block of code is executed, no matter whether the <code>try</code> block completes normally or abruptly, and no matter whether a <code>catch</code> clause is first given control.</p>
<dl>
<dt><em>TryStatement:</em></dt>
<dd><code>try</code> <em>Block</em> <em>Catches</em>
</dd>
<dd><code>try</code> <em>Block</em> [<em>Catches</em>] <em>Finally</em>
</dd>
<dd><em>TryWithResourcesStatement</em>
</dd>
<dt><em>Catches:</em></dt>
<dd><em>CatchClause</em> {<em>CatchClause</em>}
</dd>
<dt><em>CatchClause:</em></dt>
<dd><code>catch</code> <code>(</code> <em>CatchFormalParameter</em> <code>)</code> <em>Block</em>
</dd>
<dt><em>CatchFormalParameter:</em></dt>
<dd>{<em>VariableModifier</em>} <em>CatchType</em> <em>VariableDeclaratorId</em>
</dd>
<dt><em>CatchType:</em></dt>
<dd><em>UnannClassType</em> {<code>|</code> <em>ClassType</em>}
</dd>
<dt><em>Finally:</em></dt>
<dd><code>finally</code> <em>Block</em>
</dd>
</dl>
<blockquote>
<p>See <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3">8.3</a> for <em>UnannClassType</em>. The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3">4.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3">8.3</a>, and <a href="#jls-8.4.1">8.4.1</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>VariableModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
<dd><code>final</code>
</dd>
<dt><em>VariableDeclaratorId:</em></dt>
<dd><em>Identifier</em> [<em>Dims</em>]
</dd>
<dt><em>Dims:</em></dt>
<dd>{<em>Annotation</em>} <code>[</code> <code>]</code> {{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<p>The <em>Block</em> immediately after the keyword <code>try</code> is called the <em><code>try</code> block</em> of the <code>try</code> statement.</p>
<p>The <em>Block</em> immediately after the keyword <code>finally</code> is called the <em><code>finally</code> block</em> of the <code>try</code> statement.</p>
<p>A <code>try</code> statement may have <code>catch</code> clauses, also called <em>exception handlers</em>.</p>
<p>A <code>catch</code> clause declares exactly one parameter, which is called an <em>exception parameter</em>.</p>
<p>It is a compile-time error if <code>final</code> appears more than once as a modifier for an exception parameter declaration.</p>
<p>The scope and shadowing of an exception parameter is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to an exception parameter from a nested class or a lambda expression are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<p>An exception parameter may denote its type as either a single class type or a union of two or more class types (called <em>alternatives</em>). The alternatives of a union are syntactically separated by <code>|</code>.</p>
<p>A <code>catch</code> clause whose exception parameter is denoted as a single class type is called a <em>uni-<code>catch</code> clause</em>.</p>
<p>A <code>catch</code> clause whose exception parameter is denoted as a union of types is called a <em>multi-<code>catch</code> clause</em>.</p>
<p>...</p>
<h4 id="jls-14.20.3">14.20.3 <code>try</code>-with-resources</h4>
<p>A <code>try</code>-with-resources statement is parameterized with local variables (known as <em>resources</em>) that are initialized before execution of the <code>try</code> block and closed automatically, in the reverse order from which they were initialized, after execution of the <code>try</code> block. <code>catch</code> clauses and a <code>finally</code> clause are often unnecessary when resources are closed automatically.</p>
<dl>
<dt><em>TryWithResourcesStatement:</em></dt>
<dd><code>try</code> <em>ResourceSpecification</em> <em>Block</em> [<em>Catches</em>] [<em>Finally</em>]
</dd>
<dt><em>ResourceSpecification:</em></dt>
<dd><code>(</code> <em>ResourceList</em> [<code>;</code>] <code>)</code>
</dd>
<dt><em>ResourceList:</em></dt>
<dd><em>Resource</em> {<code>;</code> <em>Resource</em>}
</dd>
<dt><em>Resource:</em></dt>
<dd>{<em>VariableModifier</em>} <em>LocalVariableType</em> <em>Identifier</em> <code>=</code> <em>Expression</em>
</dd>
<dd><em>VariableAccess</em>
</dd>
<dt><em>VariableAccess:</em></dt>
<dd><em>ExpressionName</em>
</dd>
<dd><em>FieldAccess</em>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="#jls-8.4.1">8.4.1</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>VariableModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
<dd><code>final</code>
</dd>
<dt><em>LocalVariableType:</em></dt>
<dd><em>UnannType</em>
</dd>
<dd><code>var</code>
</dd>
</dl>
</blockquote>
<p>A <em>resource specification</em> uses variables to denote <em>resources</em> for the <code>try</code> statement, either by declaring local variables with initializer expressions or by referring to suitable existing variables. An existing variable is referred to by either an expression name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.6">6.5.6</a>) or a field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11">15.11</a>).</p>
<p>It is a compile-time error for a resource specification to declare two variables with the same name.</p>
<p>It is a compile-time error if <code>final</code> appears more than once as a modifier for each variable declared in a resource specification.</p>
<p>A variable declared in a resource specification is implicitly declared <code>final</code> if it is not explicitly declared <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>A resource denoted by an expression name or field access expression must be a <code>final</code> or effectively <code>final</code> variable that is definitely assigned before the <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-16.html">16</a>), or a compile-time error occurs.</p>
<p>It is a compile-time error if the <em>LocalVariableType</em> of a variable declared in a resource specification is <code>var</code> and the initializer expression contains a reference to the variable.</p>
<p>The type of a variable declared in a resource specification is determined as follows:</p>
<ul>
<li><p>If <em>LocalVariableType</em> is an <em>UnannType</em>, then <em>UnannType</em> denotes the type of the local variable.</p></li>
<li><p>If <em>LocalVariableType</em> is <code>var</code>, then let <em>T</em> be the type of the initializer expression when treated as if it did not appear in an assignment context, and were thus a standalone expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.2">15.2</a>). The type of the local variable is the upward projection of <em>T</em> with respect to all synthetic type variables mentioned by <em>T</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10.5">4.10.5</a>).</p>
<p>It is a compile-time error if <em>T</em> is the null type.</p></li>
</ul>
<p>The type of a variable declared or referred to as a resource in a resource specification must be a subtype of <code>AutoCloseable</code>, or a compile-time error occurs.</p>
<p>The scope and shadowing of a variable declared in a resource specification is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to a variable declared in a resource specification from a nested class are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<p>Resources are initialized in left-to-right order. If a resource fails to initialize (that is, its initializer expression throws an exception), then all resources initialized so far by the <code>try</code>-with-resources statement are closed. If all resources initialize successfully, the <code>try</code> block executes as normal and then all non-null resources of the <code>try</code>-with-resources statement are closed.</p>
<p>Resources are closed in the reverse order from that in which they were initialized. A resource is closed only if it initialized to a non-null value. An exception from the closing of one resource does not prevent the closing of other resources. Such an exception is <em>suppressed</em> if an exception was thrown previously by an initializer, the <code>try</code> block, or the closing of a resource.</p>
<p>A <code>try</code>-with-resources statement whose resource specification indicates multiple resources is treated as if it were multiple <code>try</code>-with-resources statements, each of which has a resource specification that indicates a single resource. When a <code>try</code>-with-resources statement with <em>n</em> resources (<em>n</em> &gt; 1) is translated, the result is a <code>try</code>-with-resources statement with <em>n</em>-1 resources. After <em>n</em> such translations, there are <em>n</em> nested <code>try</code>-<code>catch</code>-<code>finally</code> statements, and the overall translation is complete.</p>
<h2 id="jls-15">Chapter 15: Expressions</h2>
<h3 id="jls-15.8">15.8 Primary Expressions</h3>
<h4 id="jls-15.8.3">15.8.3 <code>this</code></h4>
<div class="deleted">
<p>The keyword <code>this</code> may be used only in the following contexts:</p>
<ul>
<li><p>in the body of an instance method or default method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.7">8.4.7</a>, <a href="#jls-9.4.3">9.4.3</a>)</p></li>
<li><p>in the body of a constructor of a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.7">8.8.7</a>)</p></li>
<li><p>in an instance initializer of a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.6">8.6</a>)</p></li>
<li><p>in the initializer of an instance variable of a class (<a href="#jls-8.3.2">8.3.2</a>)</p></li>
<li><p>to denote a receiver parameter (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
</ul>
<p>If it appears anywhere else, a compile-time error occurs.</p>
<p>The keyword <code>this</code> may be used in a lambda expression only if it is allowed in the context in which the lambda expression appears. Otherwise, a compile-time error occurs.</p>
</div>
<p>When used as a primary expression, the keyword <code>this</code> denotes a value that is a reference to the object for which the instance method or default method was invoked (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>), or to the object being constructed. The value denoted by <code>this</code> in a lambda body is the same as the value denoted by <code>this</code> in the surrounding context.</p>
<blockquote>
<p>The keyword <code>this</code> is also used in explicit constructor invocation statements (<a href="#jls-8.8.7.1">8.8.7.1</a>).</p>
</blockquote>
<p>Let <em>C</em> be the innermost enclosing class or interface declaration of a <code>this</code> expression. If <em>C</em> is generic, with type parameters <em>F<sub>1</sub></em>, ..., <em>F<sub>n</sub></em>, the type of <code>this</code> is <em>C&lt;F<sub>1</sub>, ..., F<sub>n</sub>&gt;</em>. Otherwise, the type of <code>this</code> is <em>C</em>.</p>
<p><strong>It is a compile-time error if the <code>this</code> expression occurs in a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<div class="editorial">
<p>There's no need to enumerate all the places where <code>this</code> can be used when we've already defined the concept of <em>static context</em>.</p>
</div>
<p>At run time, the class of the actual object referred to may be <em>C</em>, if <em>C</em> is a class, or a subclass of <em>C</em>.</p>
<div class="example">
<p>Example 15.8.3-1. The <code>this</code> Expression</p>
<pre><code>class IntVector {
    int[] v;
    boolean equals(IntVector other) {
        if (this == other)
            return true;
        if (v.length != other.v.length)
            return false;
        for (int i = 0; i &lt; v.length; i++) {
            if (v[i] != other.v[i]) return false;
        }
        return true;
    }
}</code></pre>
<p>Here, the class <code>IntVector</code> implements a method <code>equals</code>, which compares two vectors. If the other vector is the same vector object as the one for which the <code>equals</code> method was invoked, then the check can skip the length and value comparisons. The <code>equals</code> method implements this check by comparing the reference to the other object to <code>this</code>.</p>
</div>
<h4 id="jls-15.8.4">15.8.4 Qualified <code>this</code></h4>
<p>Any lexically enclosing instance (<a href="#jls-8.1.3">8.1.3</a>) can be referred to by explicitly qualifying the keyword <code>this</code>.</p>
<p>Let <em>n</em> be an integer such that <em>TypeName</em> is the <em>n</em>'th lexically enclosing class or interface declaration of the class or interface <del>in which</del> <strong>immediately enclosing</strong> the qualified <code>this</code> expression <del>appears</del>.</p>
<p>The value of an expression of the form <em>TypeName</em><code>.this</code> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p>
<p>If <em>TypeName</em> is generic, with type parameters <em>F<sub>1</sub></em>, ..., <em>F<sub>n</sub></em>, the type of the expression is <em>TypeName&lt;F<sub>1</sub>, ..., F<sub>n</sub>&gt;</em>. Otherwise, the type of the expression is <em>TypeName</em>.</p>
<p><del>It is a compile-time error if <em>TypeName</em> is not a lexically enclosing class or interface declaration of the expression, or if the expression occurs in a class or interface which is not an inner class of <em>TypeName</em> or <em>TypeName</em> itself.</del></p>
<p><strong>It is a compile-time error if a qualified <code>this</code> expression occurs in a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<p><strong>It is a compile-time error if the immediately enclosing class or interface declaration of a qualified <code>this</code> expression is not an inner class of <em>TypeName</em> or <em>TypeName</em> itself.</strong></p>
<h3 id="jls-15.9">15.9 Class Instance Creation Expressions</h3>
<h4 id="jls-15.9.2">15.9.2 Determining Enclosing Instances</h4>
<p>Let <em>C</em> be the class being instantiated, and let <em>i</em> be the instance being created. If <em>C</em> is an inner class, then <em>i</em> may have an <em>immediately enclosing instance</em> (<a href="#jls-8.1.3">8.1.3</a>), determined as follows:</p>
<ul>
<li><p>If <em>C</em> is an anonymous class, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then <em>i</em> has no immediately enclosing instance.</p></li>
<li><p>Otherwise, the immediately enclosing instance of <em>i</em> is <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>C</em> is <del>a</del> <strong>an inner</strong> local class, then:</p>
<ul>
<li><p>If <em>C</em> occurs in a static context, then <em>i</em> has no immediately enclosing instance.</p></li>
<li><p>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p><strong>Otherwise, let <em>O</em> be the immediately enclosing class or interface declaration of <em>C</em>, and let <em>U</em> be the immediately enclosing class or interface declaration of the class instance creation expression. If <em>U</em> is not an inner class of <em>O</em> or <em>O</em> itself, then a compile-time error occurs.</strong></p></li>
<li><p>Otherwise, let <del><em>O</em> be the immediately enclosing class or interface declaration of <em>C</em>. Let</del> <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing class or interface declaration of <del>the class or interface in which the class instance creation expression appears</del> <strong><em>U</em></strong>.</p>
<p>The immediately enclosing instance of <em>i</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>C</em> is an inner member class, then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p><strong>Otherwise, if <em>C</em> is not a member of any class whose declaration encloses the class instance creation expression, then a compile-time error occurs.</strong></p></li>
<li><p><strong>Otherwise, let <em>O</em> be the innermost enclosing class declaration of which <em>C</em> is a member, and let <em>U</em> be the immediately enclosing class or interface declaration of the class instance creation expression. If <em>U</em> is not an inner class of <em>O</em> or <em>O</em> itself, then a compile-time error occurs.</strong></p></li>
<li><p>Otherwise, <del>if <em>C</em> is a member of a class enclosing the class or interface in which the class instance creation expression appears, then let <em>O</em> be the immediately enclosing class of which <em>C</em> is a member. Let</del> <strong>let</strong> <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing class or interface declaration of <del>the class or interface in which the class instance creation expression appears</del> <strong><em>U</em></strong>.</p>
<p>The immediately enclosing instance of <em>i</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
<li><p><del>Otherwise, a compile-time error occurs.</del></p></li>
</ul></li>
<li><p>If the class instance creation expression is qualified, then the immediately enclosing instance of <em>i</em> is the object that is the value of the <em>Primary</em> expression or the <em>ExpressionName</em>.</p></li>
</ul></li>
</ul>
<p>If <em>C</em> is an anonymous class, and its direct superclass <em>S</em> is an inner class, then <em>i</em> may have an <em>immediately enclosing instance with respect to S</em>, determined as follows:</p>
<ul>
<li><p>If <em>S</em> is <del>a</del> <strong>an inner</strong> local class, then:</p>
<ul>
<li><p>If <em>S</em> occurs in a static context, then <em>i</em> has no immediately enclosing instance with respect to <em>S</em>.</p></li>
<li><p>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p><strong>Otherwise, let <em>O</em> be the immediately enclosing class or interface declaration of <em>S</em>, and let <em>U</em> be the immediately enclosing class or interface declaration of the class instance creation expression. If <em>U</em> is not an inner class of <em>O</em> or <em>O</em> itself, then a compile-time error occurs.</strong></p></li>
<li><p>Otherwise, let <del><em>O</em> be the immediately enclosing class or interface declaration of <em>S</em>. Let</del> <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing class or interface declaration of <del>the class or interface in which the class instance creation expression appears</del> <strong><em>U</em></strong>.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>S</em> is an inner member class, then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p><strong>Otherwise, if <em>S</em> is not a member of any class whose declaration encloses the class instance creation expression, then a compile-time error occurs.</strong></p></li>
<li><p><strong>Otherwise, let <em>O</em> be the innermost enclosing class declaration of which <em>S</em> is a member, and let <em>U</em> be the immediately enclosing class or interface declaration of the class instance creation expression. If <em>U</em> is not an inner class of <em>O</em> or <em>O</em> itself, then a compile-time error occurs.</strong></p></li>
<li><p>Otherwise, <del>if <em>S</em> is a member of a class enclosing the class or interface in which the class instance creation expression appears, then let <em>O</em> be the immediately enclosing class of which <em>S</em> is a member. Let</del> <strong>let</strong> <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing class or interface declaration of <del>the class or interface in which the class instance creation expression appears</del> <strong><em>U</em></strong>.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the class instance creation expression is qualified, then the immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the object that is the value of the <em>Primary</em> expression or the <em>ExpressionName</em>.</p></li>
</ul></li>
</ul>
<h3 id="jls-15.11">15.11 Field Access Expressions</h3>
<h4 id="jls-15.11.2">15.11.2 Accessing Superclass Members using <code>super</code></h4>
<p>The form <code>super.</code><em>Identifier</em> refers to the field named <em>Identifier</em> of the current object, but with the current object viewed as an instance of the superclass of the current class.</p>
<p>The form <em>T</em><code>.super.</code><em>Identifier</em> refers to the field named <em>Identifier</em> of the lexically enclosing instance corresponding to <em>T</em>, but with that instance viewed as an instance of the superclass of <em>T</em>.</p>
<div class="deleted">
<p>The forms using the keyword <code>super</code> are valid only in an instance method, instance initializer, or constructor of a class, or in the initializer of an instance variable of a class. If they appear anywhere else, a compile-time error occurs.</p>
<blockquote>
<p>These are exactly the same situations in which the keyword <code>this</code> may be used in a class declaration (<a href="#jls-15.8.3">15.8.3</a>).</p>
</blockquote>
</div>
<p><strong>It is a compile-time error if a field access expression using the keyword <code>super</code> appears in a static context (<a href="#jls-8.1.3">8.1.3</a>).</strong></p>
<p><del>It is a compile-time error if the forms using the keyword <code>super</code> appear in the declaration of class <code>Object</code>, since <code>Object</code> has no superclass.</del></p>
<p><strong>It is a compile-time error if the immediately enclosing class or interface declaration of a field access expression of the form <code>super.</code><em>Identifier</em> is the class <code>Object</code> or an interface.</strong></p>
<p><strong>Let <em>U</em> be the immediately enclosing class or interface declaration of a field access expression of the form <em>T</em><code>.super.</code><em>Identifier</em>. It is a compile-time error if <em>U</em> is not an inner class of <em>T</em> or <em>T</em> itself. It is a compile-time error if <em>T</em> is the class <code>Object</code> or an interface.</strong></p>
<div class="editorial">
<p>The restriction on interfaces was not specified previously, although it became relevant when default methods were introduced. Compare <a href="#jls-15.12.1">15.12.1</a>.</p>
</div>
<p>Suppose that a field access expression <code>super.</code><em>f</em> appears within class <em>C</em>, and the immediate superclass of <em>C</em> is class <em>S</em>. If <em>f</em> in <em>S</em> is accessible from class <em>C</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>), then <code>super.</code><em>f</em> is treated as if it had been the expression <code>this.</code><em>f</em> in the body of class <em>S</em>. Otherwise, a compile-time error occurs.</p>
<blockquote>
<p>Thus, <code>super.</code><em>f</em> can access the field <em>f</em> that is accessible in class <em>S</em>, even if that field is hidden by a declaration of a field <em>f</em> in class <em>C</em>.</p>
</blockquote>
<p>Suppose that a field access expression <em>T</em><code>.super.</code><em>f</em> appears within class <em>C</em>, and the immediate superclass of the class denoted by <em>T</em> is a class whose fully qualified name is <em>S</em>. If <em>f</em> in <em>S</em> is accessible from <em>C</em>, then <em>T</em><code>.super.</code><em>f</em> is treated as if it had been the expression <code>this.</code><em>f</em> in the body of class <em>S</em>. Otherwise, a compile-time error occurs.</p>
<blockquote>
<p>Thus, <em>T</em><code>.super.</code><em>f</em> can access the field <em>f</em> that is accessible in class <em>S</em>, even if that field is hidden by a declaration of a field <em>f</em> in class <em>T</em>.</p>
</blockquote>
<p><del>It is a compile-time error if the current class is not an inner class of class <em>T</em> or <em>T</em> itself.</del></p>
<div class="example">
<p>Example 15.11.2-1. The <code>super</code> Expression</p>
<pre><code>interface I           { int x = 0; }
class T1 implements I { int x = 1; }
class T2 extends T1   { int x = 2; }
class T3 extends T2 {
    int x = 3;
    void test() {
        System.out.println(&quot;x=\t\t&quot;          + x);
        System.out.println(&quot;super.x=\t\t&quot;    + super.x);
        System.out.println(&quot;((T2)this).x=\t&quot; + ((T2)this).x);
        System.out.println(&quot;((T1)this).x=\t&quot; + ((T1)this).x);
        System.out.println(&quot;((I)this).x=\t&quot;  + ((I)this).x);
    }
}
class Test {
    public static void main(String[] args) {
        new T3().test();
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>x=              3
super.x=        2
((T2)this).x=   2
((T1)this).x=   1
((I)this).x=    0</code></pre>
<p>Within class <code>T3</code>, the expression <code>super.x</code> has the same effect as <code>((T2)this).x</code> when <code>x</code> has package access. Note that <code>super.x</code> is not specified in terms of a cast, due to difficulties around access to <code>protected</code> members of the superclass.</p>
</div>
<h3 id="jls-15.12">15.12 Method Invocation Expressions</h3>
<h4 id="jls-15.12.1">15.12.1 Compile-Time Step 1: Determine Type to Search</h4>
<p>The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which type to search for definitions of methods of that name.</p>
<p>The name of the method is specified by the <em>MethodName</em> or <em>Identifier</em> which immediately precedes the left parenthesis of the <em>MethodInvocation</em>.</p>
<p>For the type to search, there are six cases to consider, depending on the form that precedes the left parenthesis of the <em>MethodInvocation</em>:</p>
<ul>
<li><p>If the form is <em>MethodName</em>, that is, just an <em>Identifier</em>, then:</p>
<p>If the <em>Identifier</em> appears in the scope of a method declaration with that name (<a href="#jls-6.3">6.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>), then:</p>
<ul>
<li><p>If there is an enclosing class or interface declaration of which that method is a member, let <em>E</em> be the innermost such class or interface declaration. The type to search is the type of <em>E</em>.<code>this</code> (<a href="#jls-15.8.4">15.8.4</a>).</p>
<blockquote>
<p>This search policy is called the &quot;comb rule&quot;. It effectively looks for methods in a nested class's superclass hierarchy before looking for methods in an enclosing class and its superclass hierarchy. See <a href="#jls-6.5.7.1">6.5.7.1</a> for an example.</p>
</blockquote></li>
<li><p>Otherwise, the method declaration may be in scope due to one or more single-static-import or static-import-on-demand declarations. There is no type to search, as the method to be invoked is determined later (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.1">15.12.2.1</a>).</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the type to search is the (possibly raw) type denoted by <em>TypeName</em>.</p></li>
<li><p>If the form is <em>ExpressionName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the type to search is the declared type <em>T</em> of the variable denoted by <em>ExpressionName</em> if <em>T</em> is a class or interface type, or the upper bound of <em>T</em> if <em>T</em> is a type variable.</p></li>
<li><p>If the form is <em>Primary</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then let <em>T</em> be the type of the <em>Primary</em> expression. The type to search is <em>T</em> if <em>T</em> is a class or interface type, or the upper bound of <em>T</em> if <em>T</em> is a type variable.</p>
<p>It is a compile-time error if <em>T</em> is not a reference type.</p></li>
<li><p>If the form is <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the type to search is the direct superclass type of the class whose declaration contains the method invocation.</p>
<p>Let <em>E</em> be the class or interface declaration immediately enclosing the method invocation. It is a compile-time error if <em>E</em> is the class <code>Object</code> or <em>E</em> is an interface.</p></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if <em>TypeName</em> denotes neither a class nor an interface.</p></li>
<li><p>If <em>TypeName</em> denote a class, <em>C</em>, then the type to search is the direct superclass type of <em>C</em>.</p>
<p>It is a compile-time error if <em>C</em> is not a lexically enclosing class or interface declaration of the <del>current class or interface</del> <strong>method invocation expression</strong>, or if <em>C</em> is the class <code>Object</code>.</p>
<div class="editorial">
<p><em>C</em> may be the current class.</p>
</div>
<p><del>Let <em>E</em> be the class or interface declaration immediately enclosing the method invocation. It is a compile-time error if <em>E</em> is the class <code>Object</code>.</del></p>
<div class="editorial">
<p>This is unnecessary—<code>Object</code> has no enclosing type declaration, but if it did, there would be nothing wrong with referring to that class's <code>super</code> methods.</p>
</div></li>
<li><p>Otherwise, <em>TypeName</em> denotes an interface, <em>I</em>.</p>
<p>Let <em>E</em> be the class or interface declaration immediately enclosing the method invocation. It is a compile-time error if <em>I</em> is not a direct superinterface of <em>E</em>, or if there exists some other direct superclass or direct superinterface of <em>E</em>, <em>J</em>, such that <em>J</em> is a subclass or subinterface of <em>I</em>.</p>
<p>The type to search is the type of <em>I</em> that is a direct superinterface type of <em>E</em>.</p></li>
</ul></li>
</ul>
<blockquote>
<p>The <em>TypeName</em> <code>.</code> <code>super</code> syntax is overloaded: traditionally, the <em>TypeName</em> refers to a lexically enclosing class declaration, and the target is the superclass of this class, as if the invocation were an unqualified <code>super</code> in the lexically enclosing class declaration.</p>
<pre><code>class Superclass {
    void foo() { System.out.println(&quot;Hi&quot;); }
}

class Subclass1 extends Superclass {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass1.super.foo();  // Gets the &#39;println&#39; behavior
        }
    };
}</code></pre>
<p>To support invocation of default methods in superinterfaces, the <em>TypeName</em> may also refer to a direct superinterface of the current class or interface, and the target is that superinterface.</p>
<pre><code>interface Superinterface {
    default void foo() { System.out.println(&quot;Hi&quot;); }
}

class Subclass2 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    void tweak() {
        Superinterface.super.foo();  // Gets the &#39;println&#39; behavior
    }
}</code></pre>
<p>No syntax supports a combination of these forms, that is, invoking a superinterface method of a lexically enclosing class declaration, as if the invocation were of the form <em>InterfaceName</em> <code>.</code> <code>super</code> in the lexically enclosing class declaration.</p>
<pre><code>class Subclass3 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass3.Superinterface.super.foo();  // Illegal
        }
    };
}</code></pre>
<p>A workaround is to introduce a <code>private</code> method in the lexically enclosing class declaration that performs the interface <code>super</code> call.</p>
</blockquote>
<h4 id="jls-15.12.3">15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?</h4>
<p>If there is a most specific method declaration for a method invocation, it is called the <em>compile-time declaration</em> for the method invocation.</p>
<p>It is a compile-time error if an argument to a method invocation is not compatible with its target type, as derived from the invocation type of the compile-time declaration.</p>
<p>If the compile-time declaration is applicable by variable arity invocation, then where the last formal parameter type of the invocation type of the method is <em>F<sub>n</sub></em><code>[]</code>, it is a compile-time error if the type which is the erasure of <em>F<sub>n</sub></em> is not accessible (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6">6.6</a>) at the point of invocation.</p>
<p>If the compile-time declaration is <code>void</code>, then the method invocation must be a top level expression (that is, the <em>Expression</em> in an expression statement or in the <em>ForInit</em> or <em>ForUpdate</em> part of a <code>for</code> statement), or a compile-time error occurs. Such a method invocation produces no value and so must be used only in a situation where a value is not needed.</p>
<p>In addition, whether the compile-time declaration is appropriate may depend on the form of the method invocation expression before the left parenthesis, as follows:</p>
<ul>
<li><p>If the form is <em>MethodName</em> - that is, just an <em>Identifier</em> - and the compile-time declaration is an instance method, then:</p>
<ul>
<li><p>It is a compile-time error if the method invocation occurs in a static context (<a href="#jls-8.1.3">8.1.3</a>).</p></li>
<li><p><del>Otherwise, let <em>C</em> be the immediately enclosing class or interface declaration of which the compile-time declaration is a member. If the method invocation is not directly enclosed by <em>C</em> or an inner class of <em>C</em>, then a compile-time error occurs.</del></p>
<p><strong>Otherwise, let <em>T</em> be the class or interface to search (<a href="#jls-15.12.1">15.12.1</a>). It is a compile-time error if the innermost enclosing class or interface declaration of the method invocation is neither <em>T</em> nor an inner class of <em>T</em>.</strong></p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the compile-time declaration must be <code>static</code>, or a compile-time error occurs.</p></li>
<li><p>If the form is <em>ExpressionName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>Primary</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the compile-time declaration must not be a <code>static</code> method declared in an interface, or a compile-time error occurs.</p></li>
<li><p>If the form is <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if the compile-time declaration is <code>abstract</code>.</p></li>
<li><p>It is a compile-time error if the method invocation occurs in a static context.</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if the compile-time declaration is <code>abstract</code>.</p></li>
<li><p>It is a compile-time error if the method invocation occurs in a static context.</p></li>
<li><p>If <em>TypeName</em> denotes a class <em>C</em>, then if the <strong>immediately enclosing class or interface declaration of the</strong> method invocation is not <del>directly enclosed by</del> <em>C</em> or an inner class of <em>C</em>, a compile-time error occurs.</p></li>
<li><p>If <em>TypeName</em> denotes an interface, let <em>E</em> be the class or interface declaration immediately enclosing the method invocation. A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4.1">9.4.1</a>) the compile-time declaration from a direct superclass or direct superinterface of <em>E</em>.</p>
<blockquote>
<p>In the case that a superinterface overrides a method declared in a grandparent interface, this rule prevents the child interface from &quot;skipping&quot; the override by simply adding the grandparent to its list of direct superinterfaces. The appropriate way to access functionality of a grandparent is through the direct superinterface, and only if that interface chooses to expose the desired behavior. (Alternately, the programmer is free to define an additional superinterface that exposes the desired behavior with a <code>super</code> method invocation.)</p>
</blockquote></li>
</ul></li>
</ul>
<p>The <em>compile-time parameter types</em> and <em>compile-time result</em> are determined as follows:</p>
<ul>
<li><p>If the compile-time declaration for the method invocation is <em>not</em> a signature polymorphic method, then:</p>
<ul>
<li><p>The compile-time parameter types are the types of the formal parameters of the compile-time declaration.</p></li>
<li><p>The compile-time result is the result of the invocation type of the compile-time declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p></li>
</ul></li>
<li><p>If the compile-time declaration for the method invocation is a signature polymorphic method, then:</p>
<ul>
<li><p>The compile-time parameter types are the types of the actual argument expressions. An argument expression which is the null literal <code>null</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.10.7">3.10.7</a>) is treated as having the type <code>Void</code>.</p></li>
<li><p>The compile-time result is determined as follows:</p>
<ul>
<li><p>If the signature polymorphic method is either <code>void</code> or has a return type other than <code>Object</code>, the compile-time result is the result of the invocation type of the compile-time declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p></li>
<li><p>Otherwise, if the method invocation expression is an expression statement, the compile-time result is <code>void</code>.</p></li>
<li><p>Otherwise, if the method invocation expression is the operand of a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.16">15.16</a>), the compile-time result is the erasure of the type of the cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>).</p></li>
<li><p>Otherwise, the compile-time result is the signature polymorphic method's return type, <code>Object</code>.</p></li>
</ul></li>
</ul></li>
</ul>
<p>A method is <em>signature polymorphic</em> if all of the following are true:</p>
<ul>
<li><p>It is declared in the <code>java.lang.invoke.MethodHandle</code> class or the <code>java.lang.invoke.VarHandle</code> class.</p></li>
<li><p>It has a single variable arity parameter (<a href="#jls-8.4.1">8.4.1</a>) whose declared type is <code>Object[]</code>.</p></li>
<li><p>It is <code>native</code>.</p></li>
</ul>
<p>The following compile-time information is then associated with the method invocation for use at run time:</p>
<ul>
<li><p>The name of the method.</p></li>
<li><p>The qualifying type of the method invocation (<a href="#jls-13.1">13.1</a>).</p></li>
<li><p>The number of parameters and the compile-time parameter types, in order.</p></li>
<li><p>The compile-time result.</p></li>
<li><p>The invocation mode, computed as follows:</p>
<ul>
<li><p>If the compile-time declaration has the <code>static</code> modifier, then the invocation mode is <code>static</code>.</p></li>
<li><p>Otherwise, if the part of the method invocation before the left parenthesis is of the form <code>super</code> <code>.</code> <em>Identifier</em> or of the form <em>TypeName</em> <code>.</code> <code>super</code> <code>.</code> <em>Identifier</em>, then the invocation mode is <code>super</code>.</p></li>
<li><p>Otherwise, if the qualifying type of the method invocation is an interface, then the invocation mode is <code>interface</code>.</p></li>
<li><p>Otherwise, the invocation mode is <code>virtual</code>.</p></li>
</ul></li>
</ul>
<p>If the result of the invocation type of the compile-time declaration is not <code>void</code>, then the type of the method invocation expression is obtained by applying capture conversion (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>) to the return type of the invocation type of the compile-time declaration.</p>
<h3 id="jls-15.13">15.13 Method Reference Expressions</h3>
<h4 id="jls-15.13.1">15.13.1 Compile-Time Declaration of a Method Reference</h4>
<p>The <em>compile-time declaration</em> of a method reference expression is the method to which the expression refers. In special cases, the compile-time declaration does not actually exist, but is a notional method that represents a class instance creation or an array creation. The choice of compile-time declaration depends on a function type targeted by the expression, just as the compile-time declaration of a method invocation depends on the invocation's arguments (<a href="#jls-15.12.3">15.12.3</a>).</p>
<p>The search for a compile-time declaration mirrors the process for method invocations in <a href="#jls-15.12.1">15.12.1</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2">15.12.2</a>, as follows:</p>
<ul>
<li><p>First, a type to search is determined:</p>
<ul>
<li><p>If the method reference expression has the form <em>ExpressionName</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>Primary</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, the type to search is the type of the expression preceding the <code>::</code> token.</p></li>
<li><p>If the method reference expression has the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, the type to search is the result of capture conversion (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>) applied to <em>ReferenceType</em>.</p></li>
<li><p>If the method reference expression has the form <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, the type to search is the superclass type of the <del>class whose declaration contains</del> <strong>immediately enclosing class or interface declaration of</strong> the method reference.</p>
<p><strong>Let <em>T</em> be the class or interface declaration immediately enclosing the method reference expression. It is a compile-time error if <em>T</em> is the class <code>Object</code> or <em>T</em> is an interface.</strong></p></li>
<li><p>If the method reference expression has the form <em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, then if <em>TypeName</em> denotes a class, the type to search is the superclass type of the named class; otherwise, <em>TypeName</em> denotes an interface<del>, and the corresponding superinterface type of the class or interface whose declaration contains the method reference is the type</del> to search.</p>
<p><strong>It is a compile-time error if <em>TypeName</em> is neither a lexically enclosing class or interface declaration of the method reference expression nor a direct superinterface of the immediately enclosing class or interface declaration of the method reference expression.</strong></p>
<p><strong>It is a compile-time error if <em>TypeName</em> is the class <code>Object</code>.</strong></p>
<p><strong>It is a compile-time error if <em>TypeName</em> is an interface type, and there exists some other direct superclass or direct superinterface of the immediately enclosing class or interface declaration of the method reference expression, <em>J</em>, such that <em>J</em> is a subtype of <em>TypeName</em>.</strong></p>
<div class="editorial">
<p>Compare <a href="#jls-15.12.1">15.12.1</a>. These rules for method reference expressions don't seem to have been stated anywhere.</p>
</div></li>
<li><p>For the two other forms (involving <code>::</code> <code>new</code>), the referenced method is notional and there is no type to search.</p></li>
</ul></li>
<li><p>Second, given a targeted function type with <em>n</em> parameters, a set of potentially applicable methods is identified:</p>
<ul>
<li><p>If the method reference expression has the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the potentially applicable methods are:</p>
<ul>
<li><p>the member methods of the type to search that would be potentially applicable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.1">15.12.2.1</a>) for a method invocation which names <em>Identifier</em>, has arity <em>n</em>, has type arguments <em>TypeArguments</em>, and appears in the same class as the method reference expression; plus</p></li>
<li><p>the member methods of the type to search that would be potentially applicable for a method invocation which names <em>Identifier</em>, has arity <em>n</em>-1, has type arguments <em>TypeArguments</em>, and appears in the same class as the method reference expression.</p></li>
</ul>
<blockquote>
<p>Two different arities, <em>n</em> and <em>n</em>-1, are considered, to account for the possibility that this form refers to either a <code>static</code> method or an instance method.</p>
</blockquote></li>
<li><p>If the method reference expression has the form <em>ClassType</em> <code>::</code> <em>[TypeArguments]</em> <code>new</code>, then the potentially applicable methods are a set of notional methods corresponding to the constructors of <em>ClassType</em>.</p>
<p>If <em>ClassType</em> is a raw type, but is not a non-<code>static</code> member type of a raw type, the candidate notional member methods are those specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9.3">15.9.3</a> for a class instance creation expression that uses <code>&lt;&gt;</code> to elide the type arguments to a class. Otherwise, the candidate notional member methods are the constructors of <em>ClassType</em>, treated as if they were methods with return type <em>ClassType</em>.</p>
<p>Among these candidates, the potentially applicable methods are the notional methods that would be potentially applicable for a method invocation which has arity <em>n</em>, has type arguments <em>TypeArguments</em>, and appears in the same class as the method reference expression.</p></li>
<li><p>If the method reference expression has the form <em>ArrayType</em> <code>::</code> <code>new</code>, a single notional method is considered. The method has a single parameter of type <code>int</code>, returns the <em>ArrayType</em>, and has no <code>throws</code> clause. If <em>n</em> = 1, this is the only potentially applicable method; otherwise, there are no potentially applicable methods.</p></li>
<li><p>For all other forms, the potentially applicable methods are the member methods of the type to search that would be potentially applicable for a method invocation which names <em>Identifier</em>, has arity <em>n</em>, has type argument <em>TypeArguments</em>, and appears in the same class as the method reference expression.</p></li>
</ul></li>
<li><p>Finally, if there are no potentially applicable methods, then there is no compile-time declaration.</p>
<p>Otherwise, given a targeted function type with parameter types <em>P<sub>1</sub></em>, ..., <em>P<sub>n</sub></em> and a set of potentially applicable methods, the compile-time declaration is selected as follows:</p>
<ul>
<li><p>If the method reference expression has the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, then two searches for a most specific applicable method are performed. Each search is as specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.2">15.12.2.2</a> through <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.5">15.12.2.5</a>, with the clarifications below. Each search produces a set of applicable methods and, possibly, designates a most specific method of the set. In the case of an error as specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>, the set of applicable methods is empty. In the case of an error as specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.5">15.12.2.5</a>, there is no most specific method.</p>
<p>In the first search, the method reference is treated as if it were an invocation with argument expressions of types <em>P<sub>1</sub></em>, ..., <em>P<sub>n</sub></em>. Type arguments, if any, are given by the method reference expression.</p>
<p>In the second search, if <em>P<sub>1</sub></em>, ..., <em>P<sub>n</sub></em> is not empty and <em>P<sub>1</sub></em> is a subtype of <em>ReferenceType</em>, then the method reference expression is treated as if it were a method invocation expression with argument expressions of types <em>P<sub>2</sub></em>, ..., <em>P<sub>n</sub></em>. If <em>ReferenceType</em> is a raw type, and there exists a parameterization of this type, <em>G</em><code>&lt;</code>...<code>&gt;</code>, that is a supertype of <em>P<sub>1</sub></em>, the type to search is the result of capture conversion (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>) applied to <em>G</em><code>&lt;</code>...<code>&gt;</code>; otherwise, the type to search is the same as the type of the first search. Type arguments, if any, are given by the method reference expression.</p>
<p>If the first search produces a most specific method that is <code>static</code>, and the set of applicable methods produced by the second search contains no non-<code>static</code> methods, then the compile-time declaration is the most specified method of the first search.</p>
<p>Otherwise, if the set of applicable methods produced by the first search contains no <code>static</code> methods, and the second search produces a most specific method that is non-<code>static</code>, then the compile-time declaration is the most specific method of the second search.</p>
<p>Otherwise, there is no compile-time declaration.</p></li>
<li><p>For all other forms of method reference expression, one search for a most specific applicable method is performed. The search is as specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.2">15.12.2.2</a> through <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.5">15.12.2.5</a>, with the clarifications below.</p>
<p>The method reference is treated as if it were an invocation with argument expressions of types <em>P<sub>1</sub></em>, ..., <em>P<sub>n</sub></em>; the type arguments, if any, are given by the method reference expression.</p>
<p>If the search results in an error as specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.2">15.12.2.2</a> through <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.5">15.12.2.5</a>, or if the most specific applicable method is <code>static</code>, there is no compile-time declaration.</p>
<p>Otherwise, the compile-time declaration is the most specific applicable method.</p></li>
</ul></li>
</ul>
<p>It is a compile-time error if a method reference expression has the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, and the compile-time declaration is <code>static</code>, and <em>ReferenceType</em> is not a simple or qualified name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.2">6.2</a>).</p>
<p>It is a compile-time error if the method reference expression has the form <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, and the compile-time declaration is <code>abstract</code>.</p>
<p><strong>It is a compile-time error if the method reference expression has the form <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, and the method reference expression occurs in a static context.</strong></p>
<p><strong>It is a compile-time error if the method reference expression has the form <em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, and the method reference expression occurs in a static context, or, where <em>TypeName</em> denotes a class <em>C</em>, the immediately enclosing class or interface declaration of the method reference expression is not <em>C</em> or an inner class of <em>C</em>.</strong></p>
<div class="editorial">
<p>Compare <a href="#jls-15.12.3">15.12.3</a>.</p>
</div>
<p>It is a compile-time error if the method reference expression has the form <em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, and <em>TypeName</em> denotes an interface, and there exists a method, distinct from the compile-time declaration, that overrides (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.8">8.4.8</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4.1">9.4.1</a>) the compile-time declaration from a direct superclass or direct superinterface of the type whose declaration immediately encloses the method reference expression.</p>
<p>It is a compile-time error if the method reference expression is of the form <em>ClassType</em> <code>::</code> <em>[TypeArguments]</em> <code>new</code> and a compile-time error would occur when determining an enclosing instance for <em>ClassType</em> as specified in <a href="#jls-15.9.2">15.9.2</a> (treating the method reference expression as if it were an unqualified class instance creation expression).</p>
<blockquote>
<p>A method reference expression of the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> can be interpreted in different ways. If <em>Identifier</em> refers to an instance method, then the implicit lambda expression has an extra parameter compared to if <em>Identifier</em> refers to a <code>static</code> method. It is possible for <em>ReferenceType</em> to have both kinds of applicable methods, so the search algorithm described above identifies them separately, since there are different parameter types for each case.</p>
</blockquote>
<blockquote>
<p>An example of ambiguity is:</p>
</blockquote>
<blockquote>
<pre><code>interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
    int size() { return 0; }
    static int size(Object arg) { return 0; }

    void test() {
        Fun&lt;C, Integer&gt; f1 = C::size;
          // Error: instance method size()
          // or static method size(Object)?
    }
}</code></pre>
</blockquote>
<blockquote>
<p>This ambiguity cannot be resolved by providing an applicable instance method which is more specific than an applicable <code>static</code> method:</p>
</blockquote>
<blockquote>
<pre><code>interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
    int size() { return 0; }
    static int size(Object arg) { return 0; }
    int size(C arg) { return 0; }

    void test() {
        Fun&lt;C, Integer&gt; f1 = C::size;
          // Error: instance method size()
          // or static method size(Object)?
    }
}</code></pre>
</blockquote>
<blockquote>
<p>The search is smart enough to ignore ambiguities in which all the applicable methods (from both searches) are instance methods:</p>
</blockquote>
<blockquote>
<pre><code>interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
    int size() { return 0; }
    int size(Object arg) { return 0; }
    int size(C arg) { return 0; }

    void test() {
        Fun&lt;C, Integer&gt; f1 = C::size;
          // OK: reference is to instance method size()
    }
}</code></pre>
</blockquote>
<blockquote>
<p>For convenience, when the name of a generic type is used to refer to an instance method (where the receiver becomes the first parameter), the target type is used to determine the type arguments. This facilitates usage like <code>Pair::first</code> in place of <code>Pair&lt;String,Integer&gt;::first</code>. Similarly, a method reference like <code>Pair::new</code> is treated like a &quot;diamond&quot; instance creation (<code>new Pair&lt;&gt;()</code>). Because the &quot;diamond&quot; is implicit, this form does <em>not</em> instantiate a raw type; in fact, there is no way to express a reference to the constructor of a raw type.</p>
</blockquote>
<p>For some method reference expressions, there is only one possible compile-time declaration with only one possible invocation type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>), regardless of the targeted function type. Such method reference expressions are said to be <em>exact</em>. A method reference expression that is not exact is said to be <em>inexact</em>.</p>
<p>A method reference expression ending with <em>Identifier</em> is exact if it satisfies all of the following:</p>
<ul>
<li><p>If the method reference expression has the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, then <em>ReferenceType</em> does not denote a raw type.</p></li>
<li><p>The type to search has exactly one member method with the name <em>Identifier</em> that is accessible to the class or interface in which the method reference expression appears.</p></li>
<li><p>This method is not variable arity (<a href="#jls-8.4.1">8.4.1</a>).</p></li>
<li><p>If this method is generic (<a href="#jls-8.4.4">8.4.4</a>), then the method reference expression provides <em>TypeArguments</em>.</p></li>
</ul>
<p>A method reference expression of the form <em>ClassType</em> <code>::</code> <em>[TypeArguments]</em> <code>new</code> is exact if it satisfies all of the following:</p>
<ul>
<li><p>The type denoted by <em>ClassType</em> is not raw, or is a non-<code>static</code> member type of a raw type.</p></li>
<li><p>The type denoted by <em>ClassType</em> has exactly one constructor that is accessible to the class or interface in which the method reference expression appears.</p></li>
<li><p>This constructor is not variable arity.</p></li>
<li><p>If this constructor is generic, then the method reference expression provides <em>TypeArguments</em>.</p></li>
</ul>
<p>A method reference expression of the form <em>ArrayType</em> <code>::</code> <code>new</code> is always exact.</p>
<h3 id="jls-15.27">15.27 Lambda Expressions</h3>
<h4 id="jls-15.27.1">15.27.1 Lambda Parameters</h4>
<p>The formal parameters of a lambda expression, if any, are specified by either a parenthesized list of comma-separated parameter specifiers or a parenthesized list of comma-separated identifiers. In a list of parameter specifiers, each parameter specifier consists of optional modifiers, then a type (or <code>var</code>), then an identifier that specifies the name of the parameter. In a list of identifiers, each identifier specifies the name of the parameter.</p>
<p>If a lambda expression has no formal parameters, then an empty pair of parentheses appears before the <code>-&gt;</code> and the lambda body.</p>
<p>If a lambda expression has exactly one formal parameter, and the parameter is specified by an identifier instead of a parameter specifier, then the parentheses around the identifier may be elided.</p>
<dl>
<dt><em>LambdaParameters:</em></dt>
<dd><code>(</code> [<em>LambdaParameterList</em>] <code>)</code>
</dd>
<dd><em>Identifier</em>
</dd>
<dt><em>LambdaParameterList:</em></dt>
<dd><em>LambdaParameter</em> {<code>,</code> <em>LambdaParameter</em>}
</dd>
<dd><em>Identifier</em> {<code>,</code> <em>Identifier</em>}
</dd>
<dt><em>LambdaParameter:</em></dt>
<dd>{<em>VariableModifier</em>} <em>LambdaParameterType</em> <em>VariableDeclaratorId</em>
</dd>
<dd><em>VariableArityParameter</em>
</dd>
<dt><em>LambdaParameterType:</em></dt>
<dd><em>UnannType</em>
</dd>
<dd><code>var</code>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3">8.3</a>, and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3">4.3</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>VariableArityParameter:</em></dt>
<dd>{<em>VariableModifier</em>} <em>UnannType</em> {<em>Annotation</em>} <code>...</code> <em>Identifier</em>
</dd>
<dt><em>VariableModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
<dd><code>final</code>
</dd>
<dt><em>VariableDeclaratorId:</em></dt>
<dd><em>Identifier</em> [<em>Dims</em>]
</dd>
<dt><em>Dims:</em></dt>
<dd>{<em>Annotation</em>} <code>[</code> <code>]</code> {{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<p>A formal parameter of a lambda expression may be declared <code>final</code>, or annotated, only if specified by a parameter specifier. If a formal parameter is specified by an identifier instead, then the formal parameter is not <code>final</code> and has no annotations.</p>
<p>A formal parameter of a lambda expression may be a <em>variable arity parameter</em>, indicated by an ellipsis following the type in a parameter specifier. At most one variable arity parameter is permitted for a lambda expression. It is a compile-time error if a variable arity parameter appears anywhere in the list of parameter specifiers except the last position.</p>
<p>Each formal parameter of a lambda expression has either an <em>inferred type</em> or a <em>declared type</em>:</p>
<ul>
<li><p>If a formal parameter is specified either by a parameter specifier that uses <code>var</code>, or by an identifier instead of a parameter specifier, then the formal parameter has an inferred type. The type is inferred from the functional interface type targeted by the lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27.3">15.27.3</a>).</p></li>
<li><p>If a formal parameter is specified by a parameter specifier that does not use <code>var</code>, then the formal parameter has a declared type. The declared type is determined as follows:</p>
<ul>
<li><p>If the formal parameter is not a variable arity parameter, then the declared type is denoted by <em>UnannType</em> if no bracket pairs appear in <em>UnannType</em> and <em>VariableDeclaratorId</em>, and specified by <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.2">10.2</a> otherwise.</p></li>
<li><p>If the formal parameter is a variable arity parameter, then the declared type is an array type specified by <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.2">10.2</a>.</p></li>
</ul></li>
</ul>
<blockquote>
<p>No distinction is made between the following lambda parameter lists:</p>
</blockquote>
<blockquote>
<pre><code>(int... x) `-&gt;` BODY
(int[] x) `-&gt;` BODY</code></pre>
</blockquote>
<blockquote>
<p>Either can be used, whether the functional interface's abstract method is fixed arity or variable arity. (This is consistent with the rules for method overriding.) Since lambda expressions are never directly invoked, using <code>int...</code> for the formal parameter where the functional interface uses <code>int[]</code> can have no impact on the surrounding program. In a lambda body, a variable arity parameter is treated just like an array-typed parameter.</p>
</blockquote>
<p>A lambda expression where all the formal parameters have declared types is said to be <em>explicitly typed</em>. A lambda expression where all the formal parameters have inferred types is said to be <em>implicitly typed</em>. A lambda expression with no formal parameters is explicitly typed.</p>
<blockquote>
<p>If a lambda expression is implicitly typed, then its lambda body is interpreted according to the context in which it appears. Specifically, the types of expressions in the body, and the checked exceptions thrown by the body, and the type correctness of code in the body all depend on the types inferred for the formal parameters. This implies that inference of formal parameter types must occur &quot;before&quot; attempting to type-check the lambda body.</p>
</blockquote>
<p>It is a compile-time error if a lambda expression declares a formal parameter with a declared type <em>and</em> a formal parameter with an inferred type.</p>
<blockquote>
<p>This rule prevents a mix of inferred and declared types in the formal parameters, such as <code>(x, int y) -&gt; BODY</code> or <code>(var x, int y) -&gt; BODY</code>. Note that if all the formal parameters have inferred types, the grammar prevents a mix of identifiers and <code>var</code> parameter specifiers, such as <code>(x, var y) -&gt; BODY</code> or <code>(var x, y) -&gt; BODY</code>.</p>
</blockquote>
<p>The rules for annotation modifiers on a formal parameter declaration are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>It is a compile-time error if <code>final</code> appears more than once as a modifier for a formal parameter declaration.</p>
<p>It is a compile-time error if the <em>LambdaParameterType</em> of a formal parameter is <code>var</code> and the <em>VariableDeclaratorId</em> of the same formal parameter has one or more bracket pairs.</p>
<p>The scope and shadowing of a formal parameter declaration is specified in <a href="#jls-6.3">6.3</a> and <a href="#jls-6.4">6.4</a>.</p>
<p><strong>References to a formal parameter from a nested class or a nested lambda expression are restricted, as specified in <a href="#jls-6.5.6.1">6.5.6.1</a>.</strong></p>
<p>It is a compile-time error for a lambda expression to declare two formal parameters with the same name. (That is, their declarations mention the same <em>Identifier</em>.)</p>
<blockquote>
<p>In Java SE 8, the use of <code>_</code> as the name of a lambda parameter was forbidden, and its use discouraged as the name for other kinds of variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.3">4.12.3</a>). As of Java SE 9, <code>_</code> is a keyword (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.9">3.9</a>) so it cannot be used as a variable name in any context.</p>
</blockquote>
<p>It is a compile-time error if a formal parameter that is declared <code>final</code> is assigned to within the body of the lambda expression.</p>
<p>When the lambda expression is invoked (via a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>)), the values of the actual argument expressions initialize newly created parameter variables, each of the declared or inferred type, before execution of the lambda body. The <em>Identifier</em> that appears in the <em>LambdaParameter</em> or directly in the <em>LambdaParameterList</em> or <em>LambdaParameters</em> may be used as a simple name in the lambda body to refer to the formal parameter.</p>
<p>A lambda expression's formal parameter of type <code>float</code> always contains an element of the float value set (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.2.3">4.2.3</a>); similarly, a lambda expression's formal parameter of type <code>double</code> always contains an element of the double value set. It is not permitted for a lambda expression's formal parameter of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a lambda expression's formal parameter of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.</p>
<h4 id="jls-15.27.2">15.27.2 Lambda Body</h4>
<p>A lambda body is either a single expression or a block (<a href="#jls-14.2">14.2</a>). Like a method body, a lambda body describes code that will be executed whenever an invocation occurs.</p>
<dl>
<dt><em>LambdaBody:</em></dt>
<dd><em>Expression</em>
</dd>
<dd><em>Block</em>
</dd>
</dl>
<p>Unlike code appearing in anonymous class declarations, the meaning of names and the <code>this</code> and <code>super</code> keywords appearing in a lambda body, along with the accessibility of referenced declarations, are the same as in the surrounding context (except that lambda parameters introduce new names).</p>
<blockquote>
<p>The transparency of <code>this</code> (both explicit and implicit) in the body of a lambda expression - that is, treating it the same as in the surrounding context - allows more flexibility for implementations, and prevents the meaning of unqualified names in the body from being dependent on overload resolution.</p>
</blockquote>
<blockquote>
<p>Practically speaking, it is unusual for a lambda expression to need to talk about itself (either to call itself recursively or to invoke its other methods), while it is more common to want to use names to refer to things in the enclosing class that would otherwise be shadowed (<code>this</code>, <code>toString()</code>). If it is necessary for a lambda expression to refer to itself (as if via <code>this</code>), a method reference or an anonymous inner class should be used instead.</p>
</blockquote>
<p>A block lambda body is <em>void-compatible</em> if every return statement in the block has the form <code>return;</code>.</p>
<p>A block lambda body is <em>value-compatible</em> if it cannot complete normally (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.21">14.21</a>) and every return statement in the block has the form <code>return</code> <em>Expression</em><code>;</code>.</p>
<p>It is a compile-time error if a block lambda body is neither void-compatible nor value-compatible.</p>
<p>In a value-compatible block lambda body, the <em>result expressions</em> are any expressions that may produce an invocation's value. Specifically, for each statement of the form <code>return</code> <em>Expression</em> <code>;</code> contained by the body, the <em>Expression</em> is a result expression.</p>
<blockquote>
<p>The following lambda bodies are void-compatible:</p>
<pre><code>() `-&gt;` {}
() `-&gt;` { System.out.println(&quot;done&quot;); }</code></pre>
<p>These are value-compatible:</p>
<pre><code>() `-&gt;` { return &quot;done&quot;; }
() `-&gt;` { if (...) return 1; else return 0; }</code></pre>
<p>These are both:</p>
<pre><code>() `-&gt;` { throw new RuntimeException(); }
() `-&gt;` { while (true); }</code></pre>
<p>This is neither:</p>
<pre><code>() `-&gt;` { if (...) return &quot;done&quot;; System.out.println(&quot;done&quot;); }</code></pre>
</blockquote>
<blockquote>
<p>The handling of void/value-compatible and the meaning of names in the body jointly serve to minimize the dependency on a particular target type in the given context, which is useful both for implementations and for programmer comprehension. While expressions can be assigned different types during overload resolution depending on the target type, the meaning of unqualified names and the basic structure of the lambda body do not change.</p>
</blockquote>
<blockquote>
<p>Note that the void/value-compatible definition is not a strictly structural property: &quot;can complete normally&quot; depends on the values of constant expressions, and these may include names that reference constant variables.</p>
</blockquote>
<div class="deleted">
<p>Any local variable, formal parameter, or exception parameter used but not declared in a lambda expression must either be declared <code>final</code> or be effectively final (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>), or a compile-time error occurs where the use is attempted.</p>
<p>Any local variable used but not declared in a lambda body must be definitely assigned (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-16.html">16</a>) before the lambda body, or a compile-time error occurs.</p>
<blockquote>
<p>Similar rules on variable use apply in the body of an inner class (<a href="#jls-8.1.3">8.1.3</a>). The restriction to effectively final variables prohibits access to dynamically-changing local variables, whose capture would likely introduce concurrency problems. Compared to the <code>final</code> restriction, it reduces the clerical burden on programmers.</p>
</blockquote>
<blockquote>
<p>The restriction to effectively final variables includes standard loop variables, but not enhanced-<code>for</code> loop variables, which are treated as distinct for each iteration of the loop (<a href="#jls-14.14.2">14.14.2</a>).</p>
</blockquote>
<blockquote>
<p>The following lambda bodies demonstrate use of effectively final variables.</p>
<pre><code>void m1(int x) {
    int y = 1;
    foo(() -&gt; x+y);
    // Legal: x and y are both effectively final.
}

void m2(int x) {
    int y;
    y = 1;
    foo(() -&gt; x+y);
    // Legal: x and y are both effectively final.
}

void m3(int x) {
    int y;
    if (...) y = 1;
    foo(() -&gt; x+y);
    // Illegal: y is effectively final, but not definitely assigned.
}

void m4(int x) {
    int y;
    if (...) y = 1; else y = 2;
    foo(() -&gt; x+y);
    // Legal: x and y are both effectively final.
}</code></pre>
<pre><code>void m5(int x) {
    int y;
    if (...) y = 1;
    y = 2;
    foo(() -&gt; x+y);
    // Illegal: y is not effectively final.
}

void m6(int x) {
    foo(() -&gt; x+1);
    x++;
    // Illegal: x is not effectively final.
}

void m7(int x) {
    foo(() -&gt; x=1);
    // Illegal: x is not effectively final.
}

void m8() {
    int y;
    foo(() -&gt; y=1);
    // Illegal: y is not definitely assigned before the lambda.
}

void m9(String[] arr) {
    for (String s : arr) {
        foo(() -&gt; s);
        // Legal: s is effectively final
        // (it is a new variable on each iteration)
    }
}

void m10(String[] arr) {
    for (int i = 0; i &lt; arr.length; i++) {
        foo(() -&gt; arr[i]);
        // Illegal: i is not effectively final
        // (it is not final, and is incremented)
    }
}</code></pre>
</blockquote>
</div>
<div class="editorial">
<p>Some of this may be useful to move to <a href="#jls-6.5.6.1">6.5.6.1</a>.</p>
</div>
<h2 id="jls-16">Chapter 16: Definite Assignment</h2>
<h3 id="jls-16.2">16.2 Definite Assignment and Statements</h3>
<h4 id="jls-16.2.3">16.2.3 Local Class <del>Declaration Statements</del> <strong>and Interface Declarations</strong></h4>
<ul>
<li><em>V</em> is [un]assigned after a local class <strong>or interface</strong> declaration <del>statement</del> (<a href="#jls-14.3">14.3</a>) iff <em>V</em> is [un]assigned before the local class <strong>or interface</strong> declaration <del>statement</del>.</li>
</ul>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2021, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java16.0.1speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 16.0.1+9-24 --></footer>
</body>
</html>