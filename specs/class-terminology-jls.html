<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Consistent Class and Interface Terminology</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../resources/spec-changes.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Consistent Class and Interface Terminology</h1>
<p class="subtitle">Changes to the Java® Language Specification • Version 16.0.1+9-24</p>
</header>
<nav id="TOC" title="Table Of Contents">
<ul>
<li><a href="#jls-1">Chapter 1: Introduction</a><ul>
<li><a href="#jls-1.1">1.1 Organization of the Specification</a></li>
</ul></li>
<li><a href="#jls-2">Chapter 2: Grammars</a><ul>
<li><a href="#jls-2.4">2.4 Grammar Notation</a></li>
</ul></li>
<li><a href="#jls-4">Chapter 4: Types, Values, and Variables</a><ul>
<li><a href="#jls-4.5">4.5 Parameterized Types</a><ul>
<li><a href="#jls-4.5.2">4.5.2 Members and Constructors of Parameterized Types</a></li>
</ul></li>
<li><a href="#jls-4.8">4.8 Raw Types</a></li>
<li><a href="#jls-4.9">4.9 Intersection Types</a></li>
<li><a href="#jls-4.10">4.10 Subtyping</a><ul>
<li><a href="#jls-4.10.2">4.10.2 Subtyping among Class and Interface Types</a></li>
</ul></li>
<li><a href="#jls-4.11">4.11 Where Types Are Used</a></li>
</ul></li>
<li><a href="#jls-6">Chapter 6: Names</a><ul>
<li><a href="#jls-6.1">6.1 Declarations</a></li>
<li><a href="#jls-6.2">6.2 Names and Identifiers</a></li>
<li><a href="#jls-6.3">6.3 Scope of a Declaration</a></li>
<li><a href="#jls-6.5">6.5 Determining the Meaning of a Name</a><ul>
<li><a href="#jls-6.5.1">6.5.1 Syntactic Classification of a Name According to Context</a></li>
<li><a href="#jls-6.5.4">6.5.4 Meaning of <em>PackageOrTypeNames</em></a><ul>
<li><a href="#jls-6.5.4.1">6.5.4.1 Simple <em>PackageOrTypeNames</em></a></li>
<li><a href="#jls-6.5.4.2">6.5.4.2 Qualified <em>PackageOrTypeNames</em></a></li>
</ul></li>
<li><a href="#jls-6.5.5">6.5.5 Meaning of Type Names</a><ul>
<li><a href="#jls-6.5.5.1">6.5.5.1 Simple Type Names</a></li>
<li><a href="#jls-6.5.5.2">6.5.5.2 Qualified Type Names</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-6.6">6.6 Access Control</a></li>
</ul></li>
<li><a href="#jls-7">Chapter 7: Packages and Modules</a><ul>
<li><a href="#jls-7.3">7.3 Compilation Units</a></li>
<li><a href="#jls-7.5">7.5 Import Declarations</a><ul>
<li><a href="#jls-7.5.1">7.5.1 Single-Type-Import Declarations</a></li>
<li><a href="#jls-7.5.2">7.5.2 Type-Import-on-Demand Declarations</a></li>
<li><a href="#jls-7.5.3">7.5.3 Single-Static-Import Declarations</a></li>
<li><a href="#jls-7.5.4">7.5.4 Static-Import-on-Demand Declarations</a></li>
</ul></li>
<li><a href="#jls-7.6">7.6 Top Level <del>Type</del> <strong>Class and Interface</strong> Declarations</a></li>
<li><a href="#jls-7.7">7.7 Module Declarations</a><ul>
<li><a href="#jls-7.7.3">7.7.3 Service Consumption</a></li>
<li><a href="#jls-7.7.4">7.7.4 Service Provision</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-8">Chapter 8: Classes</a><ul>
<li><a href="#jls-8.1">8.1 Class Declarations</a><ul>
<li><a href="#jls-8.1.1">8.1.1 Class Modifiers</a><ul>
<li><a href="#jls-8.1.1.3">8.1.1.3 <code>strictfp</code> Classes</a></li>
</ul></li>
<li><a href="#jls-8.1.3">8.1.3 Inner Classes and Enclosing Instances</a></li>
<li><a href="#jls-8.1.4">8.1.4 Superclasses <del>and Subclasses</del></a></li>
<li><a href="#jls-8.1.5">8.1.5 Superinterfaces</a></li>
<li><a href="#jls-8.1.6">8.1.6 Class Body and Member Declarations</a></li>
</ul></li>
<li><a href="#jls-8.2">8.2 Class Members</a></li>
<li><a href="#jls-8.3">8.3 Field Declarations</a></li>
<li><a href="#jls-8.4">8.4 Method Declarations</a><ul>
<li><a href="#jls-8.4.8">8.4.8 Inheritance, Overriding, and Hiding</a><ul>
<li><a href="#jls-8.4.8.1">8.4.8.1 Overriding (by Instance Methods)</a></li>
<li><a href="#jls-8.4.8.2">8.4.8.2 Hiding (by Class Methods)</a></li>
<li><a href="#jls-8.4.8.3">8.4.8.3 Requirements in Overriding and Hiding</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-8.5">8.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</a><ul>
<li><a href="#jls-8.5.1">8.5.1 Static Member <del>Type</del> <strong>Class and Interface</strong> Declarations</a></li>
</ul></li>
<li><a href="#jls-8.8">8.8 Constructor Declarations</a><ul>
<li><a href="#jls-8.8.7">8.8.7 Constructor Body</a><ul>
<li><a href="#jls-8.8.7.1">8.8.7.1 Explicit Constructor Invocations</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-8.9">8.9 Enum <del>Types</del> <strong>Classes</strong></a><ul>
<li><a href="#jls-8.9.1">8.9.1 Enum Constants</a></li>
<li><a href="#jls-8.9.2">8.9.2 Enum Body Declarations</a></li>
<li><a href="#jls-8.9.3">8.9.3 Enum Members</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-9">Chapter 9: Interfaces</a><ul>
<li><a href="#jls-9.1">9.1 Interface Declarations</a><ul>
<li><a href="#jls-9.1.1">9.1.1 Interface Modifiers</a></li>
<li><a href="#jls-9.1.3">9.1.3 Superinterfaces <del>and Subinterfaces</del></a></li>
<li><a href="#jls-9.1.4">9.1.4 Interface Body and Member Declarations</a></li>
</ul></li>
<li><a href="#jls-9.2">9.2 Interface Members</a></li>
<li><a href="#jls-9.4">9.4 Method Declarations</a><ul>
<li><a href="#jls-9.4.1">9.4.1 Inheritance and Overriding</a><ul>
<li><a href="#jls-9.4.1.1">9.4.1.1 Overriding (by Instance Methods)</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-9.5">9.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</a></li>
<li><a href="#jls-9.6">9.6 Annotation <del>Types</del> <strong>Interfaces</strong></a><ul>
<li><a href="#jls-9.6.1">9.6.1 Annotation <del>Type</del> Elements</a></li>
<li><a href="#jls-9.6.2">9.6.2 Defaults for Annotation <del>Type</del> Elements</a></li>
<li><a href="#jls-9.6.3">9.6.3 Repeatable Annotation <del>Types</del> <strong>Interfaces</strong></a></li>
<li><a href="#jls-9.6.4">9.6.4 Predefined Annotation <del>Types</del> <strong>Interfaces</strong></a><ul>
<li><a href="#jls-9.6.4.1">9.6.4.1 <code>@Target</code></a></li>
<li><a href="#jls-9.6.4.2">9.6.4.2 <code>@Retention</code></a></li>
<li><a href="#jls-9.6.4.3">9.6.4.3 <code>@Inherited</code></a></li>
<li><a href="#jls-9.6.4.4">9.6.4.4 <code>@Override</code></a></li>
<li><a href="#jls-9.6.4.5">9.6.4.5 <code>@SuppressWarnings</code></a></li>
<li><a href="#jls-9.6.4.6">9.6.4.6 <code>@Deprecated</code></a></li>
<li><a href="#jls-9.6.4.7">9.6.4.7 <code>@SafeVarargs</code></a></li>
<li><a href="#jls-9.6.4.8">9.6.4.8 <code>@Repeatable</code></a></li>
<li><a href="#jls-9.6.4.9">9.6.4.9 <code>@FunctionalInterface</code></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-9.7">9.7 Annotations</a><ul>
<li><a href="#jls-9.7.1">9.7.1 Normal Annotations</a></li>
<li><a href="#jls-9.7.2">9.7.2 Marker Annotations</a></li>
<li><a href="#jls-9.7.3">9.7.3 Single-Element Annotations</a></li>
<li><a href="#jls-9.7.4">9.7.4 Where Annotations May Appear</a></li>
<li><a href="#jls-9.7.5">9.7.5 Multiple Annotations of the Same <del>Type</del> <strong>Interface</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-12">Chapter 12: Execution</a><ul>
<li><a href="#jls-12.2">12.2 Loading of Classes and Interfaces</a></li>
<li><a href="#jls-12.3">12.3 Linking of Classes and Interfaces</a><ul>
<li><a href="#jls-12.3.3">12.3.3 Resolution of Symbolic References</a></li>
</ul></li>
<li><a href="#jls-12.5">12.5 Creation of New Class Instances</a></li>
</ul></li>
<li><a href="#jls-13">Chapter 13: Binary Compatibility</a><ul>
<li><a href="#jls-13.1">13.1 The Form of a Binary</a></li>
<li><a href="#jls-13.3">13.3 Evolution of Packages and Modules</a></li>
<li><a href="#jls-13.4">13.4 Evolution of Classes</a><ul>
<li><a href="#jls-13.4.4">13.4.4 Superclasses and Superinterfaces</a></li>
<li><a href="#jls-13.4.8">13.4.8 Field Declarations</a></li>
<li><a href="#jls-13.4.12">13.4.12 Method and Constructor Declarations</a></li>
<li><a href="#jls-13.4.26">13.4.26 Evolution of <del>Enums</del> <strong>Enum Classes</strong></a></li>
</ul></li>
<li><a href="#jls-13.5">13.5 Evolution of Interfaces</a><ul>
<li><a href="#jls-13.5.7">13.5.7 Evolution of Annotation <del>Types</del> <strong>Interfaces</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-15">Chapter 15: Expressions</a><ul>
<li><a href="#jls-15.8">15.8 Primary Expressions</a><ul>
<li><a href="#jls-15.8.2">15.8.2 Class Literals</a></li>
<li><a href="#jls-15.8.3">15.8.3 <code>this</code></a></li>
<li><a href="#jls-15.8.4">15.8.4 Qualified <code>this</code></a></li>
</ul></li>
<li><a href="#jls-15.9">15.9 Class Instance Creation Expressions</a><ul>
<li><a href="#jls-15.9.1">15.9.1 Determining the Class being Instantiated</a></li>
<li><a href="#jls-15.9.2">15.9.2 Determining Enclosing Instances</a></li>
<li><a href="#jls-15.9.3">15.9.3 Choosing the Constructor and its Arguments</a></li>
<li><a href="#jls-15.9.4">15.9.4 Run-Time Evaluation of Class Instance Creation Expressions</a></li>
<li><a href="#jls-15.9.5">15.9.5 Anonymous Class Declarations</a><ul>
<li><a href="#jls-15.9.5.1">15.9.5.1 Anonymous Constructors</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-15.12">15.12 Method Invocation Expressions</a><ul>
<li><a href="#jls-15.12.1">15.12.1 Compile-Time Step 1: Determine <del>Class or Interface</del> <strong>Type</strong> to Search</a></li>
<li><a href="#jls-15.12.2">15.12.2 Compile-Time Step 2: Determine Method Signature</a><ul>
<li><a href="#jls-15.12.2.1">15.12.2.1 Identify Potentially Applicable Methods</a></li>
</ul></li>
<li><a href="#jls-15.12.3">15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?</a><ul>
<li><a href="#jls-15.12.4.3">15.12.4.3 Check Accessibility of Type and Method</a></li>
<li><a href="#jls-15.12.4.4">15.12.4.4 Locate Method to Invoke</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-15.13">15.13 Method Reference Expressions</a></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a href="https://docs.oracle.com/javase/specs/jls/se14/html">Java Language Specification</a> to clarify the usage of terms and taxonomies related to <em>classes</em> and <em>interfaces</em>, and more clearly distinguish classes and interfaces from <em>types</em>.</p>
<p>The following terminology is preferred: a <em>class declaration</em> or an <em>interface declaration</em> is a syntactic structure that introduces a <em>class</em> or an <em>interface</em>, respectively. Various class and interface declarations have different syntactic forms, and can appear in different contexts, per the grammar. An <em>enum declaration</em> introduces a special kind of class, an <em>enum class</em>. An <em>annotation declaration</em> introduces a special kind of interface, an <em>annotation interface</em>.</p>
<p>A <em>class type</em> or an <em>interface type</em> is the type of a variable or an expression, where the type <em>names</em> a class or interface. The word <em>type</em> should be avoided when talking about a class or interface itself, or its declaration. For example, &quot;member type&quot; is not appropriate. (As an exception, we continue to use <em>type name</em> to describe a name that refers to a class, interface, or type parameter.)</p>
<p>Each class has a <em>direct superclass type</em> and <em>direct superinterface types</em>. These can be mapped to a <em>direct superclass</em> and <em>direct superinterfaces</em> when the extra information supplied by types (e.g., type arguments) is irrelevant. Through transitive closure, we can talk more generally about <em>superclass types</em>, <em>superinterface types</em>, <em>superclasses</em>, and <em>superinterfaces</em>.</p>
<p>Changes are described with respect to existing sections of the Java Language Specification. New text is indicated <strong>like this</strong> and deleted text is indicated <del>like this</del>. Explanation and discussion, as needed, is set aside in grey boxes.</p>
<h2 id="jls-1">Chapter 1: Introduction</h2>
<h3 id="jls-1.1">1.1 Organization of the Specification</h3>
<p>Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language.</p>
<p>Chapter 3 describes the lexical structure of the Java programming language, which is based on C and C++. The language is written in the Unicode character set. It supports the writing of Unicode characters on systems that support only ASCII.</p>
<p>Chapter 4 describes types, values, and variables. Types are subdivided into primitive types and reference types.</p>
<p>The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a <code>boolean</code> type, and a Unicode character <code>char</code> type. Values of the primitive types do not share state.</p>
<p>Reference types are the class types, the interface types, and the array types. The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the class <code>Object</code>, which is the (single) root of the class hierarchy. A predefined <code>String</code> class supports Unicode character strings. Classes exist for wrapping primitive values inside of objects. In many cases, wrapping and unwrapping is performed automatically by the compiler (in which case, wrapping is called boxing, and unwrapping is called unboxing). <del>Class and interface declarations</del> <strong>Classes and interfaces</strong> may be generic, that is, they may be parameterized by <del>other</del> reference types. <del>Such declarations</del> <strong>Parameterized types of such classes and interfaces</strong> may then <del>be invoked with</del> <strong>provide</strong> specific type arguments.</p>
<p>Variables are typed storage locations. A variable of a primitive type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object <del>whose type is that class type</del> <strong>that is an instance of the named class</strong> or any subclass of that class <del>type</del>. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the <strong>named</strong> interface. A variable of an array type can hold a null reference or a reference to an array. A variable of class type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array.</p>
<p>Chapter 5 describes conversions and numeric promotions. Conversions change the compile-time type and, sometimes, the value of an expression. These conversions include the boxing and unboxing conversions between primitive types and reference types. Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed. There are no loopholes in the language; casts on reference types are checked at run time to ensure type safety.</p>
<p>Chapter 6 describes declarations and names, and how to determine what names mean (that is, which declaration a name denotes). The Java programming language does not require classes and interfaces, or their members, to be declared before they are used. Declaration order is significant only for local variables, local classes, and the order of field initializers in a class or interface. Recommended naming conventions that make for more readable programs are described here.</p>
<p>Chapter 7 describes the structure of a program, which is organized into packages. The members of a package are classes, interfaces, and subpackages. Packages, and consequently their members, have names in a hierarchical name space; the Internet domain name system can usually be used to form unique package names. Compilation units contain declarations of the classes and interfaces that are members of a given package, and may import classes and interfaces from other packages to give them short names.</p>
<p>Packages may be grouped into modules that serve as building blocks in the construction of very large programs. The declaration of a module specifies which other modules (and thus packages, and thus classes and interfaces) are required in order to compile and run code in its own packages.</p>
<p>The Java programming language supports limitations on external access to the members of packages, classes, and interfaces. The members of a package may be accessible solely by other members in the same package, or by members in other packages of the same module, or by members of packages in different modules. Similar constraints apply to the members of classes and interfaces.</p>
<p>Chapter 8 describes classes. The members of classes are classes, interfaces, fields (variables) and methods. Class variables exist once per class. Class methods operate without reference to a specific object. Instance variables are dynamically created in objects that are instances of classes. Instance methods are invoked on instances of classes; such instances become the current object <code>this</code> during their execution, supporting the object-oriented programming style.</p>
<p>Classes support single inheritance, in which each class has a single superclass. Each class inherits members from its superclass, and ultimately from the class <code>Object</code>. Variables of a class type can reference an instance of <del>that</del> <strong>the named</strong> class or of any subclass of that class, allowing new <del>types</del> <strong>classes</strong> to be used with existing methods, polymorphically.</p>
<p>Classes support concurrent programming with <code>synchronized</code> methods. Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled. Objects can declare a <code>finalize</code> method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.</p>
<p>For simplicity, the language has neither declaration &quot;headers&quot; separate from the implementation of a class nor separate type and class hierarchies.</p>
<p>A special form of classes, <del>enums</del> <strong>enum classes</strong>, support the definition of small sets of values and their manipulation in a type safe manner. Unlike enumerations in other languages, <del>enums</del> <strong>enum constants</strong> are objects and may have their own methods.</p>
<p>Chapter 9 describes interfaces. The members of interfaces are classes, interfaces, constant fields, and methods. Classes that are otherwise unrelated can implement the same interface. A variable of an interface type can contain a reference to any object that implements the interface.</p>
<p>Classes and interfaces support multiple inheritance from interfaces. A class that implements one or more interfaces may inherit instance methods from both its superclass and its superinterfaces.</p>
<p>Annotation <del>types</del> <strong>interfaces</strong> are specialized interfaces used to annotate declarations. Such annotations are not permitted to affect the semantics of programs in the Java programming language in any way. However, they provide useful input to various tools.</p>
<p>Chapter 10 describes arrays. Array accesses include bounds checking. Arrays are dynamically created objects and may be assigned to variables of type <code>Object</code>. The language supports arrays of arrays, rather than multidimensional arrays.</p>
<p>Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms. There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors. The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it. This provides compile-time checking that exception handlers exist, and aids programming in the large. Most user-defined exceptions should be checked exceptions. Invalid operations in the program detected by the Java Virtual Machine result in run-time exceptions, such as <code>NullPointerException</code>. Errors result from failures detected by the Java Virtual Machine, such as <code>OutOfMemoryError</code>. Most simple programs do not try to handle errors.</p>
<p>Chapter 12 describes activities that occur during execution of a program. A program is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized.</p>
<p>After initialization, class methods and class variables may be used. Some classes may be instantiated to create new objects of the class type. Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.</p>
<p>When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded.</p>
<p>Chapter 13 describes binary compatibility, specifying the impact of changes to <del>types</del> <strong>classes and interfaces</strong> on other <del>types</del> <strong>classes and interfaces</strong> that use the changed <del>types</del> <strong>classes and interfaces</strong> but have not been recompiled. These considerations are of interest to developers of <del>types</del> <strong>classes and interfaces</strong> that are to be widely distributed, in a continuing series of versions, often through the Internet. Good program development environments automatically recompile dependent code whenever a <del>type</del> <strong>class or interface</strong> is changed, so most programmers need not be concerned about these details.</p>
<p>Chapter 14 describes blocks and statements, which are based on C and C++. The language has no <code>goto</code> statement, but includes labeled <code>break</code> and <code>continue</code> statements. Unlike C, the Java programming language requires <code>boolean</code> (or <code>Boolean</code>) expressions in control-flow statements, and does not convert types to <code>boolean</code> implicitly (except through unboxing), in the hope of catching more errors at compile time. A <code>synchronized</code> statement provides basic object-level monitor locking. A <code>try</code> statement can include <code>catch</code> and <code>finally</code> clauses to protect against non-local control transfers.</p>
<p>Chapter 15 describes expressions. This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability. Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable.</p>
<p>Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use. While all other variables are automatically initialized to a default value, the Java programming language does not automatically initialize local variables in order to avoid masking programming errors.</p>
<p>Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language. The Java programming language specifies a memory model for shared-memory multiprocessors that supports high-performance implementations.</p>
<p>Chapter 18 describes a variety of type inference algorithms used to test applicability of generic methods and to infer types in a generic method invocation.</p>
<p>Chapter 19 presents a syntactic grammar for the language.</p>
<h2 id="jls-2">Chapter 2: Grammars</h2>
<h3 id="jls-2.4">2.4 Grammar Notation</h3>
<p>...</p>
<p>A very long right-hand side may be continued on a second line by clearly indenting the second line.</p>
<blockquote>
<p>For example, the syntactic grammar contains this production:</p>
<dl>
<dt><em>NormalClassDeclaration:</em></dt>
<dd>{<em>ClassModifier</em>} <code>class</code> <em>TypeIdentifier</em> [<em>TypeParameters</em>]<br />
[<del><em>Superclass</em></del> <strong><em>ClassExtends</em></strong>] [<del><em>Superinterfaces</em></del> <strong><em>ClassImplements</em></strong>] <em>ClassBody</em>
</dd>
</dl>
<p>which defines one right-hand side for the nonterminal <em>NormalClassDeclaration</em>.</p>
</blockquote>
<div class="editorial">
<p>Reflects the changes in <a href="#jls-8.1">8.1</a>.</p>
</div>
<p>...</p>
<h2 id="jls-4">Chapter 4: Types, Values, and Variables</h2>
<h3 id="jls-4.5">4.5 Parameterized Types</h3>
<p>A class or interface <del>declaration</del> that is generic (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>) defines a set of <em>parameterized types</em>.</p>
<p>A parameterized type is a class or interface type of the form <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code>, where <em>C</em> is the name of a generic <del>type</del> <strong>class or interface</strong> and <code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> is a list of type arguments that denote a particular <em>parameterization</em> of the generic <del>type</del> <strong>class or interface</strong>.</p>
<p>A generic <del>type</del> <strong>class or interface</strong> has type parameters <em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em> with corresponding bounds <em>B<sub>1</sub></em>,...,<em>B<sub>n</sub></em>. Each type argument <em>T<sub>i</sub></em> of a parameterized type ranges over all types that are subtypes of all types listed in the corresponding bound. That is, for each bound type <em>S</em> in <em>B<sub>i</sub></em>, <em>T<sub>i</sub></em> is a subtype of <em>S</em><code>[F1:=T1,...,Fn:=Tn]</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10">4.10</a>).</p>
<p>A parameterized type <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> is <em>well-formed</em> if all of the following are true:</p>
<ul>
<li><p><em>C</em> is the name of a generic <del>type</del> <strong>class or interface</strong>.</p></li>
<li><p>The number of type arguments is the same as the number of type parameters in the generic declaration of <em>C</em>.</p></li>
<li><p>When subjected to capture conversion (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>) resulting in the type <em>C</em><code>&lt;</code><em>X<sub>1</sub></em>,...,<em>X<sub>n</sub></em><code>&gt;</code>, each type argument <em>X<sub>i</sub></em> is a subtype of <em>S</em><code>[F1:=X1,...,Fn:=Xn]</code> for each bound type <em>S</em> in <em>B<sub>i</sub></em>.</p></li>
</ul>
<p>It is a compile-time error if a parameterized type is not well-formed.</p>
<p>In this specification, whenever we speak of a class or interface type, we include <del>the generic version</del> <strong>parameterized types</strong> as well, unless explicitly excluded.</p>
<p>Two parameterized types are <em>provably distinct</em> if either of the following is true:</p>
<ul>
<li><p>They are parameterizations of distinct generic type declarations.</p></li>
<li><p>Any of their type arguments are provably distinct.</p></li>
</ul>
<blockquote>
<p>Given the generic <del>types</del> <strong>classes</strong> in the examples of <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, here are some well-formed parameterized types:</p>
<ul>
<li><code>Seq&lt;String&gt;</code></li>
<li><code>Seq&lt;Seq&lt;String&gt;&gt;</code></li>
<li><code>Seq&lt;String&gt;.Zipper&lt;Integer&gt;</code></li>
<li><code>Pair&lt;String,Integer&gt;</code></li>
</ul>
<p>Here are some incorrect parameterizations of those generic <del>types</del> <strong>classes</strong>:</p>
<ul>
<li><p><code>Seq&lt;int&gt;</code> is illegal, as primitive types cannot be type arguments.</p></li>
<li><p><code>Pair&lt;String&gt;</code> is illegal, as there are not enough type arguments.</p></li>
<li><p><code>Pair&lt;String,String,String&gt;</code> is illegal, as there are too many type arguments.</p></li>
</ul>
</blockquote>
<blockquote>
<p>A parameterized type may be <del>an</del> <strong>a</strong> parameterization of a generic class or interface which is nested. For example, if a non-generic class <em>C</em> has a generic member class <em>D</em> <strong>with type parameters</strong> <code>&lt;</code><em>T</em><code>&gt;</code>, then <em>C</em><code>.</code><em>D</em><code>&lt;Object&gt;</code> is a parameterized type. And if a generic class <em>C</em> <strong>with type parameters</strong> <code>&lt;</code><em>T</em><code>&gt;</code> has a non-generic member class <em>D</em>, then the member <strong>class</strong> type <em>C</em><code>&lt;String&gt;.</code><em>D</em> is a parameterized type, even though the class <em>D</em> is not generic.</p>
</blockquote>
<h4 id="jls-4.5.2">4.5.2 Members and Constructors of Parameterized Types</h4>
<p>Let <em>C</em> be a generic class or interface <del>declaration</del> with type parameters <em>A<sub>1</sub></em>,...,<em>A<sub>n</sub></em>, and let <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> be a parameterization of <em>C</em> where, for 1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>, <em>T<sub>i</sub></em> is a type (rather than a wildcard). Then:</p>
<ul>
<li><p>Let <em>m</em> be a member or constructor declaration in <em>C</em>, whose type as declared is <em>T</em> (<a href="#jls-8.2">8.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.6">8.8.6</a>).</p>
<p>The type of <em>m</em> in <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> is <em>T</em><code>[A1:=T1,...,An:=Tn]</code>.</p></li>
<li><p>Let <em>m</em> be a member or constructor declaration in <em>D</em>, where <em>D</em> is a class extended by <em>C</em> or an interface implemented by <em>C</em>. Let <em>D</em><code>&lt;</code><em>U<sub>1</sub></em>,...,<em>U<sub>k</sub></em><code>&gt;</code> be the supertype <strong>(<a href="#jls-4.10.2">4.10.2</a>)</strong> of <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> that corresponds to <em>D</em>.</p>
<p>The type of <em>m</em> in <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> is the type of <em>m</em> in <em>D</em><code>&lt;</code><em>U<sub>1</sub></em>,...,<em>U<sub>k</sub></em><code>&gt;</code>.</p></li>
</ul>
<p>If any of the type arguments in the parameterization of <em>C</em> are wildcards, then:</p>
<ul>
<li><p>The types of the fields, methods, and constructors in <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> are the types of the fields, methods, and constructors in the capture conversion of <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>).</p></li>
<li><p>Let <em>D</em> be a (possibly generic) class or interface declaration in <em>C</em>. Then the type of <em>D</em> in <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code> is <em>D</em> where, if <em>D</em> is generic, all type arguments are unbounded wildcards.</p></li>
</ul>
<blockquote>
<p>This is of no consequence, as it is impossible to access a member of a parameterized type without performing capture conversion, and it is impossible to use a wildcard after the keyword <code>new</code> in a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>).</p>
</blockquote>
<blockquote>
<p>The sole exception to the previous paragraph is when a nested parameterized type is used as the expression in an <code>instanceof</code> operator (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.20.2">15.20.2</a>), where capture conversion is not applied.</p>
</blockquote>
<p>A <code>static</code> member that is declared in a generic <del>type declaration</del> <strong>class or interface</strong> must be referred to using the <del>non-generic type that corresponds to the generic type</del> <strong>name of the generic class or interface</strong> (<a href="#jls-6.1">6.1</a>, <a href="#jls-6.5.5.2">6.5.5.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.6.2">6.5.6.2</a>), or a compile-time error occurs.</p>
<blockquote>
<p>In other words, it is illegal to refer to a <code>static</code> member declared in a generic type declaration by using a parameterized type.</p>
</blockquote>
<h3 id="jls-4.8">4.8 Raw Types</h3>
<p>To facilitate interfacing with non-generic legacy code, it is possible to use as a type the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of a parameterized type (<a href="#jls-4.5">4.5</a>) or the erasure of an array type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.1">10.1</a>) whose element type is a parameterized type. Such a type is called a <em>raw type</em>.</p>
<p>More precisely, a raw type is defined to be one of:</p>
<ul>
<li><p>The reference type that is formed by taking the name of a generic <del>type</del> <strong>class or interface</strong> declaration without an accompanying type argument list.</p></li>
<li><p>An array type whose element type is a raw type.</p></li>
<li><p><del>A non-<code>static</code> member type</del> <strong>The name of an inner member class</strong> of a raw type <em>R</em> that is not inherited from a superclass or superinterface of <em>R</em>.</p></li>
</ul>
<p><del>A</del> <strong>The type of a</strong> non-generic class or interface <del>type</del> is not a raw type.</p>
<blockquote>
<p>To see why <del>a non-<code>static</code> type member</del> <strong>the name of an inner member class</strong> of a raw type is considered raw, consider the following example:</p>
<pre><code>class Outer&lt;T&gt;{
    T t;
    class Inner {
        T setOuterT(T t1) { t = t1; return t; }
    }
}</code></pre>
<p>The type of the member(s) of <code>Inner</code> depends on the type parameter of <code>Outer</code>. If <code>Outer</code> is raw, <code>Inner</code> must be treated as raw as well, as there is no valid binding for <code>T</code>.</p>
<p>This rule applies only to <del>type members</del> <strong>inner member classes</strong> that are not inherited. Inherited <del>type members</del> <strong>inner member classes</strong> that depend on type variables will be inherited as raw types as a consequence of the rule that the supertypes of a raw type are erased, described later in this section.</p>
<p>Another implication of the rules above is that a generic inner class of a raw type can itself only be used as a raw type:</p>
<pre><code>class Outer&lt;T&gt;{
    class Inner&lt;S&gt; {
        S s;
    }
}</code></pre>
<p>It is not possible to access <code>Inner</code> as a partially raw type (a &quot;rare&quot; type):</p>
<pre><code>Outer.Inner&lt;Double&gt; x = null;  // illegal
Double d = x.s;</code></pre>
<p>because <code>Outer</code> itself is raw, hence so are all its inner classes including <code>Inner</code>, and so it is not possible to pass any type arguments to Inner.</p>
</blockquote>
<p>The <del>superclasses</del> <strong>superclass types</strong> (respectively, <del>superinterfaces</del> <strong>superinterface types</strong>) of a raw type are the erasures of the <del>superclasses</del> <strong>superclass types</strong> (<del>superinterfaces</del> <strong>superinterface types</strong>) of <del>any of the parameterizations of the generic type</del> <strong>the named class or interface</strong>.</p>
<p>The type of a constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>), instance method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>), or non-<code>static</code> field (<a href="#jls-8.3">8.3</a>) of a raw type <em>C</em> that is not inherited from its superclasses or superinterfaces is the erasure of its type in the generic <del>declaration corresponding to</del> <strong>class or interface</strong> <em>C</em>.</p>
<p><strong>The type of an inherited instance method or non-<code>static</code> field of a raw type <em>C</em>, where the member was declared in a class or interface <em>D</em>, is the type of the member in the supertype of <em>C</em> that names <em>D</em>.</strong></p>
<div class="editorial">
<p>Class inheritance is defined in <a href="#jls-8.4.8">8.4.8</a>, but we still need to explain the types of inherited members when accessed via a raw type. Simply saying that the supertypes of the raw type are erased isn't enough.</p>
</div>
<p>The type of a <code>static</code> method or <code>static</code> field of a raw type <em>C</em> is the same as its type in the generic <del>declaration corresponding to</del> <strong>class or interface</strong> <em>C</em>.</p>
<p>It is a compile-time error to pass type arguments to a non-<code>static</code> <del>type</del> member <strong>class or interface</strong> of a raw type that is not inherited from its superclasses or superinterfaces.</p>
<p>It is a compile-time error to attempt to use a <del>type</del> member <strong>class or interface</strong> of a parameterized type as a raw type.</p>
<blockquote>
<p>This means that the ban on &quot;rare&quot; types extends to the case where the qualifying type is parameterized, but we attempt to use the inner class as a raw type:</p>
<pre><code>Outer&lt;Integer&gt;.Inner x = null; // illegal</code></pre>
<p>This is the opposite of the case discussed above. There is no practical justification for this half-baked type. In legacy code, no type arguments are used. In non-legacy code, we should use the generic types correctly and pass all the required type arguments.</p>
</blockquote>
<div class="deleted">
<p>The supertype of a class may be a raw type. Member accesses for the class are treated as normal, and member accesses for the supertype are treated as for raw types. In the constructor of the class, calls to <code>super</code> are treated as method calls on a raw type.</p>
</div>
<div class="editorial">
<p>This is covered in the treatment of superclasses and inheritance elsewhere—see, e.g., <a href="#jls-8.1.4">8.1.4</a>, <a href="#jls-8.3">8.3</a>, and <a href="#jls-8.4.8">8.4.8</a>.</p>
</div>
<p>The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of generics into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.</p>
<p>To make sure that potential violations of the typing rules are always flagged, some accesses to members of a raw type will result in compile-time unchecked warnings. The rules for compile-time unchecked warnings when accessing members or constructors of raw types are as follows:</p>
<ul>
<li><p>At an assignment to a field: if the type of the <em>Primary</em> in the field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11">15.11</a>) is a raw type, then a compile-time unchecked warning occurs if erasure changes the field's type.</p></li>
<li><p>At an invocation of a method or constructor: if the type of the class or interface to search (<a href="#jls-15.12.1">15.12.1</a>) is a raw type, then a compile-time unchecked warning occurs if erasure changes any of the formal parameter types of the method or constructor.</p></li>
<li><p>No compile-time unchecked warning occurs for a method call when the formal parameter types do not change under erasure (even if the return type and/or <code>throws</code> clause changes), for reading from a field, or for a class instance creation of a raw type.</p></li>
</ul>
<p>...</p>
<h3 id="jls-4.9">4.9 Intersection Types</h3>
<p>An intersection type takes the form <em>T<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>T<sub>n</sub></em> (<em>n</em> &gt; 0), where <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) are types.</p>
<p>Intersection types can be derived from type parameter bounds (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>) and cast expressions (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.16">15.16</a>); they also arise in the processes of capture conversion (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>) and least upper bound computation (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10.4">4.10.4</a>).</p>
<p>The values of an intersection type are those objects that are values of all of the types <em>T<sub>i</sub></em> for 1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>.</p>
<p>Every intersection type <em>T<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>T<sub>n</sub></em> <em>induces</em> a notional class or interface for the purpose of identifying the members of the intersection type, as follows:</p>
<ul>
<li><p>For each <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>), let <em>C<sub>i</sub></em> be the most specific class or array type such that <em>T<sub>i</sub></em> <code>&lt;:</code> <em>C<sub>i</sub></em>. Then there must be some <em>C<sub>k</sub></em> such that <em>C<sub>k</sub></em> <code>&lt;:</code> <em>C<sub>i</sub></em> for any <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>), or a compile-time error occurs.</p></li>
<li><p>For 1 <em>≤</em> <em>j</em> <em>≤</em> <em>n</em>, if <em>T<sub>j</sub></em> is a type variable, then let <em>T<sub>j</sub></em>' be an interface whose members are the same as the <code>public</code> members of <em>T<sub>j</sub></em>; otherwise, if <em>T<sub>j</sub></em> is an interface, then let <em>T<sub>j</sub></em>' be <em>T<sub>j</sub></em>.</p></li>
<li><p>If <em>C<sub>k</sub></em> is <code>Object</code>, a notional interface is induced; otherwise, a notional class is induced with direct superclass <strong>type</strong> <em>C<sub>k</sub></em>. This class or interface has direct <del>superinterfaces</del> <strong>superinterface types</strong> <em>T<sub>1</sub></em>', ..., <em>T<sub>n</sub></em>' and is declared in the package in which the intersection type appears.</p></li>
</ul>
<p>The members of an intersection type are the members of the class or interface it induces.</p>
<blockquote>
<p>It is worth dwelling upon the distinction between intersection types and the bounds of type variables. Every type variable bound induces an intersection type. This intersection type is often trivial, consisting of a single type. The form of a bound is restricted (only the first element may be a class or type variable, and only one type variable may appear in the bound) to preclude certain awkward situations coming into existence. However, capture conversion can lead to the creation of type variables whose bounds are more general, such as array types).</p>
</blockquote>
<h3 id="jls-4.10">4.10 Subtyping</h3>
<h4 id="jls-4.10.2">4.10.2 Subtyping among Class and Interface Types</h4>
<p>Given a non-generic <del>type declaration</del> <strong>class or interface</strong> <em>C</em>, the <em>direct supertypes</em> of the type <strong>of</strong> <em>C</em> are all of the following:</p>
<ul>
<li><p>The direct superclass <strong>type</strong> of <em>C</em> (<a href="#jls-8.1.4">8.1.4</a>)<strong>, if <em>C</em> is a class</strong>.</p></li>
<li><p>The direct <del>superinterfaces</del> <strong>superinterface types</strong> of <em>C</em> (<a href="#jls-8.1.5">8.1.5</a><strong>, <a href="#jls-9.1.3">9.1.3</a></strong>).</p></li>
<li><p>The type <code>Object</code>, if <em>C</em> is an interface <del>type</del> with no direct <del>superinterfaces</del> <strong>superinterface types</strong> (<a href="#jls-9.1.3">9.1.3</a>).</p></li>
</ul>
<p>Given a generic <del>type declaration</del> <strong>class or interface</strong> <em>C</em> <strong>with type parameters</strong> <code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct supertypes</em> of the raw type <em>C</em> (<a href="#jls-4.8">4.8</a>) are all of the following:</p>
<ul>
<li><p>The <strong>erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of the</strong> direct superclass <strong>type</strong> of <del>the raw type</del> <em>C</em><strong>, if <em>C</em> is a class</strong>.</p></li>
<li><p>The <strong>erasure of the</strong> direct <del>superinterfaces</del> <strong>superinterface types</strong> of <del>the raw type</del> <em>C</em>.</p></li>
<li><p>The type <code>Object</code>, if <em>C</em><del><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code></del> is <del>a generic interface type</del> <strong>an interface</strong> with no direct <del>superinterfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>)</del> <strong>superinterface types</strong>.</p></li>
</ul>
<div class="deleted">
<p>Given a generic type declaration <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct supertypes</em> of the generic type <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> are all of the following:</p>
<ul>
<li><p>The direct superclass of <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code>.</p></li>
<li><p>The direct superinterfaces of <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code>.</p></li>
<li><p>The type <code>Object</code>, if <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> is a generic interface type with no direct superinterfaces.</p></li>
<li><p>The raw type <em>C</em>.</p></li>
</ul>
</div>
<div class="editorial">
<p>A <em>generic type</em> is not a distinct kind of type. The <em>generic class</em> has supertypes, as described in <a href="#jls-8.1.4">8.1.4</a> and <a href="#jls-8.1.5">8.1.5</a>. A <em>parameterized type</em> has supertypes, as described below.</p>
</div>
<p>Given a generic <del>type declaration</del> <strong>class or interface</strong> <em>C</em> <strong>with type parameters</strong> <code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct supertypes</em> of the parameterized type <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code>, where <strong>each of</strong> <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) is a type, are all of the following:</p>
<ul>
<li><p><del><em>D</em><code>&lt;</code><em>U<sub>1</sub></em> <em>θ</em>,...,<em>U<sub>k</sub></em> <em>θ</em><code>&gt;</code>, where <em>D</em><code>&lt;</code><em>U<sub>1</sub></em>,...,<em>U<sub>k</sub></em><code>&gt;</code> is a generic type which is a direct supertype of the generic type <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> and <em>θ</em> is the substitution <code>[F1:=T1,...,Fn:=Tn]</code>.</del></p></li>
<li><p><strong>The substitution <code>[F1:=T1,...,Fn:=Tn]</code> applied to the direct superclass type of <em>C</em>, if <em>C</em> is a class.</strong></p></li>
<li><p><strong>The substitution <code>[F1:=T1,...,Fn:=Tn]</code> applied to the direct superinterface types of <em>C</em>.</strong></p></li>
<li><p><em>C</em><code>&lt;</code><em>S<sub>1</sub></em>,...,<em>S<sub>n</sub></em><code>&gt;</code>, where <em>S<sub>i</sub></em> contains <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a>).</p></li>
<li><p>The type <code>Object</code>, if <em>C</em><del>&lt;<em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em>&gt;</del> is <del>a generic interface type</del> <strong>an interface</strong> with no direct <del>superinterfaces</del> <strong>superinterface types</strong>.</p></li>
<li><p>The raw type <em>C</em>.</p></li>
</ul>
<p>Given a generic <del>type declaration</del> <strong>class or interface</strong> <em>C</em> <strong>with type parameters</strong> <code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct supertypes</em> of the parameterized type <em>C</em><code>&lt;</code><em>R<sub>1</sub></em>,...,<em>R<sub>n</sub></em><code>&gt;</code> where at least one of the <em>R<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) is a wildcard type argument, are the direct supertypes of the parameterized type <em>C</em><code>&lt;</code><em>X<sub>1</sub></em>,...,<em>X<sub>n</sub></em><code>&gt;</code> which is the result of applying capture conversion to <em>C</em><code>&lt;</code><em>R<sub>1</sub></em>,...,<em>R<sub>n</sub></em><code>&gt;</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">5.1.10</a>).</p>
<p>The direct supertypes of an intersection type <em>T<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>T<sub>n</sub></em> are <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>).</p>
<p>The direct supertypes of a type variable are the types listed in its bound.</p>
<p>A type variable is a direct supertype of its lower bound.</p>
<p>The direct supertypes of the null type are all reference types other than the null type itself.</p>
<h3 id="jls-4.11">4.11 Where Types Are Used</h3>
<p>Types are used in most kinds of declaration and in certain kinds of expression. Specifically, there are 16 <em>type contexts</em> where types are used:</p>
<ul>
<li><p>In declarations:</p>
<ol type="1">
<li><p>A type in the <code>extends</code> or <code>implements</code> clause of a class declaration (<a href="#jls-8.1.4">8.1.4</a>, <a href="#jls-8.1.5">8.1.5</a>, <a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>)</p></li>
<li><p>A type in the <code>extends</code> clause of an interface declaration (<a href="#jls-9.1.3">9.1.3</a>, <a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>)</p></li>
<li><p>The return type of a method (including the type of an element of an annotation <del>type</del> <strong>interface</strong>) (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.5">8.4.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="#jls-9.6.1">9.6.1</a>)</p></li>
<li><p>A type in the <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>A type in the <code>extends</code> clause of a type parameter declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>The type in a field declaration of a class or interface (including an enum constant) (<a href="#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a>, <a href="#jls-8.9.1">8.9.1</a>)</p></li>
<li><p>The type in a formal parameter declaration of a method, constructor, or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>The type of the receiver parameter of a method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p>The type in a local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>The type in an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ol></li>
<li><p>In expressions:</p>
<ol type="1">
<li><p>A type in the explicit type argument list to an explicit constructor invocation statement<strong>,</strong> <del>or</del> class instance creation expression<strong>,</strong> <del>or</del> method invocation expression<strong>, or method reference expression</strong> (<a href="#jls-8.8.7.1">8.8.7.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a><strong>, <a href="#jls-15.13">15.13</a></strong>)</p></li>
<li><p>In an unqualified class instance creation expression, as the class type to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>) or as the direct superclass <strong>type</strong> or direct superinterface <strong>type</strong> of an anonymous class to be instantiated (<a href="#jls-15.9.5">15.9.5</a>)</p></li>
<li><p>The element type in an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>The type in the cast operator of a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>The type that follows the <code>instanceof</code> relational operator (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.20.2">15.20.2</a>)</p></li>
<li><p>In a method reference expression (<a href="#jls-15.13">15.13</a>), as the reference type to search for a member method or as the class type or array type to construct.</p></li>
</ol></li>
</ul>
<p>Also, types are used as:</p>
<ul>
<li><p>The element type of an array type in any of the above contexts; and</p></li>
<li><p>A non-wildcard type argument, or a bound of a wildcard type argument, of a parameterized type in any of the above contexts.</p></li>
</ul>
<p>Finally, there are <del>three</del> <strong>two</strong> special terms in the Java programming language which denote the use of a type:</p>
<ul>
<li><p>An unbounded wildcard (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a>)</p></li>
<li><p>The <code>...</code> in the type of a variable arity parameter (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>), to indicate an array type</p></li>
<li><p><del>The simple name of a type in a constructor declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>), to indicate the class of the constructed object</del></p>
<div class="editorial">
<p>The identifier used in a constructor declaration is a class name, not a type.</p>
</div></li>
</ul>
<p>The meaning of types in type contexts is given by:</p>
<ul>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.2">4.2</a>, for primitive types</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>, for type parameters</p></li>
<li><p><a href="#jls-4.5">4.5</a>, for class and interface types that are parameterized, or appear either as type arguments in a parameterized type or as bounds of wildcard type arguments in a parameterized type</p></li>
<li><p><a href="#jls-4.8">4.8</a>, for class and interface types that are raw</p></li>
<li><p><a href="#jls-4.9">4.9</a>, for intersection types in the bounds of type parameters</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5">6.5</a>, for <del>class and interface</del> types <strong>of non-generic classes and interfaces</strong> <del>in contexts where genericity is unimportant (<a href="#jls-6.1">6.1</a>)</del> <strong>and type variables</strong></p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.1">10.1</a>, for array types</p></li>
</ul>
<p>Some type contexts restrict how a reference type may be parameterized:</p>
<ul>
<li><p>The following type contexts require that if a type is a parameterized reference type, it has no wildcard type arguments:</p>
<ul>
<li><p>In an <code>extends</code> or <code>implements</code> clause of a class declaration (<a href="#jls-8.1.4">8.1.4</a>, <a href="#jls-8.1.5">8.1.5</a>)</p></li>
<li><p>In an <code>extends</code> clause of an interface declaration (<a href="#jls-9.1.3">9.1.3</a>)</p></li>
<li><p>In an unqualified class instance creation expression, as the class type to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>) or as the direct superclass <strong>type</strong> or direct superinterface <strong>type</strong> of an anonymous class to be instantiated (<a href="#jls-15.9.5">15.9.5</a>)</p></li>
<li><p>In a method reference expression (<a href="#jls-15.13">15.13</a>), as the reference type to search for a member method or as the class type or array type to construct.</p></li>
</ul>
<p>In addition, no wildcard type arguments are permitted in the explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression or method reference expression (<a href="#jls-8.8.7.1">8.8.7.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>, <a href="#jls-15.13">15.13</a>).</p></li>
<li><p>The following type contexts require that if a type is a parameterized reference type, it has only unbounded wildcard type arguments (i.e. it is a reifiable type) :</p>
<ul>
<li><p>As the element type in an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>As the type that follows the <code>instanceof</code> relational operator (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.20.2">15.20.2</a>)</p></li>
</ul></li>
<li><p>The following type contexts disallow a parameterized reference type altogether, because they involve exceptions and the type of an exception is non-generic (<a href="#jls-6.1">6.1</a>):</p>
<ul>
<li><p>As the type of an exception that can be thrown by a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>In an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ul></li>
</ul>
<blockquote>
<p>In any type context where a type is used, it is possible to annotate the keyword denoting a primitive type or the <em>Identifier</em> denoting the simple name of a reference type. It is also possible to annotate an array type by writing an annotation to the left of the <code>[</code> at the desired level of nesting in the array type. Annotations in these locations are called <em>type annotations</em>, and are specified in <a href="#jls-9.7.4">9.7.4</a>. Here are some examples:</p>
</blockquote>
<blockquote>
<ul>
<li><p><code>@Foo int[] f;</code> annotates the primitive type <code>int</code></p></li>
<li><p><code>int @Foo [] f;</code> annotates the array type <code>int[]</code></p></li>
<li><p><code>int @Foo [][] f;</code> annotates the array type <code>int[][]</code></p></li>
<li><p><code>int[] @Foo [] f;</code> annotates the array type <code>int[]</code> which is the component type of the array type <code>int[][]</code></p></li>
</ul>
</blockquote>
<blockquote>
<p>Five of the <em>type contexts</em> which appear in declarations occupy the same syntactic real estate as a number of <em>declaration contexts</em> (<a href="#jls-9.6.4.1">9.6.4.1</a>):</p>
</blockquote>
<blockquote>
<ul>
<li><p>The return type of a method (including the type of an element of an annotation <del>type</del> <strong>interface</strong>)</p></li>
<li><p>The type in a field declaration of a class or interface (including an enum constant)</p></li>
<li><p>The type in a formal parameter declaration of a method, constructor, or lambda expression</p></li>
<li><p>The type in a local variable declaration</p></li>
<li><p>The type in an exception parameter declaration</p></li>
</ul>
</blockquote>
<blockquote>
<p>The fact that the same syntactic location in a program can be both a type context and a declaration context arises because the modifiers for a declaration immediately precede the type of the declared entity. <a href="#jls-9.7.4">9.7.4</a> explains how an annotation in such a location is deemed to appear in a type context or a declaration context or both.</p>
</blockquote>
<div class="example">
<p>Example 4.11-1. Usage of a Type</p>
<pre><code>import java.util.Random;
import java.util.Collection;
import java.util.ArrayList;

class MiscMath&lt;T extends Number&gt; {
    int divisor;
    MiscMath(int divisor) { this.divisor = divisor; }
    float ratio(long l) {
        try {
            l /= divisor;
        } catch (Exception e) {
            if (e instanceof ArithmeticException)
                l = Long.MAX_VALUE;
            else
                l = 0;
        }
        return (float)l;
    }
    double gausser() {
        Random r = new Random();
        double[] val = new double[2];
        val[0] = r.nextGaussian();
        val[1] = r.nextGaussian();
        return (val[0] + val[1]) / 2;
    }
    Collection&lt;Number&gt; fromArray(Number[] na) {
        Collection&lt;Number&gt; cn = new ArrayList&lt;Number&gt;();
        for (Number n : na) cn.add(n);
        return cn;
    }
    &lt;S&gt; void loop(S s) { this.&lt;S&gt;loop(s); }  
}</code></pre>
<p>In this example, types are used in declarations of the following:</p>
<ul>
<li><p><del>Imported types (<a href="#jls-7.5">7.5</a>); here the type <code>Random</code>, imported from the type <code>java.util.Random</code> of the package <code>java.util</code>, is declared</del></p>
<div class="editorial">
<p>Classes and interfaces, not types, are imported.</p>
</div></li>
<li><p>Fields, which are the class variables and instance variables of classes (<a href="#jls-8.3">8.3</a>), and constants of interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a>); here the field <code>divisor</code> in the class <code>MiscMath</code> is declared to be of type <code>int</code></p></li>
<li><p>Method parameters (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>); here the parameter <code>l</code> of the method <code>ratio</code> is declared to be of type <code>long</code></p></li>
<li><p>Method results (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>); here the result of the method <code>ratio</code> is declared to be of type <code>float</code>, and the result of the method <code>gausser</code> is declared to be of type <code>double</code></p></li>
<li><p>Constructor parameters (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>); here the parameter of the constructor for <code>MiscMath</code> is declared to be of type <code>int</code></p></li>
<li><p>Local variables (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14">14.14</a>); the local variables <code>r</code> and <code>val</code> of the method <code>gausser</code> are declared to be of types <code>Random</code> and <code>double[]</code> (array of <code>double</code>)</p></li>
<li><p>Exception parameters (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>); here the exception parameter <code>e</code> of the <code>catch</code> clause is declared to be of type <code>Exception</code></p></li>
<li><p>Type parameters (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>); here the type parameter of <code>MiscMath</code> is a type variable <code>T</code> with the type <code>Number</code> as its declared bound</p></li>
<li><p>In any declaration that uses a parameterized type; here the type <code>Number</code> is used as a type argument (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a>) in the parameterized type <code>Collection&lt;Number&gt;</code>.</p></li>
</ul>
<p>and in expressions of the following kinds:</p>
<ul>
<li><p>Class instance creations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>); here a local variable <code>r</code> of method <code>gausser</code> is initialized by a class instance creation expression that uses the type <code>Random</code></p></li>
<li><p>Generic class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>) instance creations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>); here <code>Number</code> is used as a type argument in the expression <code>new ArrayList&lt;Number&gt;()</code></p></li>
<li><p>Array creations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.10.1">15.10.1</a>); here the local variable <code>val</code> of method <code>gausser</code> is initialized by an array creation expression that creates an array of <code>double</code> with size 2</p></li>
<li><p>Generic method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.4">8.4.4</a>) or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.4">8.8.4</a>) invocations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>); here the method <code>loop</code> calls itself with an explicit type argument <code>S</code></p></li>
<li><p>Casts (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.16">15.16</a>); here the <code>return</code> statement of the method <code>ratio</code> uses the <code>float</code> type in a cast</p></li>
<li><p>The <code>instanceof</code> operator (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.20.2">15.20.2</a>); here the <code>instanceof</code> operator tests whether <code>e</code> is assignment-compatible with the type <code>ArithmeticException</code></p></li>
</ul>
</div>
<h2 id="jls-6">Chapter 6: Names</h2>
<p>Names are used to refer to entities declared in a program.</p>
<p>A declared entity (<a href="#jls-6.1">6.1</a>) is a package, class <del>type (normal or enum)</del>, interface <del>type (normal or annotation type)</del>, member (class, interface, field, or method) of a reference type, type parameter <del>(of a class, interface, method or constructor)</del>, <del>parameter (to a method, constructor, or exception handler)</del> <strong>formal parameter, exception parameter</strong>, or local variable.</p>
<div class="editorial">
<p>There's a whole section coming up (<a href="#jls-6.1">6.1</a>) dedicated to enumerating all the cases. The introductory sentence for the chapter shouldn't be trying to repeat that entire enumeration. E.g., we can describe the different kinds of class declarations later.</p>
</div>
<p>Names in programs are either <em>simple</em>, consisting of a single identifier, or <em>qualified</em>, consisting of a sequence of identifiers separated by &quot;<code>.</code>&quot; tokens (<a href="#jls-6.2">6.2</a>).</p>
<p>Every declaration that introduces a name has a <em>scope</em> (<a href="#jls-6.3">6.3</a>), which is the part of the program text within which the declared entity can be referred to by a simple name.</p>
<p>A qualified name <em>N.x</em> may be used to refer to a <em>member</em> of a package or reference type, where <em>N</em> is a simple or qualified name and <em>x</em> is an identifier. If <em>N</em> names a package, then <em>x</em> is a member of that package, which is either a class or interface type or a subpackage. If <em>N</em> names a reference type or a variable of a reference type, then <em>x</em> names a member of that type, which is either a class, an interface, a field, or a method.</p>
<p>In determining the meaning of a name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5">6.5</a>), the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name.</p>
<p>Access control (<a href="#jls-6.6">6.6</a>) can be specified in a class, interface, method, or field declaration to control when <em>access</em> to a member is allowed. Access is a different concept from scope. Access specifies the part of the program text within which the declared entity can be referred to by a qualified name. Access to a declared entity is also relevant in a field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11">15.11</a>), a method invocation expression in which the method is not specified by a simple name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>), a method reference expression (<a href="#jls-15.13">15.13</a>), or a qualified class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>). In the absence of an access modifier, most declarations have package access, allowing access anywhere within the package that contains its declaration; other possibilities are <code>public</code>, <code>protected</code>, and <code>private</code>.</p>
<p>Fully qualified and canonical names (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>) are also discussed in this chapter.</p>
<h3 id="jls-6.1">6.1 Declarations</h3>
<p>A <em>declaration</em> introduces an entity into a program and includes an identifier (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.8">3.8</a>) that can be used in a name to refer to this entity. The identifier is constrained to be a type identifier when the entity being introduced is a class, interface, or type parameter.</p>
<p>A declared entity is one of the following:</p>
<ul>
<li><p>A module, declared in a <code>module</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7">7.7</a>)</p></li>
<li><p>A package, declared in a <code>package</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4">7.4</a>)</p></li>
<li><p>An imported <del>type</del> <strong>class or interface</strong>, declared in a single-type-import declaration or a type-import-on-demand declaration (<a href="#jls-7.5.1">7.5.1</a>, <a href="#jls-7.5.2">7.5.2</a>)</p></li>
<li><p>An imported <code>static</code> member, declared in a single-static-import declaration or a static-import-on-demand declaration (<a href="#jls-7.5.3">7.5.3</a>, <a href="#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>A class, declared <del>in</del> <strong>by</strong> a <strong>normal</strong> class <del>type</del> declaration (<a href="#jls-8.1">8.1</a>) <strong>or an enum declaration (<a href="#jls-8.9">8.9</a>)</strong></p></li>
<li><p>An interface, declared <del>in an</del> <strong>by a normal</strong> interface <del>type</del> declaration (<a href="#jls-9.1">9.1</a>) <strong>or an annotation declaration (<a href="#jls-9.6">9.6</a>)</strong></p></li>
<li><p>A type parameter, declared as part of the declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>A member of a reference type (<a href="#jls-8.2">8.2</a>, <a href="#jls-9.2">9.2</a>, <a href="#jls-8.9.3">8.9.3</a>, <a href="#jls-9.6">9.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.7">10.7</a>), one of the following:</p>
<ul>
<li><p>A member class (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>)</p></li>
<li><p>A member interface (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>)</p></li>
<li><p><del>An enum constant (<a href="#jls-8.9">8.9</a>)</del></p>
<div class="editorial">
<p>Enum constants are not members—they introduce implicit fields, which are members.</p>
</div></li>
<li><p>A field, one of the following:</p>
<ul>
<li><p>A field declared in a class <del>type or enum type</del> (<a href="#jls-8.3">8.3</a><del>, <a href="#jls-8.9.2">8.9.2</a></del>)</p></li>
<li><p>A field declared in an interface <del>type or annotation type</del> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a><del>, <a href="#jls-9.6.1">9.6.1</a></del>)</p></li>
<li><p>The field <code>length</code>, which is implicitly a member of every array type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.7">10.7</a>)</p></li>
</ul></li>
<li><p>A method, one of the following:</p>
<ul>
<li><p>A method (<code>abstract</code> or otherwise) declared in a class <del>type or enum type</del> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a><del>, <a href="#jls-8.9.2">8.9.2</a></del>)</p></li>
<li><p>A method (<code>abstract</code> or otherwise) declared in an interface <del>type or annotation type</del> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a><del>, <a href="#jls-9.6.1">9.6.1</a></del>)</p></li>
</ul></li>
</ul></li>
<li><p><strong>An enum constant (<a href="#jls-8.9.1">8.9.1</a>)</strong></p></li>
<li><p><del>A parameter, one of the following:</del></p>
<ul>
<li><p><del>A formal parameter of a method or constructor of a class type or enum type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="#jls-8.9.2">8.9.2</a>), or of a lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27.1">15.27.1</a>)</del></p></li>
<li><p><del>A formal parameter of an <code>abstract</code> method of an interface type or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="#jls-9.6.1">9.6.1</a>)</del></p></li>
<li><p><del>An exception parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</del></p></li>
</ul></li>
<li><p><strong>A formal parameter of a method of a class or interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>), a constructor of a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>), or a lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27.1">15.27.1</a>)</strong></p></li>
<li><p><strong>An exception parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</strong></p></li>
</ul>
<div class="editorial">
<p>Formal parameters and exception parameters are typically treated as two distinct entities. Formal parameters of class methods and interface methods, on the other hand, are specified in exactly one place, and don't need to be treated as distinct things.</p>
</div>
<ul>
<li><p>A local variable, one of the following:</p>
<ul>
<li><p>A local variable declared in a block (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>)</p></li>
<li><p>A local variable declared in a <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14">14.14</a>)</p></li>
</ul></li>
<li><p><strong>A local class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.3">14.3</a>)</strong></p></li>
</ul>
<p>Constructors (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.</p>
<div class="deleted">
<p>The declaration of a type which is not generic (<code>class C ...</code>) declares one entity: a non-generic type (<code>C</code>). A non-generic type is not a raw type, despite the syntactic similarity. In contrast, the declaration of a generic type (<code>class C&lt;T&gt; ...</code> or <code>interface C&lt;T&gt; ...</code>) declares two entities: a generic type (<code>C&lt;T&gt;</code>) and a corresponding non-generic type (<code>C</code>). In this case, the meaning of the term <code>C</code> depends on the context where it appears:</p>
<ul>
<li><p>If genericity is unimportant, as in the <em>non-generic contexts</em> identified below, the identifier <code>C</code> denotes the non-generic type <code>C</code>.</p></li>
<li><p>If genericity is important, as in all contexts from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5">6.5</a> except the non-generic contexts, the identifier <code>C</code> denotes either:</p>
<ul>
<li><p>The raw type <code>C</code> which is the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of the generic type <code>C&lt;T&gt;</code>; or</p></li>
<li><p>A parameterized type which is a particular parameterization (<a href="#jls-4.5">4.5</a>) of the generic type <code>C&lt;T&gt;</code>.</p></li>
</ul></li>
</ul>
<p>The 14 non-generic contexts are as follows:</p>
<ol type="1">
<li><p>In a <code>uses</code> or <code>provides</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.1">7.7.1</a>)</p></li>
<li><p>In a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>)</p></li>
<li><p>To the left of the <code>.</code> in a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>)</p></li>
<li><p>To the left of the <code>.</code> in a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>To the left of the <code>(</code> in a constructor declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>)</p></li>
<li><p>After the <code>@</code> sign in an annotation (<a href="#jls-9.7">9.7</a>)</p></li>
<li><p>To the left of <code>.class</code> in a class literal (<a href="#jls-15.8.2">15.8.2</a>)</p></li>
<li><p>To the left of <code>.this</code> in a qualified <code>this</code> expression (<a href="#jls-15.8.4">15.8.4</a>)</p></li>
<li><p>To the left of <code>.super</code> in a qualified superclass field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11.2">15.11.2</a>)</p></li>
<li><p>To the left of <code>.</code><em>Identifier</em> or <code>.super.</code><em>Identifier</em> in a qualified method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>To the left of <code>.super::</code> in a method reference expression (<a href="#jls-15.13">15.13</a>)</p></li>
<li><p>In a qualified expression name in a postfix expression or a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.14.1">15.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>In a <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>In an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ol>
<p>The first eleven non-generic contexts correspond to the first eleven syntactic contexts for a <em>TypeName</em> in <a href="#jls-6.5.1">6.5.1</a>. The twelfth non-generic context is where a qualified <em>ExpressionName</em> such as <code>C.x</code> may include a <em>TypeName</em> <code>C</code> to denote static member access. The common use of <em>TypeName</em> in these twelve contexts is significant: it indicates that these contexts involve a less-than-first-class use of a type. In contrast, the thirteenth and fourteenth non-generic contexts employ <em>ClassType</em>, indicating that <code>throws</code> and <code>catch</code> clauses use types in a first-class way, in line with, say, field declarations. The characterization of these two contexts as non-generic is due to the fact that an exception type cannot be parameterized.</p>
<blockquote>
<p>Note that the <em>ClassType</em> production allows annotations, so it is possible to annotate the use of a type in a <code>throws</code> or <code>catch</code> clause, whereas the <em>TypeName</em> production disallows annotations, so it is not possible to annotate the name of a type in, say, a single-type-import declaration.</p>
</blockquote>
</div>
<div class="inserted">
<blockquote>
<p>The declaration of a generic class or interface (<code>class C&lt;T&gt; ...</code> or <code>interface C&lt;T&gt; ...</code>) (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>) introduces both a class named <code>C</code> and a family of types: raw <code>C</code>, <code>C&lt;Foo&gt;</code>, <code>C&lt;Bar&gt;</code>, etc.</p>
<p>When a reference to <code>C</code> occurs where genericity is unimportant, identified below as one of the <em>non-generic contexts</em>, the reference to <code>C</code> denotes the <em>class</em> or <em>interface</em> <code>C</code>. In other contexts, the reference to <code>C</code> denotes a <em>type</em>, or part of a type, introduced by <code>C</code>.</p>
<p>The 14 non-generic contexts are as follows:</p>
<ol type="1">
<li><p>In a <code>uses</code> or <code>provides</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.1">7.7.1</a>)</p></li>
<li><p>In a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>)</p></li>
<li><p>To the left of the <code>.</code> in a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>)</p></li>
<li><p>To the left of the <code>.</code> in a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>To the left of the <code>(</code> in a constructor declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>)</p></li>
<li><p>After the <code>@</code> sign in an annotation (<a href="#jls-9.7">9.7</a>)</p></li>
<li><p>To the left of <code>.class</code> in a class literal (<a href="#jls-15.8.2">15.8.2</a>)</p></li>
<li><p>To the left of <code>.this</code> in a qualified <code>this</code> expression (<a href="#jls-15.8.4">15.8.4</a>)</p></li>
<li><p>To the left of <code>.super</code> in a qualified superclass field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11.2">15.11.2</a>)</p></li>
<li><p>To the left of <code>.</code><em>Identifier</em> or <code>.super.</code><em>Identifier</em> in a qualified method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>To the left of <code>.super::</code> in a method reference expression (<a href="#jls-15.13">15.13</a>)</p></li>
<li><p>In a qualified expression name in a postfix expression or a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.14.1">15.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>In a <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>In an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ol>
<p>The first eleven non-generic contexts correspond to the first eleven syntactic contexts for a <em>TypeName</em> in <a href="#jls-6.5.1">6.5.1</a>. The twelfth non-generic context is where a qualified <em>ExpressionName</em> such as <code>C.x</code> may include a <em>TypeName</em> <code>C</code> to denote static member access. The common use of <em>TypeName</em> in these twelve contexts is significant: it indicates that these contexts involve a less-than-first-class use of a type. In contrast, the thirteenth and fourteenth non-generic contexts employ <em>ClassType</em>, indicating that <code>throws</code> and <code>catch</code> clauses use types in a first-class way, in line with, say, field declarations. The characterization of these two contexts as non-generic is due to the fact that an exception type cannot be parameterized.</p>
<p>Note that the <em>ClassType</em> production allows annotations, so it is possible to annotate the use of a type in a <code>throws</code> or <code>catch</code> clause, whereas the <em>TypeName</em> production disallows annotations, so it is not possible to annotate the name of a type in, say, a single-type-import declaration.</p>
</blockquote>
</div>
<div class="editorial">
<p>This discussion was an earlier attempt to do what we're doing in this document in a more comprehensive way: distinguish between <em>classes</em> and (possibly parameterized) <em>class types</em>, and between <em>interfaces</em> and (possible parameterized) <em>interface types</em>. Now the terminology surrounding the above contexts (in their respective sections) should make clear that there is, for the most part, no type involved at all—these are constructs that talk about classes and interfaces, not their types.</p>
<p>The discussion is preserved here as a note, with some modifications to the introductory paragraphs, to help clarify the distinction between references to classes and references to types.</p>
</div>
<blockquote>
<p><em>Naming Conventions</em></p>
</blockquote>
<blockquote>
<p>The class libraries of the Java SE Platform attempt to use, whenever possible, names chosen according to the conventions presented below. These conventions help to make code more readable and avoid certain kinds of name conflicts.</p>
</blockquote>
<blockquote>
<p>We recommend these conventions for use in all programs written in the Java programming language. However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise. So, for example, the <code>sin</code> and <code>cos</code> methods of the class <code>java.lang.Math</code> have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.</p>
</blockquote>
<p>...</p>
<blockquote>
<p><em>Class and Interface <del>Type</del> Names</em></p>
</blockquote>
<blockquote>
<p>Names of <del>class types</del> <strong>classes</strong> should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized.</p>
</blockquote>
<div class="example">
<p>Example 6.1-3. Descriptive Class Names</p>
<pre><code>`ClassLoader`
SecurityManager
`Thread`
Dictionary
BufferedInputStream</code></pre>
</div>
<blockquote>
<p>Likewise, names of <del>interface types</del> <strong>interfaces</strong> should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized. The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces <code>java.io.DataInput</code> and <code>java.io.DataOutput</code>; or it may be an adjective describing a behavior, as for the interfaces <code>Runnable</code> and <code>Cloneable</code>.</p>
</blockquote>
<blockquote>
<p><em>Type Variable Names</em></p>
</blockquote>
<blockquote>
<p>Type variable names should be pithy (single character if possible) yet evocative, and should not include lower case letters. This makes it easy to distinguish type parameters from ordinary classes and interfaces.</p>
</blockquote>
<blockquote>
<p>Container <del>types</del> <strong>classes and interfaces</strong> should use the name <code>E</code> for their element type. Maps should use <code>K</code> for the type of their keys and <code>V</code> for the type of their values. The name <code>X</code> should be used for arbitrary exception types. We use <code>T</code> for type, whenever there is not anything more specific about the type to distinguish it. (This is often the case in generic methods.)</p>
</blockquote>
<blockquote>
<p>If there are multiple type parameters that denote arbitrary types, one should use letters that neighbor <code>T</code> in the alphabet, such as <code>S</code>. Alternately, it is acceptable to use numeric subscripts (e.g., <code>T1</code>, <code>T2</code>) to distinguish among the different type variables. In such cases, all the variables with the same prefix should be subscripted.</p>
</blockquote>
<blockquote>
<p>If a generic method appears inside a generic class, it is a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion. The same applies to nested generic classes.</p>
</blockquote>
<div class="example">
<p>Example 6.1-4. Conventional Type Variable Names</p>
<pre><code>public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; { ... }
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; { ... }
public class ThreadLocal&lt;T&gt; { ... }
public interface Functor&lt;T, X extends Throwable&gt; {
    T eval() throws X;
}</code></pre>
</div>
<blockquote>
<p>When type parameters do not fall conveniently into one of the categories mentioned, names should be chosen to be as meaningful as possible within the confines of a single letter. The names mentioned above (<code>E</code>, <code>K</code>, <code>V</code>, <code>X</code>, <code>T</code>) should not be used for type parameters that do not fall into the designated categories.</p>
</blockquote>
<p>...</p>
<blockquote>
<p><em>Constant Names</em></p>
</blockquote>
<blockquote>
<p>The names of constants in <del>interface types</del> <strong>interfaces</strong> should be, and <code>final</code> variables of <del>class types</del> <strong>classes</strong> may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore &quot;<code>_</code>&quot; characters. Constant names should be descriptive and not unnecessarily abbreviated. Conventionally they may be any appropriate part of speech.</p>
</blockquote>
<blockquote>
<p>Examples of names for constants include <code>MIN_VALUE</code>, <code>MAX_VALUE</code>, <code>MIN_RADIX</code>, and <code>MAX_RADIX</code> of the class <code>Character</code>.</p>
</blockquote>
<blockquote>
<p>A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix.</p>
</blockquote>
<blockquote>
<p>For example:</p>
<pre><code>interface ProcessStates {
    int PS_RUNNING   = 0;
    int PS_SUSPENDED = 1;
}</code></pre>
</blockquote>
<p>...</p>
<h3 id="jls-6.2">6.2 Names and Identifiers</h3>
<p>A <em>name</em> is used to refer to an entity declared in a program.</p>
<p>There are two forms of names: simple names and qualified names.</p>
<p>A <em>simple name</em> is a single identifier.</p>
<p>A <em>qualified name</em> consists of a name, a &quot;<code>.</code>&quot; token, and an identifier.</p>
<p>In determining the meaning of a name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5">6.5</a>), the context in which the name appears is taken into account. The rules of <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5">6.5</a> distinguish among contexts where a name must denote (refer to) a package (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.3">6.5.3</a>)<del>,</del> <strong>;</strong> a <del>type</del> <strong>class, interface, or type parameter</strong> (<a href="#jls-6.5.5">6.5.5</a>)<del>,</del> <strong>;</strong> a variable or value in an expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.6">6.5.6</a>)<del>,</del> <strong>;</strong> or a method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.7">6.5.7</a>).</p>
<blockquote>
<p>Packages<strong>,</strong> <del>and reference types</del> <strong>classes, interfaces, and type parameters</strong> have <em>members</em> which may be accessed by qualified names. As background for the discussion of qualified names and the determination of the meaning of names, see the descriptions of membership in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">4.4</a>, <a href="#jls-4.5.2">4.5.2</a>, <a href="#jls-4.8">4.8</a>, <a href="#jls-4.9">4.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.1">7.1</a>, <a href="#jls-8.2">8.2</a>, <a href="#jls-9.2">9.2</a>, and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.7">10.7</a>.</p>
</blockquote>
<p>Not all identifiers in a program are a part of a name. Identifiers are also used in the following situations:</p>
<ul>
<li><p>In declarations (<a href="#jls-6.1">6.1</a>), where an identifier may occur to specify the name by which the declared entity will be known.</p></li>
<li><p>As labels in labeled statements (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.7">14.7</a>) and in <code>break</code> and <code>continue</code> statements (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.15">14.15</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.16">14.16</a>) that refer to statement labels.</p>
<p>The identifiers used in labeled statements and their associated <code>break</code> and <code>continue</code> statements are completely separate from those used in declarations.</p></li>
<li><p>In field access expressions (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11">15.11</a>), where an identifier occurs after a &quot;<code>.</code>&quot; token to indicate a member of the object denoted by the expression before the &quot;<code>.</code>&quot; token, or the object denoted by the <code>super</code> or <em>TypeName</em><code>.super</code> before the &quot;<code>.</code>&quot; token.</p></li>
<li><p>In some method invocation expressions (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>), wherever an identifier occurs after a &quot;<code>.</code>&quot; token and before a &quot;<code>(</code>&quot; token to indicate a method to be invoked for the object denoted by the expression before the &quot;<code>.</code>&quot; token, or the type denoted by the <em>TypeName</em> before the &quot;<code>.</code>&quot; token, or the object denoted by the <code>super</code> or <em>TypeName</em><code>.super</code> before the &quot;<code>.</code>&quot; token.</p></li>
<li><p>In some method reference expressions (<a href="#jls-15.13">15.13</a>), wherever an identifier occurs after a &quot;<code>::</code>&quot; token to indicate a method of the object denoted by the expression before the &quot;<code>::</code>&quot; token, or the type denoted by the <em>TypeName</em> before the &quot;<code>::</code>&quot; token, or the object denoted by the <code>super</code> or <em>TypeName</em><code>.super</code> before the &quot;<code>::</code>&quot; token.</p></li>
<li><p>In qualified class instance creation expressions (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>), where an identifier occurs to the right of the <code>new</code> token to indicate a type that is a member of the compile-time type of the expression preceding the <code>new</code> token.</p></li>
<li><p>In element-value pairs of annotations (<a href="#jls-9.7.1">9.7.1</a>), to denote an element of the corresponding annotation <del>type</del> <strong>interface</strong>.</p></li>
</ul>
<p>...</p>
<h3 id="jls-6.3">6.3 Scope of a Declaration</h3>
<p>The <em>scope</em> of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is not shadowed (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>).</p>
<p>A declaration is said to be <em>in scope</em> at a particular point in a program if and only if the declaration's scope includes that point.</p>
<p>The scope of the declaration of an observable top level package (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.3">7.4.3</a>) is all observable compilation units associated with modules to which the package is uniquely visible (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.3">7.4.3</a>).</p>
<p>The declaration of a package that is not observable is never in scope.</p>
<p>The declaration of a subpackage is never in scope.</p>
<p>The package <code>java</code> is always in scope.</p>
<p>The scope of a <del>type</del> <strong>class or interface</strong> imported by a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>) or a type-import-on-demand declaration (<a href="#jls-7.5.2">7.5.2</a>) is the module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7">7.7</a>) and all the class and interface <del>type</del> declarations (<a href="#jls-7.6">7.6</a>) of the compilation unit in which the <code>import</code> declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit.</p>
<p>The scope of a member imported by a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>) or a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>) is the module declaration and all the class and interface <del>type</del> declarations of the compilation unit in which the <code>import</code> declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit.</p>
<p>The scope of a top level <del>type</del> <strong>class or interface</strong> (<a href="#jls-7.6">7.6</a>) is all <del>type</del> <strong>class and interface</strong> declarations in the package in which the top level <del>type</del> <strong>class or interface</strong> is declared.</p>
<p>The scope of a declaration of a member <em>m</em> declared in or inherited by a class <del>type</del> <strong>or interface</strong> <em>C</em> (<del><a href="#jls-8.1.6">8.1.6</a></del> <strong><a href="#jls-8.2">8.2</a>, <a href="#jls-9.2">9.2</a></strong>) is the entire body of <em>C</em>, including any nested <del>type</del> <strong>class or interface</strong> declarations.</p>
<p><del>The scope of a declaration of a member <em>m</em> declared in or inherited by an interface type <em>I</em> (<a href="#jls-9.1.4">9.1.4</a>) is the entire body of <em>I</em>, including any nested type declarations.</del></p>
<p><del>The scope of an enum constant <em>C</em> declared in an enum type <em>T</em> is the body of <em>T</em>, and any <code>case</code> label of a <code>switch</code> statement whose expression is of enum type <em>T</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.11">14.11</a>).</del></p>
<div class="editorial">
<p>Names do not resolve to enum constants, they resolve to implicit fields of enum classes. Switch statements require some special treatment, but don't rely on the normal scoping/name resolution mechanisms.</p>
</div>
<p>The scope of a formal parameter of a method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>), constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>), or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27">15.27</a>) is the entire body of the method, constructor, or lambda expression.</p>
<p>The scope of a class's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>) is the type parameter section of the class declaration, the type parameter section of any superclass <strong>type</strong> or superinterface <strong>type</strong> of the class declaration, and the class body.</p>
<p>The scope of an interface's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>) is the type parameter section of the interface declaration, the type parameter section of any superinterface <strong>type</strong> of the interface declaration, and the interface body.</p>
<p>The scope of a method's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.4">8.4.4</a>) is the entire declaration of the method, including the type parameter section, but excluding the method modifiers.</p>
<p>The scope of a constructor's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.4">8.8.4</a>) is the entire declaration of the constructor, including the type parameter section, but excluding the constructor modifiers.</p>
<p>The scope of a local class declaration immediately enclosed by a block (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.2">14.2</a>) is the rest of the immediately enclosing block, including its own class declaration.</p>
<p>The scope of a local class declaration immediately enclosed by a switch block statement group (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.11">14.11</a>) is the rest of the immediately enclosing switch block statement group, including its own class declaration.</p>
<p>The scope of a local variable declaration in a block (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>) is the rest of the block in which the declaration appears, starting with its own initializer and including any further declarators to the right in the local variable declaration statement.</p>
<p>The scope of a local variable declared in the <em>ForInit</em> part of a basic <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.1">14.14.1</a>) includes all of the following:</p>
<ul>
<li><p>Its own initializer</p></li>
<li><p>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement</p></li>
<li><p>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement</p></li>
<li><p>The contained <em>Statement</em></p></li>
</ul>
<p>The scope of a local variable declared in the <em>FormalParameter</em> part of an enhanced <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.2">14.14.2</a>) is the contained <em>Statement</em>.</p>
<p>The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>) is the entire block associated with the <code>catch</code>.</p>
<p>The scope of a variable declared in the <em>ResourceSpecification</em> of a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>) is from the declaration rightward over the remainder of the <em>ResourceSpecification</em> and the entire <code>try</code> block associated with the <code>try</code>-with-resources statement.</p>
<blockquote>
<p>The translation of a <code>try</code>-with-resources statement implies the rule above.</p>
</blockquote>
<div class="example">
<p>Example 6.3-1. Scope of <del>Type</del> <strong>Class</strong> Declarations</p>
<p>These rules imply that declarations of class and interface types need not appear before uses of the types. In the following program, the use of <code>PointList</code> in class <code>Point</code> is valid, because the scope of the class declaration <code>PointList</code> includes both class <code>Point</code> and class <code>PointList</code>, as well as any other <del>type</del> <strong>class or interface</strong> declarations in other compilation units of package <code>points</code>.</p>
<pre><code>package points;
class Point {
    int x, y;
    PointList list;
    Point next;
}

class PointList {
    Point first;
}</code></pre>
</div>
<div class="example">
<p>Example 6.3-2. Scope of Local Variable Declarations</p>
<p>The following program causes a compile-time error because the initialization of local variable <code>x</code> is within the scope of the declaration of local variable <code>x</code>, but the local variable <code>x</code> does not yet have a value and cannot be used. The field <code>x</code> has a value of <code>0</code> (assigned when <code>Test1</code> was initialized) but is a red herring since it is shadowed (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) by the local variable <code>x</code>.</p>
<pre><code>class Test1 {
    static int x;
    public static void main(String[] args) {
        int x = x;
    }
}</code></pre>
<p>The following program does compile:</p>
<pre><code>class Test2 {
    static int x;
    public static void main(String[] args) {
        int x = (x=2)*2;
        System.out.println(x);
    }
}</code></pre>
<p>because the local variable <code>x</code> is definitely assigned (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-16.html">16</a>) before it is used. It prints:</p>
<pre><code>4</code></pre>
<p>In the following program, the initializer for <code>three</code> can correctly refer to the variable <code>two</code> declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable <code>three</code> declared earlier in the block.</p>
<pre><code>class Test3 {
    public static void main(String[] args) {
        System.out.print(&quot;2+1=&quot;);
        int two = 2, three = two + 1;
        System.out.println(three);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>2+1=3</code></pre>
</div>
<h3 id="jls-6.5">6.5 Determining the Meaning of a Name</h3>
<h4 id="jls-6.5.1">6.5.1 Syntactic Classification of a Name According to Context</h4>
<p>A name is syntactically classified as a <em>ModuleName</em> in these contexts:</p>
<ul>
<li><p>In a <code>requires</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.1">7.7.1</a>)</p></li>
<li><p>To the right of <code>to</code> in an <code>exports</code> or <code>opens</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.2">7.7.2</a>)</p></li>
</ul>
<p>A name is syntactically classified as a <em>PackageName</em> in these contexts:</p>
<ul>
<li><p>To the right of <code>exports</code> or <code>opens</code> in a module declaration</p></li>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>PackageName</em></p></li>
</ul>
<p>A name is syntactically classified as a <em>TypeName</em> in these contexts:</p>
<ul>
<li><p><del>The first eleven non-generic contexts (<a href="#jls-6.1">6.1</a>)</del> <strong>To name a class or interface</strong>:</p>
<ol type="1">
<li><p>In a <code>uses</code> or <code>provides</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.1">7.7.1</a>)</p></li>
<li><p>In a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>)</p></li>
<li><p>To the left of the <code>.</code> in a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>)</p></li>
<li><p>To the left of the <code>.</code> in a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>To the left of the <code>(</code> in a constructor declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>)</p></li>
<li><p>After the <code>@</code> sign in an annotation (<a href="#jls-9.7">9.7</a>)</p></li>
<li><p>To the left of <code>.class</code> in a class literal (<a href="#jls-15.8.2">15.8.2</a>)</p></li>
<li><p>To the left of <code>.this</code> in a qualified <code>this</code> expression (<a href="#jls-15.8.4">15.8.4</a>)</p></li>
<li><p>To the left of <code>.super</code> in a qualified superclass field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11.2">15.11.2</a>)</p></li>
<li><p>To the left of <code>.</code><em>Identifier</em> or <code>.super.</code><em>Identifier</em> in a qualified method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>To the left of <code>.super::</code> in a method reference expression (<a href="#jls-15.13">15.13</a>)</p></li>
</ol></li>
<li><p>As the <em>Identifier</em> or dotted <em>Identifier</em> sequence that constitutes any <em>ReferenceType</em> (including a <em>ReferenceType</em> to the left of the brackets in an array type, or to the left of the &lt; in a parameterized type, or in a non-wildcard type argument of a parameterized type, or in an <code>extends</code> or <code>super</code> clause of a wildcard type argument of a parameterized type) in the 16 contexts where types are used (<a href="#jls-4.11">4.11</a>):</p>
<ol type="1">
<li><p>In an <code>extends</code> or <code>implements</code> clause of a class declaration (<a href="#jls-8.1.4">8.1.4</a>, <a href="#jls-8.1.5">8.1.5</a>, <a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>)</p></li>
<li><p>In an <code>extends</code> clause of an interface declaration (<a href="#jls-9.1.3">9.1.3</a>)</p></li>
<li><p>The return type of a method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>) (including the type of an element of an annotation <del>type</del> <strong>interface</strong> (<a href="#jls-9.6.1">9.6.1</a>))</p></li>
<li><p>In the <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>In an <code>extends</code> clause of a type parameter declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>The type in a field declaration of a class or interface (<a href="#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a>)</p></li>
<li><p>The type in a formal parameter declaration of a method, constructor, or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>The type of the receiver parameter of a method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p>The type in a local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>A type in an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
<li><p>In an explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression (<a href="#jls-8.8.7.1">8.8.7.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>In an unqualified class instance creation expression, either as the class type to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>) or as the direct superclass or direct superinterface of an anonymous class to be instantiated (<a href="#jls-15.9.5">15.9.5</a>)</p></li>
<li><p>The element type in an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>The type in the cast operator of a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>The type that follows the <code>instanceof</code> relational operator (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.20.2">15.20.2</a>)</p></li>
<li><p>In a method reference expression (<a href="#jls-15.13">15.13</a>), as the reference type to search for a member method or as the class type or array type to construct.</p></li>
</ol></li>
</ul>
<blockquote>
<p>The extraction of a <em>TypeName</em> from the identifiers of a <em>ReferenceType</em> in the 16 contexts above is intended to apply recursively to all sub-terms of the <em>ReferenceType</em>, such as its element type and any type arguments.</p>
<p>For example, suppose a field declaration uses the type <code>p.q.Foo[]</code>. The brackets of the array type are ignored, and the term <code>p.q.Foo</code> is extracted as a dotted sequence of <em>Identifiers</em> to the left of the brackets in an array type, and classified as a <em>TypeName</em>. A later step determines which of <code>p</code>, <code>q</code>, and <code>Foo</code> is a type name or a package name.</p>
<p>As another example, suppose a cast operator uses the type <code>p.q.Foo&lt;? extends String&gt;</code>. The term <code>p.q.Foo</code> is again extracted as a dotted sequence of <em>Identifier</em> terms, this time to the left of the <code>&lt;</code> in a parameterized type, and classified as a <em>TypeName</em>. The term <code>String</code> is extracted as an <em>Identifier</em> in an <code>extends</code> clause of a wildcard type argument of a parameterized type, and classified as a <em>TypeName</em>.</p>
</blockquote>
<p>A name is syntactically classified as an <em>ExpressionName</em> in these contexts:</p>
<ul>
<li><p>As the qualifying expression in a qualified superclass constructor invocation (<a href="#jls-8.8.7.1">8.8.7.1</a>)</p></li>
<li><p>As the qualifying expression in a qualified class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>)</p></li>
<li><p>As the array reference expression in an array access expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.10.3">15.10.3</a>)</p></li>
<li><p>As a <em>PostfixExpression</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.14">15.14</a>)</p></li>
<li><p>As the left-hand operand of an assignment operator (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.26">15.26</a>)</p></li>
<li><p>As a <em>VariableAccess</em> in a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
</ul>
<p>A name is syntactically classified as a <em>MethodName</em> in this context:</p>
<ul>
<li>Before the &quot;<code>(</code>&quot; in a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>)</li>
</ul>
<p>A name is syntactically classified as a <em>PackageOrTypeName</em> in these contexts:</p>
<ul>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>TypeName</em></p></li>
<li><p>In a type-import-on-demand declaration (<a href="#jls-7.5.2">7.5.2</a>)</p></li>
</ul>
<p>A name is syntactically classified as an <em>AmbiguousName</em> in these contexts:</p>
<ul>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>ExpressionName</em></p></li>
<li><p>To the left of the rightmost <code>.</code> that occurs before the &quot;<code>(</code>&quot; in a method invocation expression</p></li>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>AmbiguousName</em></p></li>
<li><p>In the default value clause of an annotation <del>type</del> element declaration (<a href="#jls-9.6.2">9.6.2</a>)</p></li>
<li><p>To the right of an &quot;<code>=</code>&quot; in an an element-value pair (<a href="#jls-9.7.1">9.7.1</a>)</p></li>
<li><p>To the left of <code>::</code> in a method reference expression (<a href="#jls-15.13">15.13</a>)</p></li>
</ul>
<blockquote>
<p>The effect of syntactic classification is to restrict certain kinds of entities to certain parts of expressions:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The name of a field, parameter, or local variable may be used as an expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.14.1">15.14.1</a>).</p></li>
<li><p>The name of a method may appear in an expression only as part of a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>).</p></li>
<li><p>The name of a class or interface <del>type</del> may appear in an expression only as part of a class literal (<a href="#jls-15.8.2">15.8.2</a>), a qualified <code>this</code> expression (<a href="#jls-15.8.4">15.8.4</a>), a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>), an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.10.1">15.10.1</a>), a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.16">15.16</a>), an <code>instanceof</code> expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.20.2">15.20.2</a>), an enum constant (<a href="#jls-8.9">8.9</a>), or as part of a qualified name for a field or method.</p></li>
<li><p>The name of a package may appear in an expression only as part of a qualified name for a class or interface <del>type</del>.</p></li>
</ul>
</blockquote>
<h4 id="jls-6.5.4">6.5.4 Meaning of <em>PackageOrTypeNames</em></h4>
<h5 id="jls-6.5.4.1">6.5.4.1 Simple <em>PackageOrTypeNames</em></h5>
<p>If the <em>PackageOrTypeName</em>, <em>Q</em>, is a valid <em>TypeIdentifier</em> and occurs in the scope of a <del>type</del> <strong>class, interface, or type parameter</strong> named <em>Q</em>, then the <em>PackageOrTypeName</em> is reclassified as a <em>TypeName</em>.</p>
<p>Otherwise, the <em>PackageOrTypeName</em> is reclassified as a <em>PackageName</em>. The meaning of the <em>PackageOrTypeName</em> is the meaning of the reclassified name.</p>
<h5 id="jls-6.5.4.2">6.5.4.2 Qualified <em>PackageOrTypeNames</em></h5>
<p>Given a qualified <em>PackageOrTypeName</em> of the form <em>Q.Id</em>, if <em>Id</em> is a valid <em>TypeIdentifier</em> and the <del>type</del> <strong>class, interface, type parameter,</strong> or package denoted by <em>Q</em> has a member <del>type</del> <strong>class or interface</strong> named <em>Id</em>, then the qualified <em>PackageOrTypeName</em> name is reclassified as a <em>TypeName</em>.</p>
<p>Otherwise, it is reclassified as a <em>PackageName</em>. The meaning of the qualified <em>PackageOrTypeName</em> is the meaning of the reclassified name.</p>
<h4 id="jls-6.5.5">6.5.5 Meaning of Type Names</h4>
<p>The meaning of a name classified as a <em>TypeName</em> is determined as follows.</p>
<h5 id="jls-6.5.5.1">6.5.5.1 Simple Type Names</h5>
<p>If a type name consists of a single <em>Identifier</em>, then the identifier must occur in the scope of exactly one declaration of a <del>type</del> <strong>class, interface, or type parameter</strong> with this name (<a href="#jls-6.3">6.3</a>), or a compile-time error occurs.</p>
<p>The meaning of the type name is that <del>type</del> <strong>class, interface, or type parameter</strong>.</p>
<h5 id="jls-6.5.5.2">6.5.5.2 Qualified Type Names</h5>
<p>If a type name is of the form <em>Q.Id</em>, then <em>Q</em> must be either the name of a <del>type in a package uniquely visible to the current module</del> <strong>class, interface, or type parameter</strong>, or the name of a package uniquely visible to the current module (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.3">7.4.3</a>).</p>
<div class="editorial">
<p>If an enclosing class, interface, or type parameter has a resolvable name, it shouldn't matter whether its package is uniquely visible, or even whether it is a member of a package at all (e.g., local classes and type parameters are not package members).</p>
</div>
<p>If <em>Id</em> names exactly one accessible <del>type</del> <strong>class or interface</strong> (<a href="#jls-6.6">6.6</a>) that is a member of the <del>type</del> <strong>class, interface, type parameter,</strong> or package denoted by <em>Q</em>, then the qualified type name denotes that <del>type</del> <strong>class or interface</strong>.</p>
<p>If <em>Id</em> does not name a member <del>type</del> <strong>class or interface</strong> within <em>Q</em> (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>), or the member <del>type</del> <strong>class or interface</strong> named <em>Id</em> within <em>Q</em> is not accessible (<a href="#jls-6.6">6.6</a>), or <em>Id</em> names more than one member <del>type</del> <strong>class or interface</strong> within <em>Q</em>, then a compile-time error occurs.</p>
<div class="example">
<p>Example 6.5.5.2-1. Qualified Type Names</p>
<pre><code>class Test {
    public static void main(String[] args) {
        java.util.Date date =
            new java.util.Date(System.currentTimeMillis());
        System.out.println(date.toLocaleString());
    }
}</code></pre>
<p>This program produced the following output the first time it was run:</p>
<pre><code>Sun Jan 21 22:56:29 1996</code></pre>
<p>In this example, the name <code>java.util.Date</code> must denote a type, so we first use the procedure recursively to determine if <code>java.util</code> is an accessible <del>type</del> <strong>class, interface, or type parameter,</strong> or a package, which it is, and then look to see if the type <code>Date</code> is accessible in this package.</p>
</div>
<h3 id="jls-6.6">6.6 Access Control</h3>
<p>The Java programming language provides mechanisms for <em>access control</em>, to prevent the users of a package or class from depending on unnecessary details of the implementation of that package or class. If access is permitted, then the accessed entity is said to be <em>accessible</em>.</p>
<p>Note that accessibility is a static property that can be determined at compile time; it depends only on types and declaration modifiers.</p>
<p>Qualified names are a means of access to members of packages<strong>, classes, interfaces, type parameters,</strong> and reference types. When the name of such a member is classified from its context (<a href="#jls-6.5.1">6.5.1</a>) as a qualified type name (denoting a member of a package<strong>,</strong> <del>or reference type</del> <strong>class, interface, or type parameter</strong>, <a href="#jls-6.5.5.2">6.5.5.2</a>) or a qualified expression name (denoting a member of a reference type, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.6.2">6.5.6.2</a>), access control is applied.</p>
<blockquote>
<p>For example, a single-type-import declaration uses a qualified type name (<a href="#jls-7.5.1">7.5.1</a>), so the named <del>type</del> <strong>class or interface</strong> must be accessible from the compilation unit containing the <code>import</code> declaration. As another example, a class declaration may use a qualified type name for a superclass <strong>type</strong> (<a href="#jls-8.1.5">8.1.5</a>), so again the named <del>type</del> <strong>class</strong> must be accessible.</p>
</blockquote>
<blockquote>
<p>Some obvious expressions are &quot;missing&quot; from context classification in <a href="#jls-6.5.1">6.5.1</a>: field access on a <em>Primary</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.11.1">15.11.1</a>), method invocation on a <em>Primary</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>), method reference via a <em>Primary</em> (<a href="#jls-15.13">15.13</a>), and the instantiated class in a qualified class instance creation (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>). Each of these expressions uses identifiers, rather than names, for the reason given in <a href="#jls-6.2">6.2</a>. Consequently, access control to members (whether fields, methods, <del>or types</del> <strong>classes, or interfaces</strong>) is applied <em>explicitly</em> by field access expressions, method invocation expressions, method reference expressions, and qualified class instance creation expressions. (Note that access to a field may also be denoted by a qualified name occuring as a postfix expression.)</p>
</blockquote>
<blockquote>
<p>In addition, many statements and expressions allow the use of types <del>rather than</del> <strong>that are not expressed exclusively with</strong> type names. For example, a class declaration may use a parameterized type (<a href="#jls-4.5">4.5</a>) to denote a superclass <strong>type</strong>. Because a parameterized type is not a qualified type name, it is necessary for the class declaration to explicitly perform access control for the denoted superclass. Consequently, most of the statements and expressions that provide contexts in <a href="#jls-6.5.1">6.5.1</a> to classify a <em>TypeName</em> also perform their own access control checks.</p>
</blockquote>
<blockquote>
<p>Beyond access to members of a package<strong>,</strong> <del>or reference type</del> <strong>class, interface, or type parameter</strong>, there is the matter of access to constructors of a <del>reference type</del> <strong>class</strong>. Access control must be checked when a constructor is invoked explicitly or implicitly. Consequently, access control is checked by an explicit constructor invocation statement (<a href="#jls-8.8.7.1">8.8.7.1</a>) and by a class instance creation expression (<a href="#jls-15.9.3">15.9.3</a>). Such checks are necessary because <a href="#jls-6.5.1">6.5.1</a> has no mention of explicit constructor invocation statements (because they reference constructor names indirectly) and is unaware of the distinction between the class <del>type</del> denoted by an unqualified class instance creation expression and a constructor of that class <del>type</del>. Also, constructors do not have qualified names, so we cannot rely on access control being checked during classification of qualified type names.</p>
</blockquote>
<blockquote>
<p>Accessibility affects inheritance of class members (<a href="#jls-8.2">8.2</a>), including hiding and method overriding (<a href="#jls-8.4.8.1">8.4.8.1</a>).</p>
</blockquote>
<h2 id="jls-7">Chapter 7: Packages and Modules</h2>
<h3 id="jls-7.3">7.3 Compilation Units</h3>
<p><em>CompilationUnit</em> is the goal symbol (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-2.html#jls-2.1">2.1</a>) for the syntactic grammar (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-2.html#jls-2.3">2.3</a>) of Java programs. It is defined by the following production:</p>
<dl>
<dt><em>CompilationUnit:</em></dt>
<dd><em>OrdinaryCompilationUnit</em>
</dd>
<dd><em>ModularCompilationUnit</em>
</dd>
<dt><em>OrdinaryCompilationUnit:</em></dt>
<dd>[<em>PackageDeclaration</em>] {<em>ImportDeclaration</em>} { <del><em>TypeDeclaration</em></del> <strong><em>TopLevelClassOrInterfaceDeclaration</em></strong> }
</dd>
<dt><em>ModularCompilationUnit:</em></dt>
<dd>{<em>ImportDeclaration</em>} <em>ModuleDeclaration</em>
</dd>
</dl>
<p>An <em>ordinary compilation unit</em> consists of three parts, each of which is optional:</p>
<ul>
<li><p>A <code>package</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4">7.4</a>), giving the fully qualified name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>) of the package to which the compilation unit belongs.</p>
<p>A compilation unit that has no <code>package</code> declaration is part of an unnamed package (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.2">7.4.2</a>).</p></li>
<li><p><code>import</code> declarations (<a href="#jls-7.5">7.5</a>) that allow <del>types</del> <strong>classes and interfaces</strong> from other packages and <code>static</code> members of <del>types</del> <strong>classes and interfaces</strong> to be referred to using their simple names.</p></li>
<li><p>Top level <del>type</del> declarations <del>(<a href="#jls-7.6">7.6</a>)</del> of <del>class and interface types</del> <strong>classes and interfaces (<a href="#jls-7.6">7.6</a>)</strong>.</p></li>
</ul>
<p>A <em>modular compilation unit</em> consists of a <code>module</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7">7.7</a>), optionally preceded by <code>import</code> declarations. The <code>import</code> declarations allow <del>types</del> <strong>classes and interfaces</strong> from packages in this module and other modules, as well as <code>static</code> members of <del>types</del> <strong>classes and interfaces</strong>, to be referred to using their simple names within the <code>module</code> declaration.</p>
<p>Every compilation unit implicitly imports every <code>public</code> <del>type</del> <strong>class or interface</strong> name declared in the predefined package <code>java.lang</code>, as if the declaration <code>import java.lang.*;</code> appeared at the beginning of each compilation unit immediately after any <code>package</code> declaration. As a result, the names of all those <del>types</del> <strong>classes and interfaces</strong> are available as simple names in every compilation unit.</p>
<p>The host system determines which compilation units are <em>observable</em>, except for the compilation units in the predefined package <code>java</code> and its subpackages <code>lang</code> and <code>io</code>, which are all always observable.</p>
<p>Each observable compilation unit may be <em>associated</em> with a module, as follows:</p>
<ul>
<li><p>The host system may determine that an observable ordinary compilation unit is associated with a module chosen by the host system, except for (i) the ordinary compilation units in the predefined package <code>java</code> and its subpackages <code>lang</code> and <code>io</code>, which are all associated with the <code>java.base</code> module, and (ii) any ordinary compilation unit in an unnamed package, which is associated with a module as specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.2">7.4.2</a>.</p></li>
<li><p>The host system must determine that an observable modular compilation unit is associated with the module declared by the modular compilation unit.</p></li>
</ul>
<blockquote>
<p>The observability of a compilation unit influences the observability of its package (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.3">7.4.3</a>), while the association of an observable compilation unit with a module influences the observability of that module (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.6">7.7.6</a>).</p>
</blockquote>
<p>When compiling the modular and ordinary compilation units associated with a module <em>M</em>, the host system must respect the dependences specified in <em>M</em>'s declaration. Specifically, the host system must limit the ordinary compilation units that would otherwise be observable, to only those that are <em>visible to M</em>. The ordinary compilation units that are visible to <em>M</em> are the observable ordinary compilation units associated with the modules that are <em>read by M</em>. The modules read by <em>M</em> are given by the result of <em>resolution</em>, as described in the <code>java.lang.module</code> package specification, with <em>M</em> as the only root module. The host system must perform resolution to determine the modules read by <em>M</em>; it is a compile-time error if resolution fails for any of the reasons described in the <code>java.lang.module</code> package specification.</p>
<blockquote>
<p>The readability relation is reflexive, so <em>M</em> reads itself, and thus all of the modular and ordinary compilation units associated with <em>M</em> are visible to <em>M</em>.</p>
</blockquote>
<blockquote>
<p>The modules read by <em>M</em> drive the packages that are uniquely visible to <em>M</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.3">7.4.3</a>), which in turn drives both the top level packages in scope and the meaning of package names for code in the modular and ordinary compilation units associated with <em>M</em> (<a href="#jls-6.3">6.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.3">6.5.3</a>, <a href="#jls-6.5.5">6.5.5</a>).</p>
</blockquote>
<blockquote>
<p>The rules above ensure that <del>package/type</del> names used in annotations in a modular compilation unit (in particular, annotations applied to the module declaration) are interpreted as if they appeared in an ordinary compilation unit associated with the module.</p>
</blockquote>
<p><del>Types</del> <strong>Classes and interfaces</strong> declared in different ordinary compilation units can refer to each other, circularly. A Java compiler must arrange to compile all such <del>types</del> <strong>classes and interfaces</strong> at the same time.</p>
<h3 id="jls-7.5">7.5 Import Declarations</h3>
<p>An <em>import declaration</em> allows a named <del>type or a</del> <strong>class, interface, or</strong> <code>static</code> member to be referred to by a simple name (<a href="#jls-6.2">6.2</a>) that consists of a single identifier.</p>
<p>Without the use of an appropriate import declaration, <del>the only way to refer to a type</del> <strong>a reference to a class or interface</strong> declared in another package, or a <code>static</code> member of another <del>type</del> <strong>class or interface</strong>, <del>is</del> <strong>would typically need</strong> to use a fully qualified name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>).</p>
<div class="editorial">
<p>Problems with the original claim:</p>
<ul>
<li><p>A member class could be accessed with a <em>partially</em> qualified name by importing its declaring class.</p></li>
<li><p>Members of a superclass are in scope via inheritance, without any need to import them.</p></li>
</ul>
</div>
<dl>
<dt><em>ImportDeclaration:</em></dt>
<dd><em>SingleTypeImportDeclaration</em>
</dd>
<dd><em>TypeImportOnDemandDeclaration</em>
</dd>
<dd><em>SingleStaticImportDeclaration</em>
</dd>
<dd><em>StaticImportOnDemandDeclaration</em>
</dd>
</dl>
<ul>
<li><p>A single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>) imports a single named <del>type</del> <strong>class or interface</strong>, by mentioning its canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>A type-import-on-demand declaration (<a href="#jls-7.5.2">7.5.2</a>) imports all the accessible <del>types</del> <strong>classes and interfaces</strong> of a named <del>type or named</del> package<strong>, class, or interface</strong> as needed, by mentioning the canonical name of a <del>type or</del> package<strong>, class, or interface</strong>.</p></li>
<li><p>A single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>) imports all accessible <code>static</code> members with a given name from a <del>type</del> <strong>class or interface</strong>, by giving its canonical name.</p></li>
<li><p>A static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>) imports all accessible <code>static</code> members of a named <del>type</del> <strong>class or interface</strong> as needed, by mentioning the canonical name of a <del>type</del> <strong>class or interface</strong>.</p></li>
</ul>
<p>The scope and shadowing of a <del>type</del> <strong>class, interface,</strong> or member imported by these declarations is specified in <a href="#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<blockquote>
<p>An <code>import</code> declaration makes <del>types</del> <strong>classes, interfaces,</strong> or members available by their simple names only within the compilation unit that actually contains the <code>import</code> declaration. The scope of the <del>type(s)</del> <strong>class(es), interface(s),</strong> or member(s) introduced by an <code>import</code> declaration specifically does not include other compilation units in the same package, other <code>import</code> declarations in the current compilation unit, or a <code>package</code> declaration in the current compilation unit (except for the annotations of a <code>package</code> declaration).</p>
</blockquote>
<h4 id="jls-7.5.1">7.5.1 Single-Type-Import Declarations</h4>
<p>A <em>single-type-import declaration</em> imports a single <del>type</del> <strong>class or interface</strong> by giving its canonical name, making it available under a simple name in the module, class, and interface declarations of the compilation unit in which the single-type-import declaration appears.</p>
<dl>
<dt><em>SingleTypeImportDeclaration:</em></dt>
<dd><code>import</code> <em>TypeName</em> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name of a class <del>type, interface type, enum type, or annotation type</del> <strong>or interface</strong> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>).</p>
<p>The <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="#jls-6.6">6.6</a>).</p>
<p>If two single-type-import declarations in the same compilation unit attempt to import <del>types</del> <strong>classes or interfaces</strong> with the same simple name, then a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<p>If the <del>type</del> <strong>class or interface</strong> imported by the single-type-import declaration is declared in the compilation unit that contains the <code>import</code> declaration, the <code>import</code> declaration is ignored.</p>
<p>If a single-type-import declaration imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and the compilation unit also declares a top level <del>type</del> <strong>class or interface</strong> (<a href="#jls-7.6">7.6</a>) whose simple name is <em>n</em>, a compile-time error occurs.</p>
<p>If a compilation unit contains both a single-type-import declaration that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>) that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<div class="example">
<p>Example 7.5.1-1. Single-Type-Import</p>
<pre><code>import java.util.Vector;</code></pre>
<p>causes the simple name <code>Vector</code> to be available within the class and interface declarations in a compilation unit. Thus, the simple name <code>Vector</code> refers to the <del>type</del> <strong>class</strong> declaration <code>Vector</code> in the package <code>java.util</code> in all places where it is not shadowed (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) or obscured (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.2">6.4.2</a>) by a declaration of a field, parameter, local variable, or nested <del>type</del> <strong>class or interface</strong> declaration with the same name.</p>
<p>Note that the actual declaration of <code>java.util.Vector</code> is generic (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>). Once imported, the name <code>Vector</code> can be used without qualification in a parameterized type such as <code>Vector&lt;String&gt;</code>, or as the raw type <code>Vector</code>. A related limitation of the <code>import</code> declaration is that a <del>nested type</del> <strong>member class or interface</strong> declared inside a generic <del>type</del> <strong>class or interface</strong> declaration can be imported, but its outer type is always erased.</p>
</div>
<div class="example">
<p>Example 7.5.1-2. Duplicate <del>Type</del> <strong>Class or Interface</strong> Declarations</p>
<p>This program:</p>
<pre><code>import java.util.Vector;
class Vector { Object[] vec; }</code></pre>
<p>causes a compile-time error because of the duplicate declaration of <code>Vector</code>, as does:</p>
<pre><code>import java.util.Vector;
import myVector.Vector;</code></pre>
<p>where <code>myVector</code> is a package containing the compilation unit:</p>
<pre><code>package myVector;
public class Vector { Object[] vec; }</code></pre>
</div>
<div class="example">
<p>Example 7.5.1-3. No Import of a Subpackage</p>
<p>Note that an <code>import</code> declaration cannot import a subpackage, only a <del>type</del> <strong>class or interface</strong>.</p>
<p>For example, it does not work to try to import <code>java.util</code> and then use the name <code>util.Random</code> to refer to the type <code>java.util.Random</code>:</p>
<pre><code>import java.util;
class Test { util.Random generator; }
  // incorrect: compile-time error</code></pre>
</div>
<div class="example">
<p>Example 7.5.1-4. Importing a Type Name that is also a Package Name</p>
<p>Package names and type names are usually different under the naming conventions described in <a href="#jls-6.1">6.1</a>. Nevertheless, in a contrived example where there is an unconventionally-named package <code>Vector</code>, which declares a public class whose name is <code>Mosquito</code>:</p>
<pre><code>package Vector;
public class Mosquito { int capacity; }</code></pre>
<p>and then the compilation unit:</p>
<pre><code>package strange;
import java.util.Vector;
import Vector.Mosquito;
class Test {
    public static void main(String[] args) {
        System.out.println(new Vector().getClass());
        System.out.println(new Mosquito().getClass());
    }
}</code></pre>
<p>the single-type-import declaration importing class <code>Vector</code> from package <code>java.util</code> does not prevent the package name <code>Vector</code> from appearing and being correctly recognized in subsequent <code>import</code> declarations. The example compiles and produces the output:</p>
<pre><code>class java.util.Vector
class Vector.Mosquito</code></pre>
</div>
<h4 id="jls-7.5.2">7.5.2 Type-Import-on-Demand Declarations</h4>
<p>A <em>type-import-on-demand declaration</em> allows all accessible <del>types</del> <strong>classes and interfaces</strong> of a named package<strong>, class, or interface</strong> <del>or type</del> to be imported as needed.</p>
<dl>
<dt><em>TypeImportOnDemandDeclaration:</em></dt>
<dd><code>import</code> <em>PackageOrTypeName</em> <code>.</code> <code>*</code> <code>;</code>
</dd>
</dl>
<p>The <em>PackageOrTypeName</em> must be the canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>) of a package, a class <del>type</del>, <strong>or</strong> an interface <del>type, an enum type, or an annotation type</del>.</p>
<p>If the <em>PackageOrTypeName</em> denotes a <del>type</del> <strong>class or interface</strong> (<a href="#jls-6.5.4">6.5.4</a>), then the <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named package is not uniquely visible to the current module (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.3">7.4.3</a>), or if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="#jls-6.6">6.6</a>).</p>
<p>It is not a compile-time error to name either <code>java.lang</code> or the named package of the current compilation unit in a type-import-on-demand declaration. The type-import-on-demand declaration is ignored in such cases.</p>
<p>Two or more type-import-on-demand declarations in the same compilation unit may name the same <del>type or</del> package<strong>, class, or interface</strong>. All but one of these declarations are considered redundant; the effect is as if that type was imported only once.</p>
<p>If a compilation unit contains both a type-import-on-demand declaration and a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>) that name the same <del>type</del> <strong>class or interface</strong>, the effect is as if the <code>static</code> member <del>types</del> <strong>classes and interfaces</strong> of that <del>type</del> <strong>class or interface</strong> (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>) were imported only once.</p>
<div class="example">
<p>Example 7.5.2-1. Type-Import-on-Demand</p>
<pre><code>import java.util.*;</code></pre>
<p>causes the simple names of all <code>public</code> <del>types</del> <strong>classes and interfaces</strong> declared in the package <code>java.util</code> to be available within the class and interface declarations of the compilation unit. Thus, the simple name <code>Vector</code> refers to the <del>type</del> <strong>class</strong> <code>Vector</code> <del>in</del> <strong>of</strong> the package <code>java.util</code> in all places in the compilation unit where that <del>type</del> <strong>class</strong> declaration is not shadowed (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) or obscured (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.2">6.4.2</a>).</p>
<p>The declaration might be shadowed by a single-type-import declaration of a <del>type</del> <strong>class or interface</strong> whose simple name is <code>Vector</code>; by a <del>type</del> <strong>class or interface</strong> named <code>Vector</code> and declared in the package to which the compilation unit belongs; or any nested classes or interfaces.</p>
<p>The declaration might be obscured by a declaration of a field, parameter, or local variable named <code>Vector</code>.</p>
<p>(It would be unusual for any of these conditions to occur.)</p>
</div>
<h4 id="jls-7.5.3">7.5.3 Single-Static-Import Declarations</h4>
<p>A <em>single-static-import declaration</em> imports all accessible <code>static</code> members with a given simple name from a <del>type</del> <strong>class or interface</strong>. This makes these <code>static</code> members available under their simple name in the module, class, and interface declarations of the compilation unit in which the single-static-import declaration appears.</p>
<dl>
<dt><em>SingleStaticImportDeclaration:</em></dt>
<dd><code>import</code> <code>static</code> <em>TypeName</em> <code>.</code> <em>Identifier</em> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>) of a class <del>type, interface type, enum type, or annotation type</del> <strong>or interface</strong>.</p>
<p>The <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="#jls-6.6">6.6</a>).</p>
<p>The <em>Identifier</em> must name at least one <code>static</code> member of the named <del>type</del> <strong>class or interface</strong>. It is a compile-time error if there is no <code>static</code> member of that name, or if all of the named members are not accessible.</p>
<p>It is permissible for one single-static-import declaration to import several fields<strong>, classes, or interfaces</strong> <del>or types</del> with the same name, or several methods with the same name and signature. This occurs when the named <del>type</del> <strong>class or interface</strong> inherits multiple fields, member <del>types</del> <strong>classes, member interfaces</strong>, or methods, all with the same name, from its own supertypes.</p>
<p>If two single-static-import declarations in the same compilation unit attempt to import <del>types</del> <strong>classes or interfaces</strong> with the same simple name, then a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<p>If a single-static-import declaration imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and the compilation unit also declares a top level <del>type</del> <strong>class or interface</strong> (<a href="#jls-7.6">7.6</a>) whose simple name is <em>n</em>, a compile-time error occurs.</p>
<p>If a compilation unit contains both a single-static-import declaration that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>) that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<h4 id="jls-7.5.4">7.5.4 Static-Import-on-Demand Declarations</h4>
<p>A <em>static-import-on-demand declaration</em> allows all accessible <code>static</code> members of a named <del>type</del> <strong>class or interface</strong> to be imported as needed.</p>
<dl>
<dt><em>StaticImportOnDemandDeclaration:</em></dt>
<dd><code>import</code> <code>static</code> <em>TypeName</em> <code>.</code> <code>*</code> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>) of a class <del>type, interface type, enum type, or annotation type</del> <strong>or interface</strong>.</p>
<p>The <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="#jls-6.6">6.6</a>).</p>
<p>Two or more static-import-on-demand declarations in the same compilation unit may name the same <del>type</del> <strong>class or interface</strong>; the effect is as if there was exactly one such declaration.</p>
<p>Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once.</p>
<p>It is permissible for one static-import-on-demand declaration to import several fields<strong>, classes, or interfaces</strong> <del>or types</del> with the same name, or several methods with the same name and signature. This occurs when the named <del>type</del> <strong>class or interface</strong> inherits multiple fields, member <del>types</del> <strong>classes, member interfaces</strong>, or methods, all with the same name, from its own supertypes.</p>
<p>If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand declaration (<a href="#jls-7.5.2">7.5.2</a>) that name the same <del>type</del> <strong>class or interface</strong>, the effect is as if the <code>static</code> member <del>types</del> <strong>classes and interfaces</strong> of that <del>type</del> <strong>class or interface</strong> (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>) were imported only once.</p>
<h3 id="jls-7.6">7.6 Top Level <del>Type</del> <strong>Class and Interface</strong> Declarations</h3>
<p>A <em>top level <del>type</del> <strong>class or interface</strong> declaration</em> declares a top level class <del>type</del> (<del><a href="#jls-8">8</a></del> <strong><a href="#jls-8.1">8.1</a></strong>) or a top level interface <del>type</del> (<del><a href="#jls-9">9</a></del> <strong><a href="#jls-9.1">9.1</a></strong>).</p>
<dl>
<dt><del><em>TypeDeclaration:</em></del> <strong><em>TopLevelClassOrInterfaceDeclaration:</em></strong></dt>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>InterfaceDeclaration</em>
</dd>
<dd><code>;</code>
</dd>
</dl>
<blockquote>
<p>Extra &quot;<code>;</code>&quot; tokens appearing at the level of <del>type</del> <strong>class or interface</strong> declarations in a compilation unit have no effect on the meaning of the compilation unit. Stray semicolons are permitted in the Java programming language solely as a concession to C++ programmers who are used to placing &quot;<code>;</code>&quot; after a class declaration. They should not be used in new Java code.</p>
</blockquote>
<p>In the absence of an access modifier, a top level <del>type</del> <strong>class or interface</strong> has package access: it is accessible only within ordinary compilation units of the package in which it is declared (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.6.1">6.6.1</a>). A <del>type</del> <strong>class or interface</strong> may be declared <code>public</code> to grant access to the <del>type</del> <strong>class or interface</strong> from code in other packages of the same module, and potentially from code in packages of other modules.</p>
<p>It is a compile-time error if a top level <del>type</del> <strong>class or interface</strong> declaration contains any one of the following access modifiers: <code>protected</code>, <code>private</code>, or <code>static</code>.</p>
<p>It is a compile-time error if the name of a top level <del>type</del> <strong>class or interface</strong> appears as the name of any other top level class or interface <del>type</del> declared in the same package.</p>
<p>The scope and shadowing of a top level <del>type</del> <strong>class or interface</strong> is specified in <a href="#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p>The fully qualified name of a top level <del>type</del> <strong>class or interface</strong> is specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>.</p>
<div class="example">
<p>Example 7.6-1. Conflicting Top Level <del>Type</del> <strong>Class or Interface</strong> Declarations</p>
<pre><code>package test;
import java.util.Vector;
class Point {
    int x, y;
}
interface Point {  // compile-time error #1
    int getR();
    int getTheta();
}
class Vector { Point[] pts; }  // compile-time error #2</code></pre>
<p>Here, the first compile-time error is caused by the duplicate declaration of the name <code>Point</code> as both a class and an interface in the same package. A second compile-time error is the attempt to declare the name <code>Vector</code> both by a class <del>type</del> declaration and by a single-type-import declaration.</p>
<p>Note, however, that it is not an error for the name of a class to also name a <del>type</del> <strong>class or interface</strong> that otherwise might be imported by a type-import-on-demand declaration (<a href="#jls-7.5.2">7.5.2</a>) in the compilation unit (<a href="#jls-7.3">7.3</a>) containing the class declaration. Thus, in this program:</p>
<pre><code>package test;
import java.util.*;
class Vector {}  // not a compile-time error</code></pre>
<p>the declaration of the class <code>Vector</code> is permitted even though there is also a class <code>java.util.Vector</code>. Within this compilation unit, the simple name <code>Vector</code> refers to the class <code>test.Vector</code>, not to <code>java.util.Vector</code> (which can still be referred to by code within the compilation unit, but only by its fully qualified name).</p>
</div>
<div class="example">
<p>Example 7.6-2. Scope of Top Level <del>Types</del> <strong>Classes and Interfaces</strong></p>
<pre><code>package points;
class Point {
    int x, y;           // coordinates
    PointColor color;   // color of this point
    Point next;         // next point with this color
    static int nPoints;
}
class PointColor {
    Point first;        // first point with this color
    PointColor(int color) { this.color = color; }
    private int color;  // color components
}</code></pre>
<p>This program defines two classes that use each other in the declarations of their class members. Because the <del>class types</del> <strong>classes</strong> <code>Point</code> and <code>PointColor</code> have all the <del>type</del> <strong>class</strong> declarations in package <code>points</code>, including all those in the current compilation unit, as their scope, this program compiles correctly. That is, forward reference is not a problem.</p>
</div>
<div class="example">
<p>Example 7.6-3. Fully Qualified Names</p>
<pre><code>class Point { int x, y; }</code></pre>
<p>In this code, the class <code>Point</code> is declared in a compilation unit with no <code>package</code> declaration, and thus <code>Point</code> is its fully qualified name, whereas in the code:</p>
<pre><code>package vista;
class Point { int x, y; }</code></pre>
<p>the fully qualified name of the class <code>Point</code> is <code>vista.Point</code>. (The package name <code>vista</code> is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name (<a href="#jls-6.1">6.1</a>).)</p>
</div>
<p>An implementation of the Java SE Platform must keep track of <del>types</del> <strong>classes and interfaces</strong> within packages by the combination of their enclosing module names and their binary names (<a href="#jls-13.1">13.1</a>). Multiple ways of naming a <del>type</del> <strong>class or interface</strong> must be expanded to binary names to make sure that such names are understood as referring to the same <del>type</del> <strong>class or interface</strong>.</p>
<blockquote>
<p>For example, if a compilation unit contains the single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>):</p>
<pre><code>import java.util.Vector;</code></pre>
<p>then within that compilation unit, the simple name <code>Vector</code> and the fully qualified name <code>java.util.Vector</code> refer to the same <del>type</del> <strong>class</strong>.</p>
</blockquote>
<p>If and only if packages are stored in a file system (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.2">7.2</a>), the host system may choose to enforce the restriction that it is a compile-time error if a <del>type</del> <strong>class or interface</strong> is not found in a file under a name composed of the <del>type</del> <strong>class or interface</strong> name plus an extension (such as <code>.java</code> or <code>.jav</code>) if either of the following is true:</p>
<ul>
<li><p>The <del>type</del> <strong>class or interface</strong> is referred to by code in other ordinary compilation units of the package in which the <del>type</del> <strong>class or interface</strong> is declared.</p></li>
<li><p>The <del>type</del> <strong>class or interface</strong> is declared <code>public</code> (and therefore is potentially accessible from code in other packages).</p></li>
</ul>
<blockquote>
<p>This restriction implies that there must be at most one such <del>type</del> <strong>class or interface</strong> per compilation unit. This restriction makes it easy for a Java compiler to find a named class <strong>or interface</strong> within a package. In practice, many programmers choose to put each class or interface <del>type</del> in its own compilation unit, whether or not it is <code>public</code> or is referred to by code in other compilation units.</p>
</blockquote>
<blockquote>
<p>For example, the source code for a <code>public</code> type <code>wet.sprocket.Toad</code> would be found in a file <code>Toad.java</code> in the directory <code>wet/sprocket</code>, and the corresponding object code would be found in the file <code>Toad.class</code> in the same directory.</p>
</blockquote>
<h3 id="jls-7.7">7.7 Module Declarations</h3>
<h4 id="jls-7.7.3">7.7.3 Service Consumption</h4>
<p>The <code>uses</code> directive specifies a <em>service</em> for which the current module may discover providers via <code>java.util.ServiceLoader</code>.</p>
<p><del>The service must be a class type, an interface type, or an annotation type.</del> It is a compile-time error if a <code>uses</code> directive specifies an enum <del>type</del> <strong>class</strong> (<a href="#jls-8.9">8.9</a>) as the service.</p>
<div class="editorial">
<p>As a resolvable <em>TypeName</em>, the service will be a class or interface. The only (and somewhat odd) extra constraint here is that it must not be an enum class.</p>
</div>
<p>The service may be declared in the current module or in another module. If the service is not declared in the current module, then the service must be accessible to code in the current module (<a href="#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>It is a compile-time error if more than one <code>uses</code> directive in a module declaration specifies the same service.</p>
<h4 id="jls-7.7.4">7.7.4 Service Provision</h4>
<p>The <code>provides</code> directive specifies a service for which the <code>with</code> clause specifies one or more <em>service providers</em> to <code>java.util.ServiceLoader</code>.</p>
<p><del>The service must be a class type, an interface type, or an annotation type.</del> It is a compile-time error if a <code>provides</code> directive specifies an enum <del>type</del> <strong>class</strong> (<a href="#jls-8.9">8.9</a>) as the service.</p>
<div class="editorial">
<p>See comment in <a href="#jls-7.7.3">7.7.3</a>.</p>
</div>
<p>The service may be declared in the current module or in another module. If the service is not declared in the current module, then the service must be accessible to code in the current module (<a href="#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>Every service provider must be a <strong><code>public</code></strong> class <del>type</del> or <del>an</del> interface <del>type, that is <code>public</code>, and</del> that is top level or <del>nested</del> <code>static</code>, or a compile-time error occurs.</p>
<div class="editorial">
<p>There will eventually be some ambiguity in what &quot;nested <code>static</code>&quot; means. We can resolve it by just eliminating the word &quot;nested&quot;—any <code>static</code> class or interface that can be successfully referenced is fine.</p>
</div>
<p>Every service provider must be declared in the current module, or a compile-time error occurs.</p>
<p>If a service provider explicitly declares a <code>public</code> constructor with no formal parameters, or implicitly declares a <code>public</code> default constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.9">8.8.9</a>), then that constructor is called the <em>provider constructor</em>.</p>
<p>If a service provider explicitly declares a <code>public</code> <code>static</code> method called <code>provider</code> with no formal parameters, then that method is called the <em>provider method</em>.</p>
<p>If a service provider has a provider method, then its return type must (i) either be declared in the current module, or be declared in another module and be accessible to code in the current module; and (ii) be a subtype of the service specified in the <code>provides</code> directive; or a compile-time error occurs.</p>
<blockquote>
<p>While a service provider that is specified by a <code>provides</code> directive must be declared in the current module, its provider method may have a return type that is declared in <em>another</em> module. Also, note that when a service provider declares a provider method, the service provider itself need not be a subtype of the service.</p>
</blockquote>
<p>If a service provider does not have a provider method, then that service provider must have a provider constructor and must be a subtype of the service specified in the <code>provides</code> directive, or a compile-time error occurs.</p>
<p>It is a compile-time error if more than one <code>provides</code> directive in a module declaration specifies the same service.</p>
<p>It is a compile-time error if the <code>with</code> clause of a given <code>provides</code> directive specifies the same service provider more than once.</p>
<h2 id="jls-8">Chapter 8: Classes</h2>
<p>Class declarations define new <del>reference types</del> <strong>classes</strong> and describe how they are implemented (<a href="#jls-8.1">8.1</a>).</p>
<p>A <em>top level class</em> <strong>(<a href="#jls-7.6">7.6</a>)</strong> is a class that is <del>not a nested class</del> <strong>declared at the top level of a compilation unit</strong>.</p>
<p>A <em>nested class</em> is any class whose declaration occurs within the body of another class or interface. <strong>A nested class may be a <em>member class</em> (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>), a <em>local class</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.3">14.3</a>), or an <em>anonymous class</em> (<a href="#jls-15.9.5">15.9.5</a>).</strong></p>
<p><strong>An <em>inner class</em> (<a href="#jls-8.1.3">8.1.3</a>) is a nested class that can refer to enclosing class instances, local variables, and type variables.</strong></p>
<p><strong>An <em>enum class</em> (<a href="#jls-8.9">8.9</a>) is a class declared with special syntax that defines a small set of named class instances.</strong></p>
<p>This chapter discusses the common semantics of all classes <del>- top level (<a href="#jls-7.6">7.6</a>) and nested (including member classes (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>), local classes (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.3">14.3</a>) and anonymous classes (<a href="#jls-15.9.5">15.9.5</a>))</del>. Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs.</p>
<p>A <del>named</del> class may be declared <code>abstract</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.1.1">8.1.1.1</a>) and must be declared abstract if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>), in which case it cannot have subclasses. <del>If a class is declared <code>public</code>, then it can be referred to from code in any package of its module and potentially from code in other modules.</del> <strong>A class can use access control (<a href="#jls-6.6">6.6</a>) to prevent references to the class from other classes, interfaces, packages, or modules.</strong> Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class (<a href="#jls-8.1.4">8.1.4</a>) and may implement interfaces (<a href="#jls-8.1.5">8.1.5</a>). Classes may be <em>generic</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>), that is, they may declare type variables whose bindings may differ among different instances of the class.</p>
<div class="editorial">
<p>Clarifications to better reflect the full domain of class declarations.</p>
</div>
<p>Classes may be decorated with annotations (<a href="#jls-9.7">9.7</a>) just like any other kind of declaration.</p>
<p>The body of a class declares members (fields<strong>,</strong> <del>and</del> methods<strong>,</strong> <del>and nested</del> classes<strong>,</strong> and interfaces), instance and static initializers, and constructors (<a href="#jls-8.1.6">8.1.6</a>). The scope (<a href="#jls-6.3">6.3</a>) of a member (<a href="#jls-8.2">8.2</a>) is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers (<a href="#jls-6.6">6.6</a>) <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members (<a href="#jls-8.2">8.2</a>). Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared <del>class members and interface members</del> <strong>member classes and interfaces</strong> can hide <del>class or interface members</del> <strong>member classes and interfaces</strong> declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.</p>
<p>Field declarations (<a href="#jls-8.3">8.3</a>) describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3.1.2">8.3.1.2</a>), in which case it can be assigned to only once. Any field declaration may include an initializer.</p>
<p>Member class declarations (<a href="#jls-8.5">8.5</a>) describe nested classes that are members of the surrounding class. Member classes may be <code>static</code><del>, in which case they have no access to the instance variables of the surrounding class;</del> or they may be inner classes <del>(<a href="#jls-8.1.3">8.1.3</a>)</del>.</p>
<div class="editorial">
<p>The earlier introduction of <em>inner classes</em> makes these details redundant.</p>
</div>
<p>Member interface declarations (<a href="#jls-8.5">8.5</a>) describe nested interfaces that are members of the surrounding class.</p>
<p>Method declarations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>) describe code that may be invoked by method invocation expressions (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>). A class method is invoked relative to the class <del>type</del>; an instance method is invoked with respect to some particular object that is an instance of a class <del>type</del>. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.3.3">8.4.3.3</a>), in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.3.4">8.4.3.4</a>). A <code>synchronized</code> method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.3.6">8.4.3.6</a>) automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.19">14.19</a>), thus allowing its activities to be synchronized with those of other threads (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html">17</a>).</p>
<p>Method names may be overloaded (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.9">8.4.9</a>).</p>
<p>Instance initializers (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.6">8.6</a>) are blocks of executable code that may be used to help initialize an instance when it is created (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>).</p>
<p>Static initializers (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.7">8.7</a>) are blocks of executable code that may be used to help initialize a class.</p>
<p>Constructors (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>) are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.8">8.8.8</a>).</p>
<h3 id="jls-8.1">8.1 Class Declarations</h3>
<p>A class declaration specifies <del>a new named reference type</del> <strong>a new class</strong>.</p>
<p>There are two kinds of class declarations: <em>normal class declarations</em> and <em>enum declarations</em>.</p>
<dl>
<dt><em>ClassDeclaration:</em></dt>
<dd><em>NormalClassDeclaration</em>
</dd>
<dd><em>EnumDeclaration</em>
</dd>
<dt><em>NormalClassDeclaration:</em></dt>
<dd>{<em>ClassModifier</em>} <code>class</code> <em>TypeIdentifier</em> [<em>TypeParameters</em>]<br />
[<del><em>Superclass</em></del> <strong><em>ClassExtends</em></strong>] [<del><em>Superinterfaces</em></del> <strong><em>ClassImplements</em></strong>] <em>ClassBody</em>
</dd>
</dl>
<div class="editorial">
<p>The productions could be named <em>SuperclassType</em> and <em>SuperinterfaceTypes</em>, but it seems appropriate to emphasize the keyword they use (compare the <em>Throws</em> production).</p>
</div>
<p><strong>A class is also implicitly declared by a <em>ClassInstanceCreationExpression</em> (<a href="#jls-15.9.5">15.9.5</a>) or <em>EnumConstant</em> (<a href="#jls-8.9.1">8.9.1</a>) that ends with a class body.</strong></p>
<div class="deleted">
<p>The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in <a href="#jls-8.9">8.9</a>.</p>
</div>
<div class="editorial">
<p>A discussion about how different declaration forms for classes (including enum declarations and anonymous class declarations) relate to the rules specified throughout Chapter 8 already appears in <a href="#jls-8">8</a>. It's confusing to repeat it here.</p>
</div>
<p>The <em>TypeIdentifier</em> in a class declaration specifies the name of the class.</p>
<p>It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The scope and shadowing of a class declaration is specified in <a href="#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<h4 id="jls-8.1.1">8.1.1 Class Modifiers</h4>
<p>A class declaration may include <em>class modifiers</em>.</p>
<dl>
<dt><em>ClassModifier:</em></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code> <code>protected</code> <code>private</code>
</dd>
<dd><code>abstract</code> <code>static</code> <code>final</code> <code>strictfp</code>
</dd>
</dl>
<p>The rules for annotation modifiers on a class declaration are specified in <a href="#jls-9.7.4">9.7.4</a> and <a href="#jls-9.7.5">9.7.5</a>.</p>
<p>The access modifier <code>public</code> (<a href="#jls-6.6">6.6</a>) pertains only to top level classes (<a href="#jls-7.6">7.6</a>) and member classes (<a href="#jls-8.5">8.5</a><strong>, <a href="#jls-9.5">9.5</a></strong>)<del>, not to local classes (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.3">14.3</a>) or anonymous classes (<a href="#jls-15.9.5">15.9.5</a>)</del>.</p>
<p>The <del>access</del> modifiers <code>protected</code><strong>,</strong> <del>and</del> <code>private</code><strong>, and <code>static</code></strong> pertain only to member classes <del>within a directly enclosing class declaration (<a href="#jls-8.5">8.5</a>)</del>.</p>
<p><del>The modifier <code>static</code> pertains only to member classes (<a href="#jls-8.5.1">8.5.1</a>), not to top level or local or anonymous classes.</del></p>
<div class="editorial">
<p>This is not the place for comprehensive lists and rules. The purpose of these sentences is to provide some cross references for readers who'd like to know how certain modifiers are used. More details can be found there.</p>
</div>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="#jls-6.6">6.6</a>).</p>
<blockquote>
<p>If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>ClassModifier</em>.</p>
</blockquote>
<h5 id="jls-8.1.1.3">8.1.1.3 <code>strictfp</code> Classes</h5>
<p>The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double</code> expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.4">15.4</a>).</p>
<p>This implies that all methods declared in the class, and all nested <del>types</del> <strong>classes and interfaces</strong> declared in the class, are implicitly <code>strictfp</code>.</p>
<h4 id="jls-8.1.3">8.1.3 Inner Classes and Enclosing Instances</h4>
<p>An <em>inner class</em> is a nested class that is not explicitly or implicitly declared <code>static</code>.</p>
<p>An inner class may be a non-<code>static</code> member class (<a href="#jls-8.5">8.5</a>), a local class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.3">14.3</a>), or an anonymous class (<a href="#jls-15.9.5">15.9.5</a>). A member class of an interface is implicitly <code>static</code> (<a href="#jls-9.5">9.5</a>) so is never considered to be an inner class.</p>
<p>It is a compile-time error if an inner class declares a static initializer (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.7">8.7</a>).</p>
<p>It is a compile-time error if an inner class declares a member that is explicitly or implicitly <code>static</code>, unless the member is a constant variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>An inner class may inherit <code>static</code> members that are not constant variables even though it cannot declare them.</p>
<p>A nested class that is not an inner class may declare <code>static</code> members freely, in accordance with the usual rules of the Java programming language.</p>
<div class="example">
<p>Example 8.1.3-1. Inner Class Declarations and Static Members</p>
<pre><code>class HasStatic {
    static int j = 100;
}
class Outer {
    class Inner extends HasStatic {
        static final int x = 3;  // OK: constant variable
        static int y = 4;  // Compile-time error: an inner class
    }
    static class NestedButNotInner{
        static int z = 5;    // OK: not an inner class
    }
    interface NeverInner {}  // Interfaces are never inner
}</code></pre>
</div>
<p>A statement or expression <em>occurs in a static context</em> if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement (<a href="#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>An inner class <em>C</em> is a <em>direct inner class of a class or interface O</em> if <em>O</em> is the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>C</em> and the declaration of <em>C</em> does not occur in a static context.</p>
<blockquote>
<p><strong>If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface.</strong></p>
</blockquote>
<p>A class <em>C</em> is an <em>inner class of class or interface O</em> if it is either a direct inner class of <em>O</em> or an inner class of an inner class of <em>O</em>.</p>
<blockquote>
<p>It is unusual, but possible, for the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of an inner class to be an interface. This only occurs if the class is <strong>a local or anonymous class</strong> declared in a default <strong>or static</strong> method body (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>). <del>Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body.</del></p>
</blockquote>
<div class="editorial">
<p>In that second example, the immediately enclosing class or interface declaration is the anonymous class, not the interface.</p>
</div>
<p>A class or interface <em>O</em> is the <em>zeroth lexically enclosing type declaration of itself</em>.</p>
<p>A class <em>O</em> is the <em>n'th lexically enclosing type declaration of a class C</em> if it is the immediately enclosing type declaration of the <em>n-1</em>'th lexically enclosing type declaration of <em>C</em>.</p>
<p>An instance <em>i</em> of a direct inner class <em>C</em> of a class or interface <em>O</em> is associated with an instance of <em>O</em>, known as the <em>immediately enclosing instance of i</em>. The immediately enclosing instance of an object, if any, is determined when the object is created (<a href="#jls-15.9.2">15.9.2</a>).</p>
<p>An object <em>o</em> is the <em>zeroth lexically enclosing instance of itself</em>.</p>
<p>An object <em>o</em> is the <em>n'th lexically enclosing instance of an instance i</em> if it is the immediately enclosing instance of the <em>n-1</em>'th lexically enclosing instance of <em>i</em>.</p>
<p>An instance of <del>an inner class <em>I</em></del> <strong>a local class or an anonymous class</strong> whose declaration occurs in a static context has no lexically enclosing instances. <del>However, if <em>I</em> is immediately declared within a static method or static initializer then <em>I</em> does have an <em>enclosing block</em>, which is the innermost block statement lexically enclosing the declaration of <em>I</em>.</del></p>
<div class="editorial">
<p>The term &quot;enclosing block&quot; is never used outside of this paragraph. This section already includes an overwhelming amount of new terminology, so we're better off without this additional definition.</p>
</div>
<p>For every superclass <em>S</em> of <em>C</em> which is itself a direct inner class of a class or interface <em>SO</em>, there is an instance of <em>SO</em> associated with <em>i</em>, known as the <em>immediately enclosing instance of i with respect to S</em>. The immediately enclosing instance of an object with respect to its class'<strong>s</strong> direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement (<a href="#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing <del>type</del> <strong>class or interface</strong> declaration, the variable of the corresponding lexically enclosing instance is used.</p>
<p>Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared <code>final</code> or be effectively final (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>), or a compile-time error occurs where the use is attempted.</p>
<p>Any local variable used but not declared in an inner class must be definitely assigned (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-16.html">16</a>) before the body of the inner class, or a compile-time error occurs.</p>
<blockquote>
<p>Similar rules on variable use apply in the body of a lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p>
</blockquote>
<p>A blank <code>final</code> field (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>) of a lexically enclosing <del>type</del> <strong>class or interface</strong> declaration may not be assigned within an inner class, or a compile-time error occurs.</p>
<div class="example">
<p>Example 8.1.3-2. Inner Class Declarations</p>
<pre><code>class Outer {
    int i = 100;
    static void classMethod() {
        final int l = 200;
        class LocalInStaticContext {
            int k = i;  // Compile-time error
            int m = l;  // OK
        }
    }
    void foo() {
        class Local {  // A local class
            int j = i;
        }
    }
}</code></pre>
<p>The declaration of class <code>LocalInStaticContext</code> occurs in a static context due to being within the static method <code>classMethod</code>. Instance variables of class <code>Outer</code> are not available within the body of a static method. In particular, instance variables of <code>Outer</code> are not available inside the body of <code>LocalInStaticContext</code>. However, local variables from the surrounding method may be referred to without error (provided they are declared <code>final</code> or are effectively final).</p>
<p>Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing <del>type</del> <strong>class</strong> declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing <del>type</del> <strong>class</strong> declaration, the instance variable must be defined with respect to an enclosing instance of <del>that declared type</del> <strong>the inner class</strong>. For example, the class <code>Local</code> above has an enclosing instance of class <code>Outer</code>. As a further example:</p>
<pre><code>class WithDeepNesting {
    boolean toBe;
    WithDeepNesting(boolean b) { toBe = b; }

    class Nested {
        boolean theQuestion;
        class DeeplyNested {
            DeeplyNested(){
                theQuestion = toBe || !toBe;
            }
        }
    }
}</code></pre>
<p>Here, every instance of <code>WithDeepNesting.Nested.DeeplyNested</code> has an enclosing instance of class <code>WithDeepNesting.Nested</code> (its immediately enclosing instance) and an enclosing instance of class <code>WithDeepNesting</code> (its 2nd lexically enclosing instance).</p>
</div>
<h4 id="jls-8.1.4">8.1.4 Superclasses <del>and Subclasses</del></h4>
<div class="editorial">
<p>The core feature being described here is a class's superclass. &quot;Subclass&quot; is merely a convenient bit of terminology, not significant enough to belong in the title.</p>
</div>
<p>The optional <code>extends</code> clause in a normal class declaration specifies the <em>direct superclass <strong>type</strong></em> of the current class.</p>
<dl>
<dt><del><em>Superclass:</em></del> <strong><em>ClassExtends:</em></strong></dt>
<dd><code>extends</code> <em>ClassType</em>
</dd>
</dl>
<p>The <code>extends</code> clause must not appear in the definition of the class <code>Object</code>, or a compile-time error occurs, because it is the primordial class and has no direct superclass <strong>type</strong>.</p>
<p>The <em>ClassType</em> must name an accessible class type (<a href="#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>It is a compile-time error if the <em>ClassType</em> names a class that is <code>final</code>, because <code>final</code> classes are not allowed to have subclasses (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>).</p>
<p>It is a compile-time error if the <em>ClassType</em> names the class <code>Enum</code> <del>or any invocation of <code>Enum</code></del><strong>, which can only be extended by an enum class</strong> (<a href="#jls-8.9">8.9</a>).</p>
<p>If the <em>ClassType</em> has type arguments, it must denote a well-formed parameterized type (<a href="#jls-4.5">4.5</a>), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.</p>
<div class="deleted">
<p>Given a (possibly generic) class declaration <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> <em>≥</em> 0, <em>C</em> <em>≠</em> <code>Object</code>), the <em>direct superclass</em> of the class type <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> is the type given in the <code>extends</code> clause of the declaration of <em>C</em> if an <code>extends</code> clause is present, or <code>Object</code> otherwise.</p>
<p>Given a generic class declaration <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct superclass</em> of the parameterized class type <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code>, where <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) is a type, is <em>D</em><code>&lt;</code><em>U<sub>1</sub></em> <em>θ</em>,...,<em>U<sub>k</sub></em> <em>θ</em><code>&gt;</code>, where <em>D</em><code>&lt;</code><em>U<sub>1</sub></em>,...,<em>U<sub>k</sub></em><code>&gt;</code> is the direct superclass of <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> and <em>θ</em> is the substitution <code>[F1:=T1,...,Fn:=Tn]</code>.</p>
</div>
<div class="editorial">
<p>Covered by <a href="#jls-4.10.2">4.10.2</a>. This section is only concerned with the superclass type of a <em>class</em>, not the superclass types of types.</p>
</div>
<div class="inserted">
<p>The direct superclass type of a class whose declaration lacks an <code>extends</code> clause is as follows:</p>
<ul>
<li><p>The class <code>Object</code> has no direct superclass type.</p></li>
<li><p>For a class other than <code>Object</code> with a normal class declaration, the direct superclass type is <code>Object</code>.</p></li>
<li><p>For an enum class <em>E</em>, the direct superclass type is <code>Enum&lt;</code><em>E</em><code>&gt;</code>.</p></li>
<li><p>For an anonymous class, the direct superclass type is defined in <a href="#jls-15.9.5">15.9.5</a>.</p></li>
</ul>
</div>
<div class="editorial">
<p>This section, as indicated in <a href="#jls-8">8</a>, is about all classes, so it's important to define the relation for all classes.</p>
</div>
<p><strong>The <em>direct superclass</em> of a class is the class named by its direct superclass type.</strong> <del>A class is said to be a <em>direct subclass</em> of its direct superclass.</del> The direct superclass is the class from whose implementation the implementation of the current class is derived.</p>
<p>The <del><em>subclass</em></del> <strong><em>superclass</em></strong> relationship is the transitive closure of the direct <del>subclass</del> <strong>superclass</strong> relationship. A class <em>A</em> is a <del>subclass</del> <strong>superclass</strong> of class <em>C</em> if either of the following is true:</p>
<ul>
<li><p><em>A</em> is the direct <del>subclass</del> <strong>superclass</strong> of <em>C</em></p></li>
<li><p><del>There exists a class <em>B</em> such that <em>A</em> is a subclass of <em>B</em>, and <em>B</em> is a subclass of <em>C</em></del> <strong>Where a class <em>B</em> is the direct superclass of <em>C</em>, <em>A</em> is a superclass of <em>B</em></strong>, applying this definition recursively.</p></li>
</ul>
<p><del>Class <em>C</em> is said to be a <em>superclass</em> of class <em>A</em> whenever <em>A</em> is a subclass of <em>C</em>.</del></p>
<p><strong>A class is said to be a <em>direct subclass</em> of its direct superclass, and a <em>subclass</em> of each of its superclasses.</strong></p>
<div class="editorial">
<p>If <em>direct superclass</em> is the fundamental relation being defined here, it's more natural presentationally to get to <em>superclass</em> via transitive closure on that relation, rather than taking a detour through the inverse, <em>subclass</em>.</p>
</div>
<div class="example">
<p>Example 8.1.4-1. Direct Superclasses and Subclasses</p>
<pre><code>class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; }  // error</code></pre>
<p>Here, the relationships are as follows:</p>
<ul>
<li><p>The class <code>Point</code> is a direct subclass of <code>Object</code>.</p></li>
<li><p>The class <code>Object</code> is the direct superclass of the class <code>Point</code>.</p></li>
<li><p>The class <code>ColoredPoint</code> is a direct subclass of class <code>Point</code>.</p></li>
<li><p>The class <code>Point</code> is the direct superclass of class <code>ColoredPoint</code>.</p></li>
</ul>
<p>The declaration of class <code>Colored3dPoint</code> causes a compile-time error because it attempts to extend the final class <code>ColoredPoint</code>.</p>
</div>
<div class="example">
<p>Example 8.1.4-2. Superclasses and Subclasses</p>
<pre><code>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }</code></pre>
<p>Here, the relationships are as follows:</p>
<ul>
<li><p>The class <code>Point</code> is a superclass of class <code>ColoredPoint</code>.</p></li>
<li><p>The class <code>Point</code> is a superclass of class <code>Colored3dPoint</code>.</p></li>
<li><p>The class <code>ColoredPoint</code> is a subclass of class <code>Point</code>.</p></li>
<li><p>The class <code>ColoredPoint</code> is a superclass of class <code>Colored3dPoint</code>.</p></li>
<li><p>The class <code>Colored3dPoint</code> is a subclass of class <code>ColoredPoint</code>.</p></li>
<li><p>The class <code>Colored3dPoint</code> is a subclass of class <code>Point</code>.</p></li>
</ul>
</div>
<p>A class <em>C</em> <em>directly depends</em> on a <del>type <em>T</em></del> <strong>class or interface <em>A</em></strong> if <del><em>T</em></del> <strong><em>A</em></strong> is mentioned in the <code>extends</code> or <code>implements</code> clause of <em>C</em> either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name.</p>
<p>A class <em>C</em> <em>depends</em> on a <del>reference type <em>T</em></del> <strong>class or interface <em>A</em></strong> if any of the following is true:</p>
<ul>
<li><p><em>C</em> directly depends on <del><em>T</em></del> <strong><em>A</em></strong>.</p></li>
<li><p><em>C</em> directly depends on an interface <em>I</em> that depends (<a href="#jls-9.1.3">9.1.3</a>) on <del><em>T</em></del> <strong><em>A</em></strong>.</p></li>
<li><p><em>C</em> directly depends on a class <em>D</em> that depends on <del><em>T</em></del> <strong><em>A</em></strong> (using this definition recursively).</p></li>
</ul>
<p>It is a compile-time error if a class depends on itself.</p>
<p>If circularly declared classes are detected at run time, as classes are loaded, then a <code>ClassCircularityError</code> is thrown (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.2.1">12.2.1</a>).</p>
<div class="example">
<p>Example 8.1.4-3. Class Depends on Itself</p>
<pre><code>class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }</code></pre>
<p>This program causes a compile-time error because class <code>Point</code> depends on itself.</p>
</div>
<h4 id="jls-8.1.5">8.1.5 Superinterfaces</h4>
<p>The optional <code>implements</code> clause in a class declaration lists <del>the names of interfaces</del> <strong>interface types</strong> that are <strong>the</strong> direct <del>superinterfaces</del> <strong>superinterface types</strong> of the class being declared.</p>
<dl>
<dt><del><em>Superinterfaces:</em></del> <strong><em>ClassImplements:</em></strong></dt>
<dd><code>implements</code> <em>InterfaceTypeList</em>
</dd>
<dt><em>InterfaceTypeList:</em></dt>
<dd><em>InterfaceType</em> {<code>,</code> <em>InterfaceType</em>}
</dd>
</dl>
<p>Each <em>InterfaceType</em> must name an accessible interface type (<a href="#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>If an <em>InterfaceType</em> has type arguments, it must denote a well-formed parameterized type (<a href="#jls-4.5">4.5</a>), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.</p>
<p>It is a compile-time error if the same interface is <del>mentioned as</del> <strong>named by</strong> a direct superinterface <strong>type</strong> more than once in a single <code>implements</code> clause. This is true even if the interface is named in different ways.</p>
<div class="example">
<p>Example 8.1.5-1. Illegal Superinterfaces</p>
<pre><code>class Redundant implements java.lang.Cloneable, Cloneable {
    int x;
}</code></pre>
<p>This program results in a compile-time error because the names <code>java.lang.Cloneable</code> and <code>Cloneable</code> refer to the same interface.</p>
</div>
<div class="deleted">
<p>Given a (possibly generic) class declaration <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> <em>≥</em> 0, <em>C</em> <em>≠</em> <code>Object</code>), the <em>direct superinterfaces</em> of the class type <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> are the types given in the <code>implements</code> clause of the declaration of <em>C</em>, if an <code>implements</code> clause is present.</p>
<p>Given a generic class declaration <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct superinterfaces</em> of the parameterized class type <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code>, where <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) is a type, are all types <em>I</em><code>&lt;</code><em>U<sub>1</sub></em> <em>θ</em>,...,<em>U<sub>k</sub></em> <em>θ</em><code>&gt;</code>, where <em>I</em><code>&lt;</code><em>U<sub>1</sub></em>,...,<em>U<sub>k</sub></em><code>&gt;</code> is a direct superinterface of <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> and <em>θ</em> is the substitution <code>[F1:=T1,...,Fn:=Tn]</code>.</p>
</div>
<div class="editorial">
<p>Covered by <a href="#jls-4.10.2">4.10.2</a>. This section is only concerned with the superinterface types of a <em>class</em>, not the superinterface types of types.</p>
</div>
<p><strong>A class whose declaration lacks an <code>implements</code> clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type, as defined in <a href="#jls-15.9.5">15.9.5</a>.</strong></p>
<p><strong>An interface is a <em>direct superinterface</em> of a class if the interface is named by one of the direct superinterface types of the class.</strong></p>
<p>An interface <del>type</del> <em>I</em> is a <em>superinterface</em> of class <del>type</del> <em>C</em> if any of the following is true:</p>
<ul>
<li><p><em>I</em> is a direct superinterface of <em>C</em>.</p></li>
<li><p><em>C</em> has some direct superinterface <em>J</em> for which <em>I</em> is a superinterface, using the definition of &quot;superinterface of an interface&quot; given in <a href="#jls-9.1.3">9.1.3</a>.</p></li>
<li><p><em>I</em> is a superinterface of the direct superclass of <em>C</em>.</p></li>
</ul>
<p>A class can have a superinterface in more than one way.</p>
<p>A class is said to <strong><em>directly implement</em> its direct superinterfaces, and to</strong> <em>implement</em> all <strong>of</strong> its superinterfaces. <strong>We also say that a class is a <em>direct subclass</em> of its direct superinterfaces, and a <em>subclass</em> of all of its superinterfaces.</strong></p>
<div class="editorial">
<p><em>Subclass</em> is traditionally a class-class relationship, but it's often useful to have a noun that describes a class-interface relationship. &quot;Implementing class&quot; can be awkward (e.g., where <em>A</em> is a class or interface, &quot;<em>C</em> is a subclass of <em>A</em>&quot; vs. &quot;<em>C</em> is a subclass or implementing class of <em>A</em>&quot;).</p>
</div>
<p>A class may not <del>at the same time be a subtype of two interface types</del> <strong>declare a direct superclass type and a direct superinterface type, or two direct superinterface types,</strong> which are<strong>, or which have supertypes (<a href="#jls-4.10.2">4.10.2</a>) which are,</strong> different parameterizations of the same generic interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>), or a <del>subtype of a</del> parameterization of a generic interface and a raw type naming that same generic interface<strong>.</strong> <strong>In the case of such a conflict,</strong> <del>or</del> a compile-time error occurs.</p>
<blockquote>
<p>This requirement was introduced in order to support translation by type erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>).</p>
</blockquote>
<div class="example">
<p>Example 8.1.5-2. Superinterfaces</p>
<pre><code>interface Colorable {
    void setColor(int color);
    int getColor();
}
enum Finish { MATTE, GLOSSY }
interface Paintable extends Colorable {
    void setFinish(Finish finish);
    Finish getFinish();
}

class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
    public int getColor() { return color; }
}
class PaintedPoint extends ColoredPoint implements Paintable {
    Finish finish;
    public void setFinish(Finish finish) {
        this.finish = finish;
    }
    public Finish getFinish() { return finish; }
}</code></pre>
<p>Here, the relationships are as follows:</p>
<ul>
<li><p>The interface <code>Paintable</code> is a superinterface of class <code>PaintedPoint</code>.</p></li>
<li><p>The interface <code>Colorable</code> is a superinterface of class <code>ColoredPoint</code> and of class <code>PaintedPoint</code>.</p></li>
<li><p>The interface <code>Paintable</code> is a subinterface of the interface <code>Colorable</code>, and <code>Colorable</code> is a superinterface of <code>Paintable</code>, as defined in <a href="#jls-9.1.3">9.1.3</a>.</p></li>
</ul>
<p>The class <code>PaintedPoint</code> has <code>Colorable</code> as a superinterface both because it is a superinterface of <code>ColoredPoint</code> and because it is a superinterface of <code>Paintable</code>.</p>
</div>
<div class="example">
<p>Example 8.1.5-3. Illegal Multiple Inheritance of an Interface</p>
<pre><code>interface I&lt;T&gt; {}
class B implements I&lt;Integer&gt; {}
class C extends B implements I&lt;String&gt; {}</code></pre>
<p>Class <code>C</code> causes a compile-time error because it attempts to be a subtype of both <em>I</em>&lt;<code>Integer</code>&gt; and <em>I</em>&lt;<code>String</code>&gt;.</p>
</div>
<p>...</p>
<h4 id="jls-8.1.6">8.1.6 Class Body and Member Declarations</h4>
<p>A <em>class body</em> may contain declarations of members of the class, that is, fields (<a href="#jls-8.3">8.3</a>), methods (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>), classes (<a href="#jls-8.5">8.5</a>), and interfaces (<a href="#jls-8.5">8.5</a>).</p>
<p>A class body may also contain instance initializers (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.6">8.6</a>), static initializers (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.7">8.7</a>), and declarations of constructors (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8">8.8</a>) for the class.</p>
<dl>
<dt><em>ClassBody:</em></dt>
<dd><code>{</code> {<em>ClassBodyDeclaration</em>} <code>}</code>
</dd>
<dt><em>ClassBodyDeclaration:</em></dt>
<dd><em>ClassMemberDeclaration</em>
</dd>
<dd><em>InstanceInitializer</em>
</dd>
<dd><em>StaticInitializer</em>
</dd>
<dd><em>ConstructorDeclaration</em>
</dd>
<dt><em>ClassMemberDeclaration:</em></dt>
<dd><em>FieldDeclaration</em>
</dd>
<dd><em>MethodDeclaration</em>
</dd>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>InterfaceDeclaration</em>
</dd>
<dd><code>;</code>
</dd>
</dl>
<p>The scope and shadowing of a declaration of a member <em>m</em> declared in or inherited by a class <del>type</del> <em>C</em> is specified in <a href="#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<blockquote>
<p>If <em>C</em> <del>itself</del> is a nested class, there may be definitions of the same kind (variable, method, or type) and name as <em>m</em> in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member <em>m</em> declared in or inherited by <em>C</em> shadows (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) the other definitions of the same kind and name.</p>
</blockquote>
<h3 id="jls-8.2">8.2 Class Members</h3>
<p>The members of a class <del>type</del> are all of the following:</p>
<ul>
<li><p>Members inherited from its direct superclass <strong>type</strong> (<a href="#jls-8.1.4">8.1.4</a>), except in class <code>Object</code>, which has no direct superclass <strong>type</strong></p></li>
<li><p>Members inherited from any direct <del>superinterfaces</del> <strong>superinterface types</strong> (<a href="#jls-8.1.5">8.1.5</a>)</p></li>
<li><p>Members declared in the body of the class (<a href="#jls-8.1.6">8.1.6</a>)</p></li>
</ul>
<p>Members of a class that are declared <code>private</code> are not inherited by subclasses of that class.</p>
<p>Only members of a class that are declared <code>protected</code> or <code>public</code> are inherited by subclasses declared in a package other than the one in which the class is declared.</p>
<p>Constructors, static initializers, and instance initializers are not members and therefore are not inherited.</p>
<p>We use the phrase <em>the type of a member</em> to denote:</p>
<ul>
<li><p>For a field, its type.</p></li>
<li><p>For a method, an ordered 4-tuple consisting of:</p>
<ul>
<li><p>type parameters: the declarations of any type parameters of the method member.</p></li>
<li><p>argument types: a list of the types of the arguments to the method member.</p></li>
<li><p>return type: the return type of the method member.</p></li>
<li><p><code>throws</code> clause: exception types declared in the <code>throws</code> clause of the method member.</p></li>
</ul></li>
</ul>
<p>Fields, methods, and member <del>types</del> <strong>classes and interfaces</strong> of a class <del>type</del> may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5">6.5</a>). However, this is discouraged as a matter of style.</p>
<p>...</p>
<h3 id="jls-8.3">8.3 Field Declarations</h3>
<p>The variables of a class <del>type</del> are introduced by <em>field declarations</em>.</p>
<p>...</p>
<h3 id="jls-8.4">8.4 Method Declarations</h3>
<h4 id="jls-8.4.8">8.4.8 Inheritance, Overriding, and Hiding</h4>
<p>A class <em>C</em> <em>inherits</em> from its direct superclass <strong>type</strong> all concrete methods <em>m</em> (both <code>static</code> and instance) of the superclass <strong>type</strong> for which all of the following are true:</p>
<ul>
<li><p><em>m</em> is a member of the direct superclass <strong>type</strong> of <em>C</em><strong>, <em>D</em></strong>.</p></li>
<li><p><em>m</em> is <code>public</code>, <code>protected</code>, or declared with package access in the same package as <em>C</em>.</p></li>
<li><p>No method declared in <em>C</em> has a signature that is a subsignature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the signature of <em>m</em> <strong>as a member of <em>D</em></strong>.</p></li>
</ul>
<div class="editorial">
<p>It's important that the subsignature test be performed with respect to a method's signature <em>as a member</em> of a particular type. A method's signature can vary depending on type parameter instantiations.</p>
</div>
<p>A class <em>C</em> <em>inherits</em> from its direct superclass <strong>type</strong> and direct <del>superinterfaces</del> <strong>superinterface types</strong> all <code>abstract</code> and default (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>) methods <em>m</em> for which all of the following are true:</p>
<ul>
<li><p><em>m</em> is a member of the direct superclass <strong>type</strong> or a direct superinterface <strong>type</strong>, <em>D</em>, of <em>C</em>.</p></li>
<li><p><em>m</em> is <code>public</code>, <code>protected</code>, or declared with package access in the same package as <em>C</em>.</p></li>
<li><p>No method declared in <em>C</em> has a signature that is a subsignature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the signature of <em>m</em> <strong>as a member of <em>D</em></strong>.</p></li>
<li><p>No concrete method inherited by <em>C</em> from its direct superclass <strong>type</strong> has a signature that is a subsignature of the signature of <em>m</em> <strong>as a member of <em>D</em></strong>.</p></li>
<li><p>There exists no method <em>m</em>' that is a member of the direct superclass <strong>type</strong> or a direct superinterface <strong>type</strong>, <em>D</em>', of <em>C</em> (<em>m</em> distinct from <em>m</em>', <em>D</em> distinct from <em>D</em>'), such that <em>m</em>' overrides from <strong>the class or interface of</strong> <em>D</em>' (<a href="#jls-8.4.8.1">8.4.8.1</a>, <a href="#jls-9.4.1.1">9.4.1.1</a>) the declaration of the method <em>m</em>.</p></li>
</ul>
<p>A class does not inherit <code>private</code> or <code>static</code> methods from its <del>superinterfaces</del> <strong>superinterface types</strong>.</p>
<blockquote>
<p>Note that methods are overridden or hidden on a signature-by-signature basis. If, for example, a class declares two <code>public</code> methods with the same name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.9">8.4.9</a>), and a subclass overrides one of them, the subclass still inherits the other method.</p>
</blockquote>
<div class="example">
<p>Example 8.4.8-1. Inheritance</p>
<pre><code>interface I1 {
    int foo();
}

interface I2 {
    int foo();
}

abstract class Test implements I1, I2 {} </code></pre>
<p>Here, the <code>abstract</code> class <code>Test</code> inherits the <code>abstract</code> method <code>foo</code> from interface <code>I1</code> and also the <code>abstract</code> method <code>foo</code> from interface <code>I2</code>. The key question in determining the inheritance of <code>foo</code> from <code>I1</code> is: does the method <code>foo</code> in <code>I2</code> override &quot;from <code>I2</code>&quot; (<a href="#jls-9.4.1.1">9.4.1.1</a>) the method <code>foo</code> in <code>I1</code>? No, because <code>I1</code> and <code>I2</code> are not subinterfaces of each other. Thus, from the viewpoint of class <code>Test</code>, the inheritance of <code>foo</code> from <code>I1</code> is unfettered; similarly for the inheritance of <code>foo</code> from <code>I2</code>. Per <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.8.4">8.4.8.4</a>, class <code>Test</code> can inherit both <code>foo</code> methods; obviously it must be declared <code>abstract</code>, or else override both <code>abstract</code> <code>foo</code> methods with a concrete method.</p>
</div>
<blockquote>
<p>Note that it is possible for an inherited concrete method to prevent the inheritance of an <code>abstract</code> or default method. (The concrete method will override the <code>abstract</code> or default method &quot;from <em>C</em>&quot;, per <a href="#jls-8.4.8.1">8.4.8.1</a> and <a href="#jls-9.4.1.1">9.4.1.1</a>.) Also, it is possible for one supertype method to prevent the inheritance of another supertype method if the former &quot;already&quot; overrides the latter - this is the same as the rule for interfaces (<a href="#jls-9.4.1">9.4.1</a>), and prevents conflicts in which multiple default methods are inherited and one implementation is clearly meant to supersede the other.</p>
</blockquote>
<h5 id="jls-8.4.8.1">8.4.8.1 Overriding (by Instance Methods)</h5>
<p>An instance method <em>m<sub>C</sub></em> declared in or inherited by class <em>C</em>, <em>overrides from C</em> another method <em>m<sub>A</sub></em> declared in class <em>A</em>, iff all of the following are true:</p>
<ul>
<li><p><em>C</em> is a subclass of <em>A</em>.</p></li>
<li><p><em>C</em> does not inherit <em>m<sub>A</sub></em>.</p></li>
<li><p>The signature of <em>m<sub>C</sub></em> is a subsignature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the signature of <em>m<sub>A</sub></em> <strong>as a member of the supertype of <em>C</em> that names <em>A</em></strong>.</p>
<div class="editorial">
<p>In the case of a generic class <em>A</em>, we need to know what type parameters to apply to <em>A</em> before comparing signatures.</p>
</div></li>
<li><p>One of the following is true:</p>
<ul>
<li><p><em>m<sub>A</sub></em> is <code>public</code>.</p></li>
<li><p><em>m<sub>A</sub></em> is <code>protected</code>.</p></li>
<li><p><em>m<sub>A</sub></em> is declared with package access in the same package as <em>C</em>, and either <em>C</em> declares <em>m<sub>C</sub></em> or <em>m<sub>A</sub></em> is a member of the direct superclass <strong>type</strong> of <em>C</em>.</p></li>
<li><p><em>m<sub>A</sub></em> is declared with package access and <em>m<sub>C</sub></em> overrides <em>m<sub>A</sub></em> from some superclass of <em>C</em>.</p></li>
<li><p><em>m<sub>A</sub></em> is declared with package access and <em>m<sub>C</sub></em> overrides a method <em>m'</em> from <em>C</em> (<em>m'</em> distinct from <em>m<sub>C</sub></em> and <em>m<sub>A</sub></em>), such that <em>m'</em> overrides <em>m<sub>A</sub></em> from some superclass of <em>C</em>.</p></li>
</ul></li>
</ul>
<p>If <em>m<sub>C</sub></em> is non-<code>abstract</code> and overrides from <em>C</em> an <code>abstract</code> method <em>m<sub>A</sub></em>, then <em>m<sub>C</sub></em> is said to <em>implement</em> <em>m<sub>A</sub></em> <em>from C</em>.</p>
<p>It is a compile-time error if the overridden method, <em>m<sub>A</sub></em>, is a <code>static</code> method.</p>
<blockquote>
<p>In this respect, overriding of methods differs from hiding of fields (<a href="#jls-8.3">8.3</a>), for it is permissible for an instance variable to hide a <code>static</code> variable.</p>
</blockquote>
<p>An instance method <em>m<sub>C</sub></em> declared in or inherited by class <em>C</em>, <em>overrides from C</em> another method <em>m<sub>I</sub></em> declared in interface <em>I</em>, iff all of the following are true:</p>
<ul>
<li><p><em>I</em> is a superinterface of <em>C</em>.</p></li>
<li><p><em>m<sub>I</sub></em> is not <code>static</code>.</p></li>
<li><p><em>C</em> does not inherit <em>m<sub>I</sub></em>.</p></li>
<li><p>The signature of <em>m<sub>C</sub></em> is a subsignature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the signature of <em>m<sub>I</sub></em> <strong>as a member of the supertype of <em>C</em> that names <em>I</em></strong>.</p></li>
<li><p><em>m<sub>I</sub></em> is <code>public</code>.</p></li>
</ul>
<blockquote>
<p>The signature of an overriding method may differ from the overridden one if a formal parameter in one of the methods has a raw type, while the corresponding parameter in the other has a parameterized type. This accommodates migration of pre-existing code to take advantage of generics.</p>
</blockquote>
<blockquote>
<p>The notion of overriding includes methods that override another from some subclass of their declaring class. This can happen in two ways:</p>
</blockquote>
<blockquote>
<ul>
<li><p>A concrete method in a generic superclass can, under certain parameterizations, have the same signature as an abstract method in that class. In this case, the concrete method is inherited and the <code>abstract</code> method is not (as described above). The inherited method should then be considered to override its abstract peer <em>from C</em>. (This scenario is complicated by package access: if <em>C</em> is in a different package, then <em>m<sub>A</sub></em> would not have been inherited anyway, and should not be considered overridden.)</p></li>
<li><p>A method inherited from a class can override a superinterface method. (Happily, package access is not a concern here.)</p></li>
</ul>
</blockquote>
<p>An overridden method can be accessed by using a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>) that contains the keyword <code>super</code>. A qualified name or a cast to a superclass type is not effective in attempting to access an overridden method.</p>
<blockquote>
<p>In this respect, overriding of methods differs from hiding of fields.</p>
</blockquote>
<p>The presence or absence of the <code>strictfp</code> modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.</p>
<p>...</p>
<h5 id="jls-8.4.8.2">8.4.8.2 Hiding (by Class Methods)</h5>
<p>If a class <em>C</em> declares or inherits a <code>static</code> method <em>m</em>, then <em>m</em> is said to <em>hide</em> any method <em>m'</em> <strong>declared in class or interface <em>A</em></strong> for which all of the following are true:</p>
<ul>
<li><p><strong><em>A</em> is a superclass or superinterface of <em>C</em>.</strong></p></li>
<li><p><del><em>m'</em> is either a <code>static</code> or instance method declared in a superclass of <em>C</em>, or an instance method declared in a superinterface of <em>C</em>.</del> <strong>If <em>A</em> is an interface, <em>m'</em> is an instance method.</strong></p></li>
<li><p><em>m'</em> is accessible to <em>C</em> (<a href="#jls-6.6">6.6</a>).</p></li>
<li><p>The signature of <em>m</em> is a subsignature <strong>(<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>)</strong> of the signature of <em>m'</em> <del>(<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>)</del> <strong>as a member of the supertype of <em>C</em> that names <em>A</em></strong>.</p></li>
</ul>
<div class="editorial">
<p>The clarification about the type to use when determining the signature is irrelevant to <code>static</code> methods, which cannot make use of type parameters, but affects how <code>static</code> methods are matched up with instance methods in supertypes.</p>
</div>
<p>It is a compile-time error if a <code>static</code> method hides an instance method.</p>
<blockquote>
<p>In this respect, hiding of methods differs from hiding of fields (<a href="#jls-8.3">8.3</a>), for it is permissible for a <code>static</code> variable to hide an instance variable. Hiding is also distinct from shadowing (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) and obscuring (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.2">6.4.2</a>).</p>
</blockquote>
<p>A hidden method can be accessed by using a qualified name or by using a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>) that contains the keyword <code>super</code> or a cast to a superclass type.</p>
<blockquote>
<p>In this respect, hiding of methods is similar to hiding of fields.</p>
</blockquote>
<div class="example">
<p>Example 8.4.8.2-1. Invocation of Hidden Class Methods</p>
<p>A class (<code>static</code>) method that is hidden can be invoked by using a reference whose type is the <strong>type of the</strong> class that actually contains the declaration of the method. In this respect, hiding of <code>static</code> methods is different from overriding of instance methods. The example:</p>
<pre><code>class Super {
    static String greeting() { return &quot;Goodnight&quot;; }
    String name() { return &quot;Richard&quot;; }
}
class Sub extends Super {
    static String greeting() { return &quot;Hello&quot;; }
    String name() { return &quot;Dick&quot;; }
}
class Test {
    public static void main(String[] args) {
        Super s = new Sub();
        System.out.println(s.greeting() + &quot;, &quot; + s.name());
    }
}</code></pre>
<p>produces the output:</p>
<pre><code>Goodnight, Dick</code></pre>
<p>because the invocation of <code>greeting</code> uses the type of <code>s</code>, namely <code>Super</code>, to figure out, at compile time, which class method to invoke, whereas the invocation of <code>name</code> uses the class of <code>s</code>, namely <code>Sub</code>, to figure out, at run time, which instance method to invoke.</p>
</div>
<h5 id="jls-8.4.8.3">8.4.8.3 Requirements in Overriding and Hiding</h5>
<p>If a method declaration <em>d<sub>1</sub></em> with return type <em>R<sub>1</sub></em> overrides or hides the declaration of another method <em>d<sub>2</sub></em> with return type <em>R<sub>2</sub></em>, then <em>d<sub>1</sub></em> must be return-type-substitutable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.5">8.4.5</a>) for <em>d<sub>2</sub></em>, or a compile-time error occurs.</p>
<blockquote>
<p>This rule allows for covariant return types - refining the return type of a method when overriding it.</p>
</blockquote>
<p>If <em>R<sub>1</sub></em> is not a subtype of <em>R<sub>2</sub></em>, then a compile-time unchecked warning occurs, unless suppressed by <code>@SuppressWarnings</code> (<a href="#jls-9.6.4.5">9.6.4.5</a>).</p>
<p>A method that overrides or hides another method, including methods that implement <code>abstract</code> methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.</p>
<blockquote>
<p>In this respect, overriding of methods differs from hiding of fields (<a href="#jls-8.3">8.3</a>), for it is permissible for a field to hide a field of another type.</p>
</blockquote>
<p>More precisely, suppose that <em>B</em> is a class or interface, and <em>A</em> is a superclass or superinterface of <em>B</em>, and a method declaration <em>m<sub>2</sub></em> in <em>B</em> overrides or hides a method declaration <em>m<sub>1</sub></em> in <em>A</em>. Then:</p>
<ul>
<li><p>If <em>m<sub>2</sub></em> has a <code>throws</code> clause that mentions any checked exception types, then <em>m<sub>1</sub></em> must have a <code>throws</code> clause, or a compile-time error occurs.</p></li>
<li><p>For every checked exception type listed in the <code>throws</code> clause of <em>m<sub>2</sub></em>, that same exception class or one of its supertypes must occur in the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of the <code>throws</code> clause of <em>m<sub>1</sub></em>; otherwise, a compile-time error occurs.</p></li>
<li><p>If the unerased <code>throws</code> clause of <em>m<sub>1</sub></em> does not contain a supertype of each exception type in the <code>throws</code> clause of <em>m<sub>2</sub></em> (adapted, if necessary, to the type parameters of <em>m<sub>1</sub></em>), then a compile-time unchecked warning occurs, unless suppressed by <code>@SuppressWarnings</code> (<a href="#jls-9.6.4.5">9.6.4.5</a>).</p></li>
</ul>
<p>It is a compile-time error if a <del>type declaration <em>T</em></del> <strong>class or interface <em>C</em></strong> has a member method <em>m<sub>1</sub></em> and there exists a method <em>m<sub>2</sub></em> declared in <del><em>T</em></del> <strong><em>C</em></strong> or a <del>supertype</del> <strong>superclass or superinterface</strong> of <del><em>T</em></del> <strong><em>C</em>, <em>A</em></strong> such that all of the following are true:</p>
<ul>
<li><p><em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> have the same name.</p></li>
<li><p><em>m<sub>2</sub></em> is accessible (<a href="#jls-6.6">6.6</a>) from <del><em>T</em></del> <strong><em>C</em></strong>.</p></li>
<li><p>The signature of <em>m<sub>1</sub></em> is not a subsignature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the signature of <em>m<sub>2</sub></em> <strong>as a member of the supertype of <em>C</em> that names <em>A</em></strong>.</p></li>
<li><p>The <strong>declared</strong> signature of <em>m<sub>1</sub></em> or some method <em>m<sub>1</sub></em> overrides (directly or indirectly) has the same erasure as the <strong>declared</strong> signature of <em>m<sub>2</sub></em> or some method <em>m<sub>2</sub></em> overrides (directly or indirectly).</p></li>
</ul>
<blockquote>
<p>These restrictions are necessary because generics are implemented via erasure. The rule above implies that methods declared in the same class with the same name must have different erasures. It also implies that a <del>type declaration</del> <strong>class or interface</strong> cannot implement or extend two distinct <del>invocations</del> <strong>parameterizations</strong> of the same generic interface.</p>
</blockquote>
<p>The access modifier of an overriding or hiding method must provide at least as much access as the overridden or hidden method, as follows:</p>
<ul>
<li><p>If the overridden or hidden method is <code>public</code>, then the overriding or hiding method must be <code>public</code>; otherwise, a compile-time error occurs.</p></li>
<li><p>If the overridden or hidden method is <code>protected</code>, then the overriding or hiding method must be <code>protected</code> or <code>public</code>; otherwise, a compile-time error occurs.</p></li>
<li><p>If the overridden or hidden method has package access, then the overriding or hiding method must <em>not</em> be <code>private</code>; otherwise, a compile-time error occurs.</p></li>
</ul>
<blockquote>
<p>Note that a <code>private</code> method cannot be overridden or hidden in the technical sense of those terms. This means that a subclass can declare a method with the same signature as a <code>private</code> method in one of its superclasses, and there is no requirement that the return type or <code>throws</code> clause of such a method bear any relationship to those of the <code>private</code> method in the superclass.</p>
</blockquote>
<p>...</p>
<h3 id="jls-8.5">8.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</h3>
<p>A <em>member class</em> is a class whose declaration is directly enclosed in the body of another class or interface declaration (<a href="#jls-8.1.6">8.1.6</a>, <a href="#jls-9.1.4">9.1.4</a>). <strong>A member class may be an enum class (<a href="#jls-8.9">8.9</a>).</strong></p>
<p>A <em>member interface</em> is an interface whose declaration is directly enclosed in the body of another class or interface declaration (<a href="#jls-8.1.6">8.1.6</a>, <a href="#jls-9.1.4">9.1.4</a>). <strong>A member interface may be an annotation interface (<a href="#jls-9.6">9.6</a>).</strong></p>
<p>The accessibility of a member <del>type</del> <strong>class or interface</strong> declaration in a class is specified by its access modifier, or by <a href="#jls-6.6">6.6</a> if lacking an access modifier.</p>
<p><del>It is a compile-time error if the same keyword appears more than once as a modifier for a member type declaration in a class, or if a member type declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="#jls-6.6">6.6</a>.)</del></p>
<div class="editorial">
<p>This is already stated in <a href="#jls-8.1.1">8.1.1</a> and <a href="#jls-9.1.1">9.1.1</a>.</p>
</div>
<p>The scope and shadowing of a member <del>type</del> <strong>class or interface</strong> is specified in <a href="#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p>If a class declares a member <del>type</del> <strong>class or interface</strong> with a certain name, then the declaration of that <del>type</del> <strong>class or interface</strong> is said to <em>hide</em> any and all accessible declarations of member <del>types</del> <strong>classes and interfaces</strong> with the same name in superclasses and superinterfaces of the class.</p>
<blockquote>
<p>In this respect, hiding of member <del>types</del> <strong>classes and interfaces</strong> is similar to hiding of fields (<a href="#jls-8.3">8.3</a>).</p>
</blockquote>
<p>A class inherits from its direct superclass and direct superinterfaces all the non-<code>private</code> member <del>types</del> <strong>classes and interfaces</strong> of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.</p>
<p>It is possible for a class to inherit more than one member <del>type</del> <strong>class or interface</strong> with the same name, either from its superclass and superinterfaces or from its superinterfaces alone. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such member <del>type</del> <strong>class or interface</strong> by its simple name will result in a compile-time error, because the reference is ambiguous.</p>
<p>There might be several paths by which the same member <del>type</del> <strong>class or interface</strong> declaration is inherited from an interface. In such a situation, the member <del>type</del> <strong>class or interface</strong> is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.</p>
<h4 id="jls-8.5.1">8.5.1 Static Member <del>Type</del> <strong>Class and Interface</strong> Declarations</h4>
<p>The <code>static</code> keyword may modify the declaration of a member <del>type</del> <strong>class</strong> <em>C</em> within the body of a non-inner class or interface <em>T</em>. Its effect is to declare that <em>C</em> is not an inner class. Just as a <code>static</code> method of <em>T</em> has no current instance of <em>T</em> in its body, <em>C</em> also has no current instance of <em>T</em>, nor does it have any lexically enclosing instances.</p>
<p>It is a compile-time error if a <code>static</code> class contains a usage of a non-<code>static</code> member of an enclosing class.</p>
<p>A member interface is implicitly <code>static</code> (<a href="#jls-9.1.1">9.1.1</a>). It is permitted for the declaration of a member interface to redundantly specify the <code>static</code> modifier.</p>
<h3 id="jls-8.8">8.8 Constructor Declarations</h3>
<h4 id="jls-8.8.7">8.8.7 Constructor Body</h4>
<h5 id="jls-8.8.7.1">8.8.7.1 Explicit Constructor Invocations</h5>
<dl>
<dt><em>ExplicitConstructorInvocation:</em></dt>
<dd>[<em>TypeArguments</em>] <code>this</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd>[<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd><em>ExpressionName</em> <code>.</code> [<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd><em>Primary</em> <code>.</code> [<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>TypeArguments:</em></dt>
<dd><code>&lt;</code> <em>TypeArgumentList</em> <code>&gt;</code>
</dd>
<dt><em>ArgumentList:</em></dt>
<dd><em>Expression</em> {<code>,</code> <em>Expression</em>}
</dd>
</dl>
</blockquote>
<p>Explicit constructor invocation statements are divided into two kinds:</p>
<ul>
<li><p><em>Alternate constructor invocations</em> begin with the keyword <code>this</code> (possibly prefaced with explicit type arguments). They are used to invoke an alternate constructor of the same class.</p></li>
<li><p><em>Superclass constructor invocations</em> begin with either the keyword <code>super</code> (possibly prefaced with explicit type arguments) or a <em>Primary</em> expression or an <em>ExpressionName</em>. They are used to invoke a constructor of the direct superclass. They are further divided:</p>
<ul>
<li><p><em>Unqualified superclass constructor invocations</em> begin with the keyword <code>super</code> (possibly prefaced with explicit type arguments).</p></li>
<li><p><em>Qualified superclass constructor invocations</em> begin with a <em>Primary</em> expression or an <em>ExpressionName</em>. They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass (<a href="#jls-8.1.3">8.1.3</a>). This may be necessary when the superclass is an inner class.</p></li>
</ul></li>
</ul>
<p>An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods or inner classes declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs.</p>
<blockquote>
<p>This prohibition on using the current instance explains why an explicit constructor invocation statement is deemed to occur in a static context (<a href="#jls-8.1.3">8.1.3</a>).</p>
</blockquote>
<p>If <em>TypeArguments</em> is present to the left of <code>this</code> or <code>super</code>, then it is a compile-time error if any of the type arguments are wildcards (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a>).</p>
<p>Let <em>C</em> be the class being instantiated, and let <em>S</em> be the direct superclass of <em>C</em>.</p>
<p>If a superclass constructor invocation statement is unqualified, then:</p>
<ul>
<li>If <em>S</em> is an inner member class, but <em>S</em> is not a member of a class enclosing <em>C</em>, then a compile-time error occurs.</li>
</ul>
<p>If a superclass constructor invocation statement is qualified, then:</p>
<ul>
<li><p>If <em>S</em> is not an inner class, or if the declaration of <em>S</em> occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, let <em>p</em> be the <em>Primary</em> expression or the <em>ExpressionName</em> immediately preceding &quot;<code>.super</code>&quot;, and let <em>O</em> be the immediately enclosing class of <em>S</em>. It is a compile-time error if the type of <em>p</em> is not <em>O</em> or a subclass of <em>O</em>, or if the type of <em>p</em> is not accessible (<a href="#jls-6.6">6.6</a>).</p></li>
</ul>
<p>The exception types that an explicit constructor invocation statement can throw are specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.2.2">11.2.2</a>.</p>
<p>Evaluation of an alternate constructor invocation statement proceeds by first evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.</p>
<p>Evaluation of a superclass constructor invocation statement proceeds as follows:</p>
<ol type="1">
<li><p>Let <em>i</em> be the instance being created. The immediately enclosing instance of <em>i</em> with respect to <em>S</em> (if any) must be determined:</p>
<ul>
<li><p>If <em>S</em> is not an inner class, or if the declaration of <em>S</em> occurs in a static context, then no immediately enclosing instance of <em>i</em> with respect to <em>S</em> exists.</p></li>
<li><p>If the superclass constructor invocation is unqualified, then <em>S</em> is necessarily a local class or an inner member class.</p>
<p>If <em>S</em> is a local class, then let <em>O</em> be the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>S</em>.</p>
<p>If <em>S</em> is an inner member class, then let <em>O</em> be the innermost enclosing class of <em>C</em> of which <em>S</em> is a member.</p>
<p>Let <em>n</em> be an integer (<em>n</em> <em>≥</em> 1) such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>C</em>.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p>
<blockquote>
<p>While it may be the case that <em>S</em> is a member of <em>C</em> due to inheritance, the zeroth lexically enclosing instance of <code>this</code> (that is, <code>this</code> itself) is never used as the immediately enclosing instance of <em>i</em> with respect to <em>S</em>.</p>
</blockquote></li>
<li><p>If the superclass constructor invocation is qualified, then the <em>Primary</em> expression or the <em>ExpressionName</em> immediately preceding &quot;<code>.super</code>&quot;, <em>p</em>, is evaluated.</p>
<p>If <em>p</em> evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the superclass constructor invocation completes abruptly.</p>
<p>Otherwise, the result of this evaluation is the immediately enclosing instance of <em>i</em> with respect to <em>S</em>.</p></li>
</ul></li>
<li><p>After determining the immediately enclosing instance of <em>i</em> with respect to <em>S</em> (if any), evaluation of the superclass constructor invocation statement proceeds by evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.</p></li>
<li><p>Finally, if the superclass constructor invocation statement completes normally, then all instance variable initializers of <em>C</em> and all instance initializers of <em>C</em> are executed. If an instance initializer or instance variable initializer <em>I</em> textually precedes another instance initializer or instance variable initializer <em>J</em>, then <em>I</em> is executed before <em>J</em>.</p>
<p>Execution of instance variable initializers and instance initializers is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided implicitly. (An alternate constructor invocation does not perform this additional implicit execution.)</p></li>
</ol>
<div class="example">
<p>Example 8.8.7.1-1. Restrictions on Explicit Constructor Invocation Statements</p>
<p>If the first constructor of <code>ColoredPoint</code> in the example from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.7">8.8.7</a> were changed as follows:</p>
<pre><code>class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
    static final int WHITE = 0, BLACK = 1;
    int color;
    ColoredPoint(int x, int y) {
        this(x, y, color);  // Changed to color from WHITE
    }
    ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = color;
    }
}</code></pre>
<p>then a compile-time error would occur, because the instance variable <code>color</code> cannot be used by a explicit constructor invocation statement.</p>
</div>
<div class="example">
<p>Example 8.8.7.1-2. Qualified Superclass Constructor Invocation</p>
<p>In the code below, <code>ChildOfInner</code> has no lexically enclosing <del>type</del> <strong>class or interface</strong> declaration, so an instance of <code>ChildOfInner</code> has no enclosing instance. However, the superclass of <code>ChildOfInner</code> (<code>Inner</code>) has a lexically enclosing <del>type</del> <strong>class</strong> declaration (<code>Outer</code>), and an instance of <code>Inner</code> must have an enclosing instance of <code>Outer</code>. The enclosing instance of <code>Outer</code> is set when an instance of <code>Inner</code> is created. Therefore, when we create an instance of <code>ChildOfInner</code>, which is implicitly an instance of <code>Inner</code>, we must provide the enclosing instance of <code>Outer</code> via a qualified superclass invocation statement in <code>ChildOfInner</code>'s constructor. The instance of <code>Outer</code> is called the immediately enclosing instance of <code>ChildOfInner</code> with respect to <code>Inner</code>.</p>
<pre><code>class Outer {
    class Inner {}
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner() { (new Outer()).super(); }
}</code></pre>
<p>Perhaps surprisingly, the same instance of <code>Outer</code> may serve as the immediately enclosing instance of <code>ChildOfInner</code> with respect to <code>Inner</code> <em>for multiple instances of <code>ChildOfInner</code></em>. These instances of <code>ChildOfInner</code> are implicitly linked to the same instance of <code>Outer</code>. The program below achieves this by passing an instance of <code>Outer</code> to the constructor of <code>ChildOfInner</code>, which uses the instance in a qualified superclass constructor invocation statement. The rules for an explicit constructor invocation statement do not prohibit using formal parameters of the constructor that contains the statement.</p>
<pre><code>class Outer {
    int secret = 5;
    class Inner {
        int  getSecret()      { return secret; }
        void setSecret(int s) { secret = s; }
    }
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner(Outer x) { x.super(); }
}

public class Test {
    public static void main(String[] args) {
        Outer x = new Outer();
        ChildOfInner a = new ChildOfInner(x);
        ChildOfInner b = new ChildOfInner(x);
        System.out.println(b.getSecret());
        a.setSecret(6);
        System.out.println(b.getSecret());
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>5
6</code></pre>
<p>The effect is that manipulation of instance variables in the common instance of <code>Outer</code> is visible through references to different instances of <code>ChildOfInner</code>, even though such references are not aliases in the conventional sense.</p>
</div>
<h3 id="jls-8.9">8.9 Enum <del>Types</del> <strong>Classes</strong></h3>
<p>An <em>enum declaration</em> specifies a new <em>enum <del>type</del> <strong>class</strong></em>, a special kind of class <del>type</del> <strong>that defines a small set of named class instances</strong>.</p>
<dl>
<dt><em>EnumDeclaration:</em></dt>
<dd>{<em>ClassModifier</em>} <code>enum</code> <em>TypeIdentifier</em> [<del><em>Superinterfaces</em></del> <strong><em>ClassImplements</em></strong>] <em>EnumBody</em>
</dd>
</dl>
<p><strong>An enum declaration may specify a top level enum class (<a href="#jls-7.6">7.6</a>) or a member enum class (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>).</strong></p>
<p>It is a compile-time error if an enum declaration has the modifier <code>abstract</code> or <code>final</code>.</p>
<p>An enum declaration is implicitly <code>final</code> unless it contains at least one enum constant that has a class body (<a href="#jls-8.9.1">8.9.1</a>).</p>
<p>A <del>nested</del> <strong>member</strong> enum <del>type</del> <strong>class</strong> is implicitly <code>static</code>. It is permitted for the declaration of a <del>nested</del> <strong>member</strong> enum <del>type</del> <strong>class</strong> to redundantly specify the <code>static</code> modifier.</p>
<blockquote>
<p>This implies that it is impossible to declare an enum <del>type</del> <strong>class</strong> <del>in the body of</del> <strong>as a member of</strong> an inner class (<a href="#jls-8.1.3">8.1.3</a>), because an inner class cannot have <code>static</code> members except for constant variables.</p>
</blockquote>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for an enum declaration, or if an enum declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="#jls-6.6">6.6</a>).</p>
<p><strong>An enum declaration does not have an <code>extends</code> clause.</strong> The direct superclass <strong>type</strong> of an enum <del>type</del> <strong>class</strong> <em>E</em> is <code>Enum&lt;</code><em>E</em><code>&gt;</code> (<a href="#jls-8.1.4">8.1.4</a>).</p>
<p>An enum <del>type</del> <strong>class</strong> has no instances other than those defined by its enum constants. It is a compile-time error to attempt to explicitly instantiate an enum <del>type</del> <strong>class</strong> (<a href="#jls-15.9.1">15.9.1</a>).</p>
<blockquote>
<p>In addition to the compile-time error, three further mechanisms ensure that no instances of an enum <del>type</del> <strong>class</strong> exist beyond those defined by its enum constants:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The <code>final</code> <code>clone</code> method in <code>Enum</code> ensures that enum constants can never be cloned.</p></li>
<li><p>Reflective instantiation of enum <del>types</del> <strong>classes</strong> is prohibited.</p></li>
<li><p>Special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization.</p></li>
</ul>
</blockquote>
<h4 id="jls-8.9.1">8.9.1 Enum Constants</h4>
<p>The body of an enum declaration may contain <em>enum constants</em>. An enum constant defines an instance of the enum <del>type</del> <strong>class</strong>.</p>
<dl>
<dt><em>EnumBody:</em></dt>
<dd><code>{</code> [<em>EnumConstantList</em>] [<code>,</code>] [<em>EnumBodyDeclarations</em>] <code>}</code>
</dd>
<dt><em>EnumConstantList:</em></dt>
<dd><em>EnumConstant</em> {<code>,</code> <em>EnumConstant</em>}
</dd>
<dt><em>EnumConstant:</em></dt>
<dd>{<em>EnumConstantModifier</em>} <em>Identifier</em> [<code>(</code> [<em>ArgumentList</em>] <code>)</code>] [<em>ClassBody</em>]
</dd>
<dt><em>EnumConstantModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
</dl>
<blockquote>
<p>The following production from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a> is shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>ArgumentList:</em></dt>
<dd><em>Expression</em> {<code>,</code> <em>Expression</em>}
</dd>
</dl>
</blockquote>
<p>The rules for annotation modifiers on an enum constant declaration are specified in <a href="#jls-9.7.4">9.7.4</a> and <a href="#jls-9.7.5">9.7.5</a>.</p>
<p>The <em>Identifier</em> in a <em>EnumConstant</em> may be used in a name to refer to the enum constant.</p>
<p>The scope and shadowing of an enum constant is specified in <a href="#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p>An enum constant may be followed by arguments, which are passed to the constructor of the enum when the constant is created during class initialization as described later in this section. The constructor to be invoked is chosen using the normal rules of overload resolution (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2">15.12.2</a>). If the arguments are omitted, an empty argument list is assumed.</p>
<p>The optional class body of an enum constant implicitly defines an anonymous class <del>declaration</del> (<a href="#jls-15.9.5">15.9.5</a>) that extends the immediately enclosing enum <del>type</del> <strong>class</strong>. The class body is governed by the usual rules of anonymous classes; in particular it cannot contain any constructors. Instance methods declared in these class bodies may be invoked outside the enclosing enum <del>type</del> <strong>class</strong> only if they override accessible methods in the enclosing enum <del>type</del> <strong>class</strong> (<a href="#jls-8.4.8">8.4.8</a>).</p>
<p><del>It is a compile-time error for the class body of an enum constant to declare an <code>abstract</code> method.</del></p>
<div class="editorial">
<p>This is redundant: anonymous classes are defined to be non-<code>abstract</code>.</p>
</div>
<p>Because there is only one instance of each enum constant, it is permitted to use the <code>==</code> operator in place of the <code>equals</code> method when comparing two object references if it is known that at least one of them refers to an enum constant.</p>
<blockquote>
<p>The <code>equals</code> method in <code>Enum</code> is a <code>final</code> method that merely invokes <code>super.equals</code> on its argument and returns the result, thus performing an identity comparison.</p>
</blockquote>
<h4 id="jls-8.9.2">8.9.2 Enum Body Declarations</h4>
<p>In addition to enum constants, the body of an enum declaration may contain constructor and member declarations as well as instance and static initializers.</p>
<dl>
<dt><em>EnumBodyDeclarations:</em></dt>
<dd><code>;</code> {<em>ClassBodyDeclaration</em>}
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="#jls-8.1.6">8.1.6</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>ClassBodyDeclaration:</em></dt>
<dd><em>ClassMemberDeclaration</em>
</dd>
<dd><em>InstanceInitializer</em>
</dd>
<dd><em>StaticInitializer</em>
</dd>
<dd><em>ConstructorDeclaration</em>
</dd>
<dt><em>ClassMemberDeclaration:</em></dt>
<dd><em>FieldDeclaration</em>
</dd>
<dd><em>MethodDeclaration</em>
</dd>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>InterfaceDeclaration</em>
</dd>
<dd><code>;</code>
</dd>
</dl>
</blockquote>
<p>Any constructor or member declarations in the body of an enum declaration apply to the enum <del>type</del> <strong>class</strong> exactly as if they had been present in the body of a normal class declaration, unless explicitly stated otherwise.</p>
<p>It is a compile-time error if a constructor declaration in an enum declaration is <code>public</code> or <code>protected</code> (<a href="#jls-6.6">6.6</a>).</p>
<p>It is a compile-time error if a constructor declaration in an enum declaration contains a superclass constructor invocation statement (<a href="#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>It is a compile-time error to refer to a <code>static</code> field of an enum <del>type</del> <strong>class</strong> from a constructor, instance initializer, or instance variable initializer of the enum <del>type</del> <strong>declaration</strong>, unless the field is a constant variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>In an enum declaration, a constructor declaration with no access modifiers is <code>private</code>.</p>
<p>In an enum declaration with no constructor declarations, a default constructor is implicitly declared. The default constructor is <code>private</code>, has no formal parameters, and has no <code>throws</code> clause.</p>
<blockquote>
<p>In practice, a compiler is likely to mirror the <code>Enum</code> <del>type</del> <strong>class</strong> by declaring <code>String</code> and <code>int</code> parameters in the default constructor of an enum <del>type</del> <strong>class</strong>. However, these parameters are not specified as &quot;implicitly declared&quot; because different compilers do not need to agree on the form of the default constructor. Only the compiler of an enum <del>type</del> <strong>declaration</strong> knows how to instantiate the enum constants; other compilers can simply rely on the implicitly declared <code>public</code> <code>static</code> fields of the enum <del>type</del> <strong>class</strong> (<a href="#jls-8.9.3">8.9.3</a>) without regard for how those fields were initialized.</p>
</blockquote>
<p>It is a compile-time error if an enum declaration <em>E</em> has an <code>abstract</code> method <em>m</em> as a member, unless <em>E</em> has at least one enum constant and all of <em>E</em>'s enum constants have class bodies that provide concrete implementations of <em>m</em>.</p>
<p>It is a compile-time error for an enum declaration to declare a finalizer (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.6">12.6</a>). An instance of an enum <del>type</del> <strong>class</strong> may never be finalized.</p>
<div class="example">
<p>Example 8.9.2-1. Enum Body Declarations</p>
<pre><code>enum Coin {
    PENNY(1), NICKEL(5), DIME(10), QUARTER(25);
    Coin(int value) { this.value = value; }

    private final int value;
    public int value() { return value; }
}</code></pre>
<p>Each enum constant arranges for a different value in the field <code>value</code>, passed in via a constructor. The field represents the value, in cents, of an American coin. Note that there are no restrictions on the parameters that may be declared by an enum <del>type's</del> <strong>class's</strong> constructor.</p>
</div>
<div class="example">
<p>Example 8.9.2-2. Restriction On Enum Constant Self-Reference</p>
<p>Without the rule on <code>static</code> field access, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum <del>types</del> <strong>classes</strong>. (A circularity exists in any class with a &quot;self-typed&quot; <code>static</code> field.) Here is an example of the sort of code that would fail:</p>
<pre><code>import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;
    Color() { colorMap.put(toString(), this); }

    static final Map&lt;String,Color&gt; colorMap =
        new HashMap&lt;String,Color&gt;();
}</code></pre>
<p>Static initialization of this enum would throw a <code>NullPointerException</code> because the <code>static</code> variable <code>colorMap</code> is uninitialized when the constructors for the enum constants run. The restriction above ensures that such code cannot be compiled. However, the code can easily be refactored to work properly:</p>
<pre><code>import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;

    static final Map&lt;String,Color&gt; colorMap =
        new HashMap&lt;String,Color&gt;();
    static {
        for (Color c : Color.values())
            colorMap.put(c.toString(), c);
    }
}</code></pre>
<p>The refactored version is clearly correct, as static initialization occurs top to bottom.</p>
</div>
<h4 id="jls-8.9.3">8.9.3 Enum Members</h4>
<p>The members of an enum <del>type</del> <strong>class</strong> <em>E</em> are all of the following:</p>
<ul>
<li><p>Members declared in the body of the declaration of <em>E</em>.</p></li>
<li><p>Members inherited from <code>Enum&lt;</code><em>E</em><code>&gt;</code>.</p></li>
<li><p>For each enum constant <em>c</em> declared in the body of the declaration of <em>E</em>, <em>E</em> has an implicitly declared <code>public</code> <code>static</code> <code>final</code> field of type <em>E</em> that has the same name as <em>c</em>. The field has a variable initializer which instantiates <em>E</em> and passes any arguments of <em>c</em> to the constructor chosen for <em>E</em>. The field has the same annotations as <em>c</em> (if any).</p>
<p>These fields are implicitly declared in the same order as the corresponding enum constants, before any <code>static</code> fields explicitly declared in the body of the declaration of <em>E</em>.</p>
<p>An enum constant is said to be <em>created</em> when the corresponding implicitly declared field is initialized.</p></li>
<li><p>An implicitly declared method <code>public</code> <code>static</code> <em>E</em><code>[]</code> <code>values()</code>, which returns an array containing the enum constants of <em>E</em>, in the same order as they appear in the body of the declaration of <em>E</em>.</p></li>
<li><p>An implicitly declared method <code>public</code> <code>static</code> <em>E</em> <code>valueOf(String name)</code>, which returns the enum constant of <em>E</em> with the specified name.</p></li>
<li><p>The following implicitly declared methods:</p>
<pre><code>/**
* Returns an array containing the constants of this enum </code></pre>
<pre class="deleted"><code>* type, in the order they&#39;re declared.  This method may be</code></pre>
<pre class="inserted"><code>* class, in the order they&#39;re declared.  This method may be</code></pre>
<pre><code>* used to iterate over the constants as follows:
*
*    for(E c : E.values())
*        System.out.println(c);
*
* @return an array containing the constants of this enum </code></pre>
<pre class="deleted"><code>* type, in the order they&#39;re declared</code></pre>
<pre class="inserted"><code>* class, in the order they&#39;re declared</code></pre>
<pre><code>*/
public static E[] values();

/**</code></pre>
<pre class="deleted"><code>* Returns the enum constant of this type with the specified</code></pre>
<pre class="inserted"><code>* Returns the enum constant of this class with the specified</code></pre>
<pre><code>* name.
* The string must match exactly an identifier used to declare</code></pre>
<pre class="deleted"><code>* an enum constant in this type.  (Extraneous whitespace </code></pre>
<pre class="inserted"><code>* an enum constant in this class.  (Extraneous whitespace </code></pre>
<pre><code>* characters are not permitted.)
* 
* @return the enum constant with the specified name</code></pre>
<pre class="deleted"><code>* @throws IllegalArgumentException if this enum type has no</code></pre>
<pre class="inserted"><code>* @throws IllegalArgumentException if this enum class has no</code></pre>
<pre><code>* constant with the specified name
*/
public static E valueOf(String name);</code></pre></li>
</ul>
<blockquote>
<p>It follows that the declaration of enum <del>type</del> <strong>class</strong> <em>E</em> cannot contain fields that conflict with the implicitly declared fields corresponding to <em>E</em>'s enum constants, nor contain methods that conflict with implicitly declared methods or override <code>final</code> methods of class <code>Enum&lt;</code><em>E</em><code>&gt;</code>.</p>
</blockquote>
<div class="example">
<p>Example 8.9.3-1. Iterating Over Enum Constants With An Enhanced <code>for</code> Loop</p>
<pre><code>public class Test {
    enum Season { WINTER, SPRING, SUMMER, FALL }

    public static void main(String[] args) {
        for (Season s : Season.values())
            System.out.println(s);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>WINTER
SPRING
SUMMER
FALL</code></pre>
</div>
<div class="example">
<p>Example 8.9.3-2. Switching Over Enum Constants</p>
<p>A <code>switch</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.11">14.11</a>) is useful for simulating the addition of a method to an enum <del>type</del> <strong>class</strong> from outside the <del>type</del> <strong>class</strong>. This example &quot;adds&quot; a <code>color</code> method to the <code>Coin</code> <del>type</del> <strong>class</strong> from <a href="#jls-8.9.2">8.9.2</a>, and prints a table of coins, their values, and their colors.</p>
<pre><code>class Test {
    enum CoinColor { COPPER, NICKEL, SILVER }

    static CoinColor color(Coin c) {
        switch (c) {
            case PENNY:
                return CoinColor.COPPER;
            case NICKEL:
                return CoinColor.NICKEL;
            case DIME: case QUARTER:
                return CoinColor.SILVER;
            default:
                throw new AssertionError(&quot;Unknown coin: &quot; + c);
        }
    }

    public static void main(String[] args) {
        for (Coin c : Coin.values())
            System.out.println(c + &quot;\t\t&quot; +
                               c.value() + &quot;\t&quot; + color(c));
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>PENNY           1       COPPER
NICKEL          5       NICKEL
DIME            10      SILVER
QUARTER         25      SILVER</code></pre>
</div>
<div class="example">
<p>Example 8.9.3-3. Enum Constants with Class Bodies</p>
<pre><code>enum Operation {
    PLUS {
        double eval(double x, double y) { return x + y; }
    },
    MINUS {
        double eval(double x, double y) { return x - y; }
    },
    TIMES {
        double eval(double x, double y) { return x * y; }
    },
    DIVIDED_BY {
        double eval(double x, double y) { return x / y; }
    };

    // Each constant supports an arithmetic operation
    abstract double eval(double x, double y);

    public static void main(String args[]) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        for (Operation op : Operation.values())
            System.out.println(x + &quot; &quot; + op + &quot; &quot; + y +
                               &quot; = &quot; + op.eval(x, y));
    }
}</code></pre>
<p>Class bodies attach behaviors to the enum constants. The program produces the output:</p>
<pre><code>java Operation 2.0 4.0
2.0 PLUS 4.0 = 6.0
2.0 MINUS 4.0 = -2.0
2.0 TIMES 4.0 = 8.0
2.0 DIVIDED_BY 4.0 = 0.5</code></pre>
<p>This pattern is much safer than using a <code>switch</code> statement in the base <del>type</del> <strong>class</strong> (<code>Operation</code>), as the pattern precludes the possibility of forgetting to add a behavior for a new constant (since the enum declaration would cause a compile-time error).</p>
</div>
<div class="example">
<p>Example 8.9.3-4. Multiple Enum <del>Types</del> <strong>Classes</strong></p>
<p>In the following program, a playing card class is built atop two simple enums.</p>
<pre><code>import java.util.List;
import java.util.ArrayList;
class Card implements Comparable&lt;Card&gt;,
                      java.io.Serializable {
    public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX, SEVEN,
                       EIGHT, NINE, TEN,JACK, QUEEN, KING, ACE }

    public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }

    private final Rank rank;
    private final Suit suit;
    public Rank rank() { return rank; }
    public Suit suit() { return suit; }

    private Card(Rank rank, Suit suit) {
        if (rank == null || suit == null)
            throw new NullPointerException(rank + &quot;, &quot; + suit);
        this.rank = rank;
        this.suit = suit;
    }

    public String toString() { return rank + &quot; of &quot; + suit; }

    // Primary sort on suit, secondary sort on rank
    public int compareTo(Card c) {
        int suitCompare = suit.compareTo(c.suit);
        return (suitCompare != 0 ?
                    suitCompare :
                    rank.compareTo(c.rank));
    }

    private static final List&lt;Card&gt; prototypeDeck =
        new ArrayList&lt;Card&gt;(52);

    static {
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values())
                prototypeDeck.add(new Card(rank, suit));
    }

    // Returns a new deck
    public static List&lt;Card&gt; newDeck() {
        return new ArrayList&lt;Card&gt;(prototypeDeck);
    }
}</code></pre>
<p>The following program exercises the <code>Card</code> class. It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand:</p>
<pre><code>import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
class Deal {
    public static void main(String args[]) {
        int numHands     = Integer.parseInt(args[0]);
        int cardsPerHand = Integer.parseInt(args[1]);
        List&lt;Card&gt; deck  = Card.newDeck();
        Collections.shuffle(deck);
        for (int i=0; i &lt; numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    }

    /**
     * Returns a new ArrayList consisting of the last n
     * elements of deck, which are removed from deck.
     * The returned list is sorted using the elements&#39;
     * natural ordering.
     */
    public static &lt;E extends Comparable&lt;E&gt;&gt;
    ArrayList&lt;E&gt; dealHand(List&lt;E&gt; deck, int n) {
        int deckSize = deck.size();
        List&lt;E&gt; handView = deck.subList(deckSize - n, deckSize);
        ArrayList&lt;E&gt; hand = new ArrayList&lt;E&gt;(handView);
        handView.clear();
        Collections.sort(hand);
        return hand;
    }
}</code></pre>
<p>The program produces the output:</p>
<pre><code>java Deal 4 3
[DEUCE of CLUBS, SEVEN of CLUBS, QUEEN of DIAMONDS]
[NINE of HEARTS, FIVE of SPADES, ACE of SPADES]
[THREE of HEARTS, SIX of HEARTS, TEN of SPADES]
[TEN of CLUBS, NINE of DIAMONDS, THREE of SPADES]</code></pre>
</div>
<h2 id="jls-9">Chapter 9: Interfaces</h2>
<p>An interface declaration introduces a new <del>reference type</del> <strong>interface</strong> <del>whose members are classes, interfaces, constants, and methods</del> <strong>that can be implemented by one or more classes</strong>. <strong>Programs can use interfaces to provide a common supertype for otherwise-unrelated classes.</strong></p>
<p><del>This type has</del> <strong>Interfaces have</strong> no instance variables, and typically <del>declares</del> <strong>declare</strong> one or more <code>abstract</code> methods; otherwise unrelated classes can implement <del>the</del> <strong>an</strong> interface by providing implementations for its <code>abstract</code> methods. Interfaces may not be directly instantiated.</p>
<p><del>A <em>nested interface</em> is any interface whose declaration occurs within the body of another class or interface.</del></p>
<p><del>A <em>top level interface</em> is an interface that is not a nested interface.</del></p>
<p><strong>A <em>top level interface</em> (<a href="#jls-7.6">7.6</a>) is an interface that is declared at the top level of a compilation unit.</strong></p>
<p><strong>A <em>nested interface</em> is any interface whose declaration occurs as a <em>member interface</em> (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>) of another class or interface.</strong></p>
<p><del>We distinguish between two kinds of interfaces - normal interfaces and annotation types.</del></p>
<p><strong>An <em>annotation interface</em> (<a href="#jls-9.6">9.6</a>) is an interface declared with special syntax, intended to be implemented by reflective representations of <em>annotations</em> (<a href="#jls-9.7">9.7</a>).</strong></p>
<p>This chapter discusses the common semantics of all interfaces <del>- normal interfaces, both top level (<a href="#jls-7.6">7.6</a>) and nested (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>), and annotation types (<a href="#jls-9.6">9.6</a>)</del>. Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs.</p>
<p><del>Programs can use interfaces to make it unnecessary for related classes to share a common <code>abstract</code> superclass or to add methods to <code>Object</code>.</del></p>
<p>An interface may be declared to be a <em>direct extension</em> of one or more other interfaces, meaning that it inherits all the member <del>types</del> <strong>classes and interfaces</strong>, instance methods, and <del>constants</del> <strong><code>static</code> fields</strong> of the interfaces it extends, except for any members that it may override or hide.</p>
<p>A class may be declared to <em>directly implement</em> one or more interfaces <strong>(<a href="#jls-8.1.5">8.1.5</a>)</strong>, meaning that any instance of the class implements all the <code>abstract</code> methods specified by the interface or interfaces. A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do. This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing a superclass.</p>
<p>A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface. It is not sufficient that the class happen to implement all the <code>abstract</code> methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.</p>
<h3 id="jls-9.1">9.1 Interface Declarations</h3>
<p>An <em>interface declaration</em> specifies <del>a new named reference type</del> <strong>an interface</strong>. There are two kinds of interface declarations - <em>normal interface declarations</em> and <em>annotation <del>type</del> <strong>interface</strong> declarations</em> (<a href="#jls-9.6">9.6</a>).</p>
<dl>
<dt><em>InterfaceDeclaration:</em></dt>
<dd><em>NormalInterfaceDeclaration</em>
</dd>
<dd><em>AnnotationTypeDeclaration</em>
</dd>
<dt><em>NormalInterfaceDeclaration:</em></dt>
<dd>{<em>InterfaceModifier</em>} <code>interface</code> <em>TypeIdentifier</em> [<em>TypeParameters</em>]<br />
[<del><em>ExtendsInterfaces</em></del> <strong><em>InterfaceExtends</em></strong>] <em>InterfaceBody</em>
</dd>
</dl>
<div class="editorial">
<p>The term <em>ExtendsInterfaces</em> incorrectly suggests that the production is a list of interfaces, not interface types. The term <em>InterfaceExtends</em> is aligned with <em>ClassExtends</em> from <a href="#jls-8.1">8.1</a>.</p>
</div>
<p>The <em>TypeIdentifier</em> in an interface declaration specifies the name of the interface.</p>
<p>It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The scope and shadowing of an interface declaration is specified in <a href="#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<h4 id="jls-9.1.1">9.1.1 Interface Modifiers</h4>
<p>An interface declaration may include <em>interface modifiers</em>.</p>
<dl>
<dt><em>InterfaceModifier:</em></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code> <code>protected</code> <code>private</code>
</dd>
<dd><code>abstract</code> <code>static</code> <code>strictfp</code>
</dd>
</dl>
<p>The rules for annotation modifiers on an interface declaration are specified in <a href="#jls-9.7.4">9.7.4</a> and <a href="#jls-9.7.5">9.7.5</a>.</p>
<p><del>The access modifier <code>public</code> (<a href="#jls-6.6">6.6</a>) pertains to every kind of interface declaration.</del></p>
<div class="editorial">
<p>So do <code>abstract</code> and <code>strictfp</code>. Why single this one out?</p>
</div>
<p>The <del>access</del> modifiers <code>protected</code><strong>,</strong> <del>and</del> <code>private</code><strong>, and <code>static</code></strong> pertain only to member interfaces <strong>(<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>)</strong> <del>whose declarations are directly enclosed by a class declaration (<a href="#jls-8.5.1">8.5.1</a>)</del>.</p>
<p><del>The modifier <code>static</code> pertains only to member interfaces (<a href="#jls-8.5.1">8.5.1</a>, <a href="#jls-9.5">9.5</a>), not to top level interfaces (<a href="#jls-7.6">7.6</a>).</del></p>
<div class="editorial">
<p>Compare changes to <a href="#jls-8.1.1">8.1.1</a>.</p>
</div>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="#jls-6.6">6.6</a>).</p>
<blockquote>
<p>If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>InterfaceModifier</em>.</p>
</blockquote>
<h4 id="jls-9.1.3">9.1.3 Superinterfaces <del>and Subinterfaces</del></h4>
<div class="editorial">
<p>The core feature being described here is an interface's set of superinterfaces. &quot;Subinterfaces&quot; is merely a convenient bit of terminology, not significant enough to belong in the title.</p>
</div>
<p>If an <code>extends</code> clause is provided, then the interface being declared extends each of the <del>other named interfaces</del> <strong>listed interface types</strong> and therefore inherits the member <del>types</del> <strong>classes and interfaces</strong>, instance methods, and constants of each of the <del>other named interfaces</del> <strong>listed interface types</strong>.</p>
<p>These <del>other named interfaces</del> <strong>listed interface types</strong> are the <em>direct <del>superinterfaces</del> <strong>superinterface types</strong></em> of the interface being declared.</p>
<p><del>Any class that <code>implements</code> the declared interface is also considered to implement all the interfaces that this interface <code>extends</code>.</del></p>
<div class="editorial">
<p>This is covered by <a href="#jls-8.1.5">8.1.5</a>. Here, &quot;considered to implement&quot; is a vague thing to say.</p>
</div>
<dl>
<dt><del><em>ExtendsInterfaces:</em></del> <strong><em>InterfaceExtends:</em></strong></dt>
<dd><code>extends</code> <em>InterfaceTypeList</em>
</dd>
</dl>
<blockquote>
<p>The following production from <a href="#jls-8.1.5">8.1.5</a> is shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>InterfaceTypeList:</em></dt>
<dd><em>InterfaceType</em> {<code>,</code> <em>InterfaceType</em>}
</dd>
</dl>
</blockquote>
<p>Each <em>InterfaceType</em> in the <code>extends</code> clause of an interface declaration must name an accessible interface type (<a href="#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>If an <em>InterfaceType</em> has type arguments, it must denote a well-formed parameterized type (<a href="#jls-4.5">4.5</a>), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.</p>
<div class="deleted">
<p>Given a (possibly generic) interface declaration <em>I</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> <em>≥</em> 0), the <em>direct superinterfaces</em> of the interface type <em>I</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> are the types given in the <code>extends</code> clause of the declaration of <em>I</em>, if an <code>extends</code> clause is present.</p>
<p>Given a generic interface declaration <em>I</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct superinterfaces</em> of the parameterized interface type <em>I</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code>, where <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) is a type, are all types <em>J</em><code>&lt;</code><em>U<sub>1</sub></em> <em>θ</em>,...,<em>U<sub>k</sub></em> <em>θ</em><code>&gt;</code>, where <em>J</em><code>&lt;</code><em>U<sub>1</sub></em>,...,<em>U<sub>k</sub></em><code>&gt;</code> is a direct superinterface of <em>I</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> and <em>θ</em> is the substitution <code>[F1:=T1,...,Fn:=Tn]</code>.</p>
</div>
<div class="editorial">
<p>Covered by <a href="#jls-4.10.2">4.10.2</a>. This section is only concerned with the superinterface types of an <em>interface</em>, not the superinterface types of types.</p>
</div>
<p><strong>The direct superinterface type of an annotation interface is, implicitly, <code>java.lang.annotation.Annotation</code>.</strong></p>
<p><strong>One interface is a <em>direct superinterface</em> of another interface if the first interface is named by one of the direct superinterface types of the second interface.</strong></p>
<p>The <em>superinterface</em> relationship is the transitive closure of the direct superinterface relationship. An interface <em>K</em> is a superinterface of interface <em>I</em> if either of the following is true:</p>
<ul>
<li><p><em>K</em> is a direct superinterface of <em>I</em>.</p></li>
<li><p><del>There exists an interface <em>J</em> such that</del> <strong>Where <em>J</em> is a direct superinterface of <em>I</em>,</strong> <em>K</em> is a superinterface of <em>J</em>, <del>and <em>J</em> is a superinterface of <em>I</em>,</del> applying this definition recursively.</p></li>
</ul>
<p><del>Interface <em>I</em> is said to be a <em>subinterface</em> of interface <em>K</em> whenever <em>K</em> is a superinterface of <em>I</em>.</del> <strong>An interface is said to be a <em>direct subinterface</em> of its direct superinterface, and a <em>subinterface</em> of each of its superinterfaces.</strong></p>
<div class="editorial">
<p>Presentational changes in these definitions to align with <a href="#jls-8.1.4">8.1.4</a> and <a href="#jls-8.1.5">8.1.5</a>.</p>
</div>
<p>While every class is an extension of class <code>Object</code>, there is no single interface of which all interfaces are extensions.</p>
<p>An interface <em>I</em> <em>directly depends</em> on a <del>type <em>T</em></del> <strong>class or interface <em>A</em></strong> if <del><em>T</em></del> <strong><em>A</em></strong> is mentioned in the <code>extends</code> clause of <em>I</em> either as a superinterface or as a qualifier in the fully qualified form of a superinterface name.</p>
<p>An interface <em>I</em> <em>depends</em> on a <del>reference type <em>T</em></del> <strong>class or interface <em>A</em></strong> if any of the following is true:</p>
<ul>
<li><p><em>I</em> directly depends on <del><em>T</em></del> <strong><em>A</em></strong>.</p></li>
<li><p><em>I</em> directly depends on a class <em>C</em> that depends on <del><em>T</em></del> <strong><em>A</em></strong> (<a href="#jls-8.1.5">8.1.5</a>).</p></li>
<li><p><em>I</em> directly depends on an interface <em>J</em> that depends on <del><em>T</em></del> <strong><em>A</em></strong> (using this definition recursively).</p></li>
</ul>
<p>It is a compile-time error if an interface depends on itself.</p>
<p>If circularly declared interfaces are detected at run time, as interfaces are loaded, then a <code>ClassCircularityError</code> is thrown (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.2.1">12.2.1</a>).</p>
<h4 id="jls-9.1.4">9.1.4 Interface Body and Member Declarations</h4>
<p>The body of an interface may declare members of the interface, that is, fields (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a>), methods (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>), classes (<a href="#jls-9.5">9.5</a>), and interfaces (<a href="#jls-9.5">9.5</a>).</p>
<dl>
<dt><em>InterfaceBody:</em></dt>
<dd><code>{</code> {<em>InterfaceMemberDeclaration</em>} <code>}</code>
</dd>
<dt><em>InterfaceMemberDeclaration:</em></dt>
<dd><em>ConstantDeclaration</em>
</dd>
<dd><em>InterfaceMethodDeclaration</em>
</dd>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>InterfaceDeclaration</em>
</dd>
<dd><code>;</code>
</dd>
</dl>
<p>The scope of a declaration of a member <em>m</em> declared in or inherited by an interface <del>type</del> <em>I</em> is specified in <a href="#jls-6.3">6.3</a>.</p>
<h3 id="jls-9.2">9.2 Interface Members</h3>
<p>The members of an interface <del>type</del> are:</p>
<ul>
<li><p>Members declared in the body of the interface (<a href="#jls-9.1.4">9.1.4</a>).</p></li>
<li><p>Members inherited from any direct <del>superinterfaces</del> <strong>superinterface types</strong> (<a href="#jls-9.1.3">9.1.3</a>).</p></li>
<li><p>If an interface has no direct <del>superinterfaces</del> <strong>superinterface types</strong>, then the interface implicitly declares a <code>public</code> <code>abstract</code> member method <em>m</em> with signature <em>s</em>, return type <em>r</em>, and <code>throws</code> clause <em>t</em> corresponding to each <code>public</code> instance method <em>m</em> with signature <em>s</em>, return type <em>r</em>, and <code>throws</code> clause <em>t</em> declared in <code>Object</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3.2">4.3.2</a>), unless an <code>abstract</code> method with the same signature, same return type, and a compatible <code>throws</code> clause is explicitly declared by the interface.</p>
<p>It is a compile-time error if the interface explicitly declares such a method <em>m</em> in the case where <em>m</em> is declared to be <code>final</code> in <code>Object</code>.</p>
<p>It is a compile-time error if the interface explicitly declares a method with a signature that is override-equivalent (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) to a <code>public</code> method of <code>Object</code>, but which has a different return type, or an incompatible <code>throws</code> clause, or is not <code>abstract</code>.</p></li>
</ul>
<p>The interface inherits, from the interfaces it extends, all members of those interfaces, except for (i) fields, classes, and interfaces that it hides, (ii) <code>abstract</code> methods and default methods that it overrides (<a href="#jls-9.4.1">9.4.1</a>), (iii) <code>private</code> methods, and (iv) <code>static</code> methods.</p>
<p>Fields, methods, and member <del>types</del> <strong>classes and interfaces</strong> of an interface <del>type</del> may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5">6.5</a>). However, this is discouraged as a matter of style.</p>
<h3 id="jls-9.4">9.4 Method Declarations</h3>
<h4 id="jls-9.4.1">9.4.1 Inheritance and Overriding</h4>
<p>An interface <em>I</em> <em>inherits</em> from its direct <del>superinterfaces</del> <strong>superinterface types</strong> all <code>abstract</code> and default methods <em>m</em> for which all of the following are true:</p>
<ul>
<li><p><em>m</em> is a member of a direct superinterface <strong>type</strong>, <em>J</em>, of <em>I</em>.</p></li>
<li><p>No method declared in <em>I</em> has a signature that is a subsignature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the signature of <em>m</em> <strong>as a member of <em>J</em></strong>.</p></li>
<li><p>There exists no method <em>m</em>' that is a member of a direct superinterface <strong>type</strong>, <em>J</em>', of <em>I</em> (<em>m</em> distinct from <em>m</em>', <em>J</em> distinct from <em>J</em>'), such that <em>m</em>' overrides from <strong>the interface of</strong> <em>J</em>' the declaration of the method <em>m</em>.</p></li>
</ul>
<blockquote>
<p>Note that methods are overridden on a signature-by-signature basis. If, for example, an interface declares two <code>public</code> methods with the same name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4.2">9.4.2</a>), and a subinterface overrides one of them, the subinterface still inherits the other method.</p>
</blockquote>
<blockquote>
<p>The third clause above prevents a subinterface from re-inheriting a method that has already been overridden by another of its superinterfaces. For example, in this program:</p>
</blockquote>
<blockquote>
<pre><code>interface Top {
    default String name() { return &quot;unnamed&quot;; }
}
interface Left extends Top {
    default String name() { return getClass().getName(); }
}
interface Right extends Top {}

interface Bottom extends Left, Right {}</code></pre>
</blockquote>
<blockquote>
<p><code>Right</code> inherits <code>name()</code> from <code>Top</code>, but <code>Bottom</code> inherits <code>name()</code> from <code>Left</code>, not <code>Right</code>. This is because <code>name()</code> from <code>Left</code> overrides the declaration of <code>name()</code> in <code>Top</code>.</p>
</blockquote>
<p>An interface does not inherit <code>private</code> or <code>static</code> methods from its superinterfaces.</p>
<p>If an interface <em>I</em> declares a <code>private</code> or <code>static</code> method <em>m</em>, and the signature of <em>m</em> is a subsignature of a <code>public</code> instance method <em>m</em>' in a superinterface <strong>type</strong> of <em>I</em>, and <em>m</em>' would otherwise be accessible to code in <em>I</em>, then a compile-time error occurs.</p>
<blockquote>
<p>In essence, a <code>static</code> method in an interface cannot hide an instance method in a superinterface <strong>type</strong>. This is similar to the rule in <a href="#jls-8.4.8.2">8.4.8.2</a> whereby a <code>static</code> method in a class cannot hide an instance method in a superclass <strong>type</strong> or superinterface <strong>type</strong>. Note that the rule in <a href="#jls-8.4.8.2">8.4.8.2</a> speaks of a class that &quot;declares or inherits a <code>static</code> method&quot;, whereas the rule above speaks only of an interface that &quot;declares a <code>static</code> method&quot;, since an interface cannot inherit a <code>static</code> method. Also note that the rule in <a href="#jls-8.4.8.2">8.4.8.2</a> allows hiding of both instance and <code>static</code> methods in superclasses/superinterfaces, whereas the rule above considers only <code>public</code> instance methods in <del>superinterfaces</del> <strong>superinterface types</strong>.</p>
</blockquote>
<blockquote>
<p>Along the same lines, a <code>private</code> method in an interface cannot override an instance method - whether <code>public</code> or <code>private</code> - in a superinterface <strong>type</strong>. This is similar to the rules in <a href="#jls-8.4.8.1">8.4.8.1</a> and <a href="#jls-8.4.8.3">8.4.8.3</a> whereby a <code>private</code> method in a class cannot override any instance method in a superclass <strong>type</strong> or superinterface <strong>type</strong>, because <a href="#jls-8.4.8.1">8.4.8.1</a> requires the overridden method to be non-<code>private</code> and <a href="#jls-8.4.8.3">8.4.8.3</a> requires the overriding method to provide at least as much access as the overridden method. In summary, only <code>public</code> methods in interfaces can be overridden, and only by <code>public</code> methods in subinterfaces or in implementing classes.</p>
</blockquote>
<h5 id="jls-9.4.1.1">9.4.1.1 Overriding (by Instance Methods)</h5>
<p>An instance method <em>m<sub>I</sub></em> declared in or inherited by interface <em>I</em>, <em>overrides from I</em> another instance method <em>m<sub>J</sub></em> declared in interface <em>J</em>, iff all of the following are true:</p>
<ul>
<li><p><em>I</em> is a subinterface of <em>J</em>.</p></li>
<li><p><em>I</em> does not inherit <em>m<sub>J</sub></em>.</p></li>
<li><p>The signature of <em>m<sub>I</sub></em> is a subsignature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the signature of <em>m<sub>J</sub></em> <strong>as a member of the supertype of <em>I</em> that names <em>J</em></strong>.</p></li>
<li><p><em>m<sub>J</sub></em> is <code>public</code>.</p></li>
</ul>
<p>The presence or absence of the <code>strictfp</code> modifier has absolutely no effect on the rules for overriding methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.</p>
<blockquote>
<p>An overridden default method can be accessed by using a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>) that contains the keyword <code>super</code> qualified by a superinterface name.</p>
</blockquote>
<h3 id="jls-9.5">9.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</h3>
<p>Interfaces may contain member <del>type</del> <strong>class and interface</strong> declarations (<a href="#jls-8.5">8.5</a>).</p>
<p>Every member <del>type</del> <strong>class or interface</strong> declaration in the body of an interface is implicitly <code>public</code> and <code>static</code>. It is permitted to redundantly specify either or both of these modifiers.</p>
<p>It is a compile-time error if a member <del>type</del> <strong>class or interface</strong> declaration in an interface has the modifier <code>protected</code> or <code>private</code>.</p>
<p><del>It is a compile-time error if the same keyword appears more than once as a modifier for a member type declaration in an interface.</del></p>
<div class="editorial">
<p>This is already stated in <a href="#jls-8.1.1">8.1.1</a> and <a href="#jls-9.1.1">9.1.1</a>.</p>
</div>
<p>If an interface declares a member <del>type</del> <strong>class or interface</strong> with a certain name, then the declaration of that <del>type</del> <strong>class or interface</strong> is said to <em>hide</em> any and all accessible declarations of member <del>types</del> <strong>classes and interfaces</strong> with the same name in superinterfaces of the interface.</p>
<p>An interface inherits from its direct superinterfaces all the <del>non-<code>private</code></del> member <del>types</del> <strong>classes and interfaces</strong> of the superinterfaces that are <del>both accessible to code in the interface and</del> not hidden by a declaration in the interface.</p>
<div class="editorial">
<p>All member classes and interfaces of the superinterfaces are <code>public</code>, so we don't need to consider their acccessibility here.</p>
</div>
<p>It is possible for an interface to inherit more than one member <del>type</del> <strong>class or interface</strong> with the same name. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the interface to refer to any such member <del>type</del> <strong>class or interface</strong> by its simple name will result in a compile-time error, because the reference is ambiguous.</p>
<p>There might be several paths by which the same member <del>type</del> <strong>class or interface</strong> declaration is inherited from an interface. In such a situation, the member <del>type</del> <strong>class or interface</strong> is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.</p>
<h3 id="jls-9.6">9.6 Annotation <del>Types</del> <strong>Interfaces</strong></h3>
<p>An <em>annotation <del>type</del> declaration</em> specifies a new <em>annotation <del>type</del> <strong>interface</strong></em>, a special kind of interface <del>type</del>. To distinguish an annotation <del>type</del> declaration from a normal interface declaration, the keyword <code>interface</code> is preceded by an <del>at-sign</del> <strong>at sign</strong> (<code>@</code>).</p>
<dl>
<dt><del><em>AnnotationTypeDeclaration:</em></del> <strong><em>AnnotationDeclaration:</em></strong></dt>
<dd>{<em>InterfaceModifier</em>} <code>@</code> <code>interface</code> <em>TypeIdentifier</em> <del><em>AnnotationTypeBody</em></del> <strong><em>AnnotationInterfaceBody</em></strong>
</dd>
</dl>
<blockquote>
<p>Note that the <del>at-sign</del> <strong>at sign</strong> (<code>@</code>) and the keyword <code>interface</code> are distinct tokens. It is possible to separate them with whitespace, but this is discouraged as a matter of style.</p>
</blockquote>
<p>The rules for annotation modifiers on an annotation <del>type</del> declaration are specified in <a href="#jls-9.7.4">9.7.4</a> and <a href="#jls-9.7.5">9.7.5</a>.</p>
<p>The <em>TypeIdentifier</em> in an annotation <del>type</del> declaration specifies the name of the annotation <del>type</del> <strong>interface</strong>.</p>
<p>It is a compile-time error if an annotation <del>type</del> <strong>interface</strong> has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The direct superinterface <strong>type</strong> of every annotation <del>type</del> <strong>interface</strong> is <code>java.lang.annotation.Annotation</code> <strong>(<a href="#jls-9.1.3">9.1.3</a>)</strong>.</p>
<blockquote>
<p>By virtue of the <del><em>AnnotationTypeDeclaration</em></del> <strong><em>AnnotationInterfaceDeclaration</em></strong> syntax, an annotation <del>type</del> <strong>interface</strong> declaration cannot be generic, and no <code>extends</code> clause is permitted.</p>
</blockquote>
<blockquote>
<p>A consequence of the fact that an annotation <del>type</del> <strong>interface</strong> cannot explicitly declare a superclass <strong>type</strong> or superinterface <strong>type</strong> is that a <del>subclass or</del> subinterface of an annotation <del>type</del> <strong>interface</strong> is never itself an annotation <del>type</del> <strong>interface</strong>. Similarly, <code>java.lang.annotation.Annotation</code> is not itself an annotation <del>type</del> <strong>interface</strong>.</p>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> inherits several members from <code>java.lang.annotation.Annotation</code>, including the implicitly declared methods corresponding to the instance methods of <code>Object</code>, yet these methods do not define elements of the annotation <del>type</del> <strong>interface</strong> (<a href="#jls-9.6.1">9.6.1</a>).</p>
<blockquote>
<p>Because these methods do not define elements of the annotation <del>type</del> <strong>interface</strong>, it is illegal to use them in annotations of that type (<a href="#jls-9.7">9.7</a>). Without this rule, we could not ensure that elements were of the types representable in annotations, or that accessor methods for them would be available.</p>
</blockquote>
<p>Unless explicitly modified herein, all of the rules that apply to normal interface declarations apply to annotation <del>type</del> declarations.</p>
<blockquote>
<p>For example, annotation <del>types</del> <strong>interfaces</strong> share the same namespace as normal <del>class and interface types</del> <strong>classes and interfaces</strong>; and annotation <del>type</del> declarations <del>are legal wherever interface declarations are legal, and</del> have the same scope and accessibility <strong>as interface declarations</strong>.</p>
</blockquote>
<h4 id="jls-9.6.1">9.6.1 Annotation <del>Type</del> Elements</h4>
<p>The body of an annotation <del>type</del> declaration may contain method declarations, each of which defines an <em>element</em> of the annotation <del>type</del> <strong>interface</strong>. An annotation <del>type</del> <strong>interface</strong> has no elements other than those defined by the methods it explicitly declares.</p>
<dl>
<dt><del><em>AnnotationTypeBody:</em></del> <strong><em>AnnotationInterfaceBody:</em></strong></dt>
<dd><code>{</code> { <del><em>AnnotationTypeMemberDeclaration</em></del> <strong><em>AnnotationMemberDeclaration</em></strong> } <code>}</code>
</dd>
<dt><del><em>AnnotationTypeMemberDeclaration:</em></del> <strong><em>AnnotationMemberDeclaration:</em></strong></dt>
<dd><del><em>AnnotationTypeElementDeclaration</em></del> <strong><em>AnnotationElementDeclaration</em></strong>
</dd>
<dd><em>ConstantDeclaration</em>
</dd>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>InterfaceDeclaration</em>
</dd>
<dd><code>;</code>
</dd>
<dt><del><em>AnnotationTypeElementDeclaration:</em></del> <strong><em>AnnotationElementDeclaration:</em></strong></dt>
<dd>{ <del><em>AnnotationTypeElementModifier</em></del> <strong><em>AnnotationElementModifier</em></strong> } <em>UnannType</em> <em>Identifier</em> <code>(</code> <code>)</code> [<em>Dims</em>]<br />
[<em>DefaultValue</em>] <code>;</code>
</dd>
<dt><del><em>AnnotationTypeElementModifier:</em></del> <strong><em>AnnotationElementModifier:</em></strong></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code>
</dd>
<dd><code>abstract</code>
</dd>
</dl>
<blockquote>
<p>By virtue of the <del><em>AnnotationTypeElementDeclaration</em></del> <strong><em>AnnotationElementDeclaration</em></strong> production, a method declaration in an annotation <del>type</del> declaration cannot have formal parameters, type parameters, or a <code>throws</code> clause. The following production from <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3">4.3</a> is shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>Dims:</em></dt>
<dd>{<em>Annotation</em>} <code>[</code> <code>]</code> {{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<blockquote>
<p>By virtue of the <del><em>AnnotationTypeElementModifier</em></del> <strong><em>AnnotationElementModifier</em></strong> production, a method declaration in an annotation <del>type</del> declaration cannot be <code>default</code> or <code>static</code>. Thus, an annotation <del>type</del> <strong>interface</strong> cannot declare the same variety of methods as a normal interface <del>type</del>. Note that it is still possible for an annotation <del>type</del> <strong>interface</strong> to inherit a default method from its implicit superinterface, <code>java.lang.annotation.Annotation</code>, though no such default method exists as of Java SE 14.</p>
</blockquote>
<blockquote>
<p>By convention, the only <del><em>AnnotationTypeElementModifier</em>s</del> <strong><em>AnnotationElementModifier</em>s</strong> that should be present on an annotation <del>type</del> element <strong>declaration</strong> are annotations.</p>
</blockquote>
<p>The return type of a method declared in an annotation <del>type</del> <strong>interface</strong> must be one of the following, or a compile-time error occurs:</p>
<ul>
<li><p>A primitive type</p></li>
<li><p><code>String</code></p></li>
<li><p><code>Class</code> or an invocation of <code>Class</code> (<a href="#jls-4.5">4.5</a>)</p></li>
<li><p>An enum <strong>class</strong> type</p></li>
<li><p>An annotation <strong>interface</strong> type</p></li>
<li><p>An array type whose component type is one of the preceding types (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.1">10.1</a>).</p></li>
</ul>
<blockquote>
<p>This rule precludes elements with nested array types, such as:</p>
<pre><code>@interface Verboten {
    String[][] value();
}</code></pre>
</blockquote>
<p>The declaration of a method that returns an array is allowed to place the bracket pair that denotes the array type after the empty formal parameter list. This syntax is supported for compatibility with early versions of the Java programming language. It is very strongly recommended that this syntax is not used in new code.</p>
<p>It is a compile-time error if any method declared in an annotation <del>type</del> <strong>interface</strong> has a signature that is override-equivalent to that of any <code>public</code> or <code>protected</code> method declared in class <code>Object</code> or in the interface <code>java.lang.annotation.Annotation</code>.</p>
<p>It is a compile-time error if <del>an annotation type declaration</del> <strong>a declaration of an annotation interface</strong> <em>T</em> contains an element of type <em>T</em>, either directly or indirectly.</p>
<blockquote>
<p>For example, this is illegal:</p>
<pre><code>@interface SelfRef { SelfRef value(); }</code></pre>
<p>and so is this:</p>
<pre><code>@interface Ping { Pong value(); }
@interface Pong { Ping value(); }</code></pre>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> with no elements is called a <em>marker annotation <del>type</del> <strong>interface</strong></em>.</p>
<p>An annotation <del>type</del> <strong>interface</strong> with one element is called a <em>single-element annotation <del>type</del> <strong>interface</strong></em>.</p>
<p>By convention, the name of the sole element in a single-element annotation <del>type</del> <strong>interface</strong> is <code>value</code>. Linguistic support for this convention is provided by single-element annotations (<a href="#jls-9.7.3">9.7.3</a>).</p>
<div class="example">
<p>Example 9.6.1-1. Annotation <del>Type</del> Declaration</p>
<p>The following annotation <del>type</del> declaration defines an annotation <del>type</del> <strong>interface</strong> with several elements:</p>
<pre><code>/**
 * Describes the &quot;request-for-enhancement&quot; (RFE)
 * that led to the presence of the annotated API element.
 */
@interface RequestForEnhancement {
    int    id();        // Unique ID number associated with RFE
    String synopsis();  // Synopsis of RFE
    String engineer();  // Name of engineer who implemented RFE
    String date();      // Date RFE was implemented
}</code></pre>
</div>
<div class="example">
<p>Example 9.6.1-2. Marker Annotation <del>Type</del> Declaration</p>
<p>The following annotation <del>type</del> declaration defines a marker annotation <del>type</del> <strong>interface</strong>:</p>
<pre><code>/**
 * An annotation with this type indicates that the 
 * specification of the annotated API element is 
 * preliminary and subject to change.
 */
@interface Preliminary {}</code></pre>
</div>
<div class="example">
<p>Example 9.6.1-3. Single-Element Annotation <del>Type</del> Declarations</p>
<p>The convention that a single-element annotation <del>type</del> <strong>interface</strong> defines an element called <code>value</code> is illustrated in the following annotation <del>type</del> declaration:</p>
<pre><code>/**
 * Associates a copyright notice with the annotated API element.
 */
@interface Copyright {
    String value();
}</code></pre>
<p>The following annotation <del>type</del> declaration defines a single-element annotation <del>type</del> <strong>interface</strong> whose sole element has an array type:</p>
<pre><code>/**
 * Associates a list of endorsers with the annotated class.
 */
@interface Endorsers {
    String[] value();
}</code></pre>
<p>The following annotation <del>type</del> declaration shows a <code>Class</code>-typed element whose value is constrained by a bounded wildcard:</p>
<pre><code>interface Formatter {}

// Designates a formatter to pretty-print the annotated class
@interface PrettyPrinter {
    Class&lt;? extends Formatter&gt; value();
}</code></pre>
<p>The following annotation <del>type</del> declaration contains an element whose type is also an annotation <strong>interface</strong> type:</p>
<pre><code>/**
 * Indicates the author of the annotated program element.
 */
@interface Author {
    Name value();
}
/**</code></pre>
<pre class="deleted"><code> * A person&#39;s name.  This annotation type is not designed
 * to be used directly to annotate program elements, but to
 * define elements of other annotation types.</code></pre>
<pre class="inserted"><code> * A person&#39;s name.  This annotation interface is not designed
 * to be used directly to annotate program elements, but to
 * define elements of other annotation interfaces.</code></pre>
<pre><code>*/
@interface Name {
   String first();
   String last();
}</code></pre>
<p>The grammar for annotation <del>type</del> declarations permits other <del>element</del> <strong>member</strong> declarations besides <del>method</del> <strong>element</strong> declarations. For example, one might choose to declare a nested enum for use in conjunction with an annotation <del>type</del> <strong>interface</strong>:</p>
<pre><code>@interface Quality {
    enum Level { BAD, INDIFFERENT, GOOD }
    Level value();
}</code></pre>
</div>
<h4 id="jls-9.6.2">9.6.2 Defaults for Annotation <del>Type</del> Elements</h4>
<p>An annotation <del>type</del> element <strong>declaration</strong> may have a <em>default value</em>, specified by following the element's (empty) parameter list with the keyword <code>default</code> and an <em>ElementValue</em> (<a href="#jls-9.7.1">9.7.1</a>).</p>
<dl>
<dt><em>DefaultValue:</em></dt>
<dd><code>default</code> <em>ElementValue</em>
</dd>
</dl>
<p>It is a compile-time error if the type of the element is not commensurate (<a href="#jls-9.7">9.7</a>) with the default value specified.</p>
<p>Default values are not compiled into annotations, but rather applied dynamically at the time annotations are read. Thus, changing a default value affects annotations even in classes that were compiled before the change was made (presuming these annotations lack an explicit value for the defaulted element).</p>
<div class="example">
<p>Example 9.6.2-1. Annotation <del>Type</del> Declaration With Default Values</p>
<p>Here is a refinement of the <code>RequestForEnhancement</code> annotation <del>type</del> <strong>interface</strong> from <a href="#jls-9.6.1">9.6.1</a>:</p>
<pre><code>@interface RequestForEnhancementDefault {
    int    id();       // No default - must be specified in 
                       // each annotation
    String synopsis(); // No default - must be specified in 
                       // each annotation
    String engineer()  default &quot;[unassigned]&quot;;
    String date()      default &quot;[unimplemented]&quot;;
}</code></pre>
</div>
<h4 id="jls-9.6.3">9.6.3 Repeatable Annotation <del>Types</del> <strong>Interfaces</strong></h4>
<p>An annotation <del>type <em>T</em></del> <strong>interface <em>A</em></strong> is <em>repeatable</em> if its declaration is (meta-)annotated with an <code>@Repeatable</code> annotation (<a href="#jls-9.6.4.8">9.6.4.8</a>) whose <code>value</code> element indicates a <em>containing annotation <del>type</del> <strong>interface</strong> of <del>T</del> <strong>A</strong></em>.</p>
<p>An annotation <del>type <em>TC</em></del> <strong>interface <em>AC</em></strong> is a <em>containing annotation <del>type</del> <strong>interface</strong> of <del>T</del> <strong>A</strong></em> if all of the following are true:</p>
<ol type="1">
<li><p><del><em>TC</em></del> <strong><em>AC</em></strong> declares a <code>value()</code> <del>method</del> <strong>element</strong> whose return type is <del><em>T</em><code>[]</code></del> <strong><em>A</em><code>[]</code></strong>.</p></li>
<li><p>Any <del>methods</del> <strong>elements</strong> declared by <del><em>TC</em></del> <strong><em>AC</em></strong> other than <code>value()</code> have a default value.</p></li>
<li><p><del><em>TC</em></del> <strong><em>AC</em></strong> is retained for at least as long as <del><em>T</em></del> <strong><em>A</em></strong>, where retention is expressed explicitly or implicitly with the <code>@Retention</code> annotation (<a href="#jls-9.6.4.2">9.6.4.2</a>). Specifically:</p>
<ul>
<li><p>If the retention of <del><em>TC</em></del> <strong><em>AC</em></strong> is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>, then the retention of <del><em>T</em></del> <strong><em>A</em></strong> is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>.</p></li>
<li><p>If the retention of <del><em>TC</em></del> <strong><em>AC</em></strong> is <code>java.lang.annotation.RetentionPolicy.CLASS</code>, then the retention of <del><em>T</em></del> <strong><em>A</em></strong> is either <code>java.lang.annotation.RetentionPolicy.CLASS</code> or <code>java.lang.annotation.RetentionPolicy.SOURCE</code>.</p></li>
<li><p>If the retention of <del><em>TC</em></del> <strong><em>AC</em></strong> is <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>, then the retention of <del><em>T</em></del> <strong><em>A</em></strong> is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>, <code>java.lang.annotation.RetentionPolicy.CLASS</code>, or <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>.</p></li>
</ul></li>
<li><p><del><em>T</em></del> <strong><em>A</em></strong> is applicable to at least the same kinds of program element as <del><em>TC</em></del> <strong><em>AC</em></strong> (<a href="#jls-9.6.4.1">9.6.4.1</a>). Specifically, if the kinds of program element where <del><em>T</em></del> <strong><em>A</em></strong> is applicable are denoted by the set <em>m<sub>1</sub></em>, and the kinds of program element where <del><em>TC</em></del> <strong><em>AC</em></strong> is applicable are denoted by the set <em>m<sub>2</sub></em>, then each kind in <em>m<sub>2</sub></em> must occur in <em>m<sub>1</sub></em>, except that:</p>
<ul>
<li><p>If the kind in <em>m<sub>2</sub></em> is <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code>, then at least one of <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code> or <code>java.lang.annotation.ElementType.TYPE</code> or <code>java.lang.annotation.ElementType.TYPE_USE</code> must occur in <em>m<sub>1</sub></em>.</p></li>
<li><p>If the kind in <em>m<sub>2</sub></em> is <code>java.lang.annotation.ElementType.TYPE</code>, then at least one of <code>java.lang.annotation.ElementType.TYPE</code> or <code>java.lang.annotation.ElementType.TYPE_USE</code> must occur in <em>m<sub>1</sub></em>.</p></li>
<li><p>If the kind in <em>m<sub>2</sub></em> is <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code>, then at least one of <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code> or <code>java.lang.annotation.ElementType.TYPE_USE</code> must occur in <em>m<sub>1</sub></em>.</p></li>
</ul>
<blockquote>
<p>This clause implements the policy that an annotation <del>type</del> <strong>interface</strong> may be <em>repeatable</em> on only some of the kinds of program element where it is <em>applicable</em>.</p>
</blockquote></li>
<li><p>If the declaration of <del><em>T</em></del> <strong><em>A</em></strong> has a (meta-)annotation that corresponds to <code>java.lang.annotation.Documented</code>, then the declaration of <del><em>TC</em></del> <strong><em>AC</em></strong> must have a (meta-)annotation that corresponds to <code>java.lang.annotation.Documented</code>.</p>
<blockquote>
<p>Note that it is permissible for <del><em>TC</em></del> <strong><em>AC</em></strong> to be <code>@Documented</code> while <del><em>T</em></del> <strong><em>A</em></strong> is not <code>@Documented</code>.</p>
</blockquote></li>
<li><p>If the declaration of <del><em>T</em></del> <strong><em>A</em></strong> has a (meta-)annotation that corresponds to <code>java.lang.annotation.Inherited</code>, then the declaration of <del><em>TC</em></del> <strong><em>AC</em></strong> must have a (meta)-annotation that corresponds to <code>java.lang.annotation.Inherited</code>.</p>
<blockquote>
<p>Note that it is permissible for <del><em>TC</em></del> <strong><em>AC</em></strong> to be <code>@Inherited</code> while <del><em>T</em></del> <strong><em>A</em></strong> is not <code>@Inherited</code>.</p>
</blockquote></li>
</ol>
<p>It is a compile-time error if an annotation <del>type <em>T</em></del> <strong>interface <em>A</em></strong> is (meta-)annotated with an <code>@Repeatable</code> annotation whose <code>value</code> element indicates a type which is not a containing annotation <del>type</del> <strong>interface</strong> of <em>T</em>.</p>
<div class="example">
<p>Example 9.6.3-1. Ill-formed Containing Annotation <del>Type</del> <strong>Interface</strong></p>
<p>Consider the following declarations:</p>
<pre><code>import java.lang.annotation.Repeatable;

@Repeatable(FooContainer.class)
@interface Foo {}

@interface FooContainer { Object[] value(); }</code></pre>
<p>Compiling the <code>Foo</code> declaration produces a compile-time error because <code>Foo</code> uses <code>@Repeatable</code> to attempt to specify <code>FooContainer</code> as its containing annotation <del>type</del> <strong>interface</strong>, but <code>FooContainer</code> is not in fact a containing annotation <del>type</del> <strong>interface</strong> of <code>Foo</code>. (The return type of <code>FooContainer.value()</code> is not <code>Foo[]</code>.)</p>
</div>
<p>The <code>@Repeatable</code> annotation cannot be repeated, so only one containing annotation <del>type</del> <strong>interface</strong> can be specified by a repeatable annotation <del>type</del> <strong>interface</strong>.</p>
<blockquote>
<p>Allowing more than one containing annotation <del>type</del> <strong>interface</strong> to be specified would cause an undesirable choice at compile time, when multiple annotations of the repeatable annotation <del>type</del> <strong>interface</strong> are logically replaced with a container annotation (<a href="#jls-9.7.5">9.7.5</a>).</p>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> can be the containing annotation <del>type</del> <strong>interface</strong> of at most one annotation <del>type</del> <strong>interface</strong>.</p>
<blockquote>
<p>This is implied by the requirement that if the declaration of an annotation <del>type <em>T</em></del> <strong>interface <em>A</em></strong> specifies a containing annotation <del>type</del> <strong>interface</strong> of <del><em>TC</em></del> <strong><em>AC</em></strong>, then the <code>value()</code> method of <del><em>TC</em></del> <strong><em>AC</em></strong> has a return type involving <del><em>T</em></del> <strong><em>A</em></strong>, specifically <del><em>T</em><code>[]</code></del> <strong><em>A</em><code>[]</code></strong>.</p>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> cannot specify itself as its containing annotation <del>type</del> <strong>interface</strong>.</p>
<blockquote>
<p>This is implied by the requirement on the <code>value()</code> method of the containing annotation <del>type</del> <strong>interface</strong>. Specifically, if an annotation <del>type</del> <strong>interface</strong> <em>A</em> specified itself (via <code>@Repeatable</code>) as its containing annotation <del>type</del> <strong>interface</strong>, then the return type of <em>A</em>'s <code>value()</code> method would have to be <em>A</em><code>[]</code>; but this would cause a compile-time error since an annotation <del>type</del> <strong>interface</strong> cannot refer to itself in its elements (<a href="#jls-9.6.1">9.6.1</a>). More generally, two annotation <del>types</del> <strong>interfaces</strong> cannot specify each other to be their containing annotation <del>types</del> <strong>interfaces</strong>, because cyclic annotation <del>type</del> <strong>interface</strong> declarations are illegal.</p>
</blockquote>
<p>An annotation <del>type <em>TC</em></del> <strong>interface <em>AC</em></strong> may be the containing annotation <del>type</del> <strong>interface</strong> of some annotation <del>type <em>T</em></del> <strong>interface <em>A</em></strong> while also having its own containing annotation <del>type <em>TC</em> '</del> <strong>interface <em>AC</em> '</strong>. That is, a containing annotation <del>type</del> <strong>interface</strong> may itself be a repeatable annotation <del>type</del> <strong>interface</strong>.</p>
<div class="example">
<p>Example 9.6.3-2. Restricting Where Annotations May Repeat</p>
<p>An annotation whose <del>type</del> declaration indicates a target of <code>java.lang.annotation.ElementType.TYPE</code> can appear in at least as many locations as an annotation whose <del>type</del> declaration indicates a target of <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code>. For example, given the following declarations of repeatable and containing annotation <del>types</del> <strong>interfaces</strong>:</p>
<pre><code>import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;

@Target(ElementType.TYPE)
@Repeatable(FooContainer.class)
@interface Foo {}

@Target(ElementType.ANNOTATION_TYPE)
@interface FooContainer {
    Foo[] value();
}</code></pre>
<p><code>@Foo</code> can appear on any <del>type</del> <strong>class or interface</strong> declaration while <code>@FooContainer</code> can appear on only annotation <del>type</del> <strong>interface</strong> declarations. Therefore, the following annotation <del>type</del> <strong>interface</strong> declaration is legal:</p>
<pre><code>@Foo @Foo
@interface Anno {}</code></pre>
<p>while the following interface declaration is illegal:</p>
<pre><code>@Foo @Foo
interface Intf {}</code></pre>
<p>More broadly, if <code>Foo</code> is a repeatable annotation <del>type</del> <strong>interface</strong> and <code>FooContainer</code> is its containing annotation <del>type</del> <strong>interface</strong>, then:</p>
<ul>
<li><p>If <code>Foo</code> has no <code>@Target</code> meta-annotation and <code>FooContainer</code> has no <code>@Target</code> meta-annotation, then <code>@Foo</code> may be repeated on any program element which supports annotations.</p></li>
<li><p>If <code>Foo</code> has no <code>@Target</code> meta-annotation but <code>FooContainer</code> has an <code>@Target</code> meta-annotation, then <code>@Foo</code> may only be repeated on program elements where <code>@FooContainer</code> may appear.</p></li>
<li><p>If <code>Foo</code> has an <code>@Target</code> meta-annotation, then in the judgment of the designers of the Java programming language, <code>FooContainer</code> must be declared with knowledge of the <code>Foo</code>'s applicability. Specifically, the kinds of program element where <code>FooContainer</code> may appear must logically be the same as, or a subset of, <code>Foo</code>'s kinds.</p>
<p>For example, if <code>Foo</code> is applicable to field and method declarations, then <code>FooContainer</code> may legitimately serve as <code>Foo</code>'s containing annotation <del>type</del> <strong>interface</strong> if <code>FooContainer</code> is applicable to just field declarations (preventing <code>@Foo</code> from being repeated on method declarations). But if <code>FooContainer</code> is applicable only to formal parameter declarations, then <code>FooContainer</code> was a poor choice of containing annotation <del>type</del> <strong>interface</strong> by <code>Foo</code> because <code>@FooContainer</code> cannot be implicitly declared on some program elements where <code>@Foo</code> is repeated.</p>
<p>Similarly, if <code>Foo</code> is applicable to field and method declarations, then <code>FooContainer</code> cannot legitimately serve as <code>Foo</code>'s containing annotation <del>type</del> <strong>interface</strong> if <code>FooContainer</code> is applicable to field and parameter declarations. While it would be possible to take the intersection of the program elements and make <code>Foo</code> repeatable on field declarations only, the presence of additional program elements for <code>FooContainer</code> indicates that <code>FooContainer</code> was not designed as a containing annotation <del>type</del> <strong>interface</strong> for <code>Foo</code>. It would therefore be dangerous for <code>Foo</code> to rely on it.</p></li>
</ul>
</div>
<div class="example">
<p>Example 9.6.3-3. A Repeatable Containing Annotation <del>Type</del> <strong>Interface</strong></p>
<p>The following declarations are legal:</p>
<pre><code>import java.lang.annotation.Repeatable;
</code></pre>
<pre class="deleted"><code>// Foo: Repeatable annotation type</code></pre>
<pre class="inserted"><code>// Foo: Repeatable annotation interface</code></pre>
<pre><code>@Repeatable(FooContainer.class)
@interface Foo { int value(); }</code></pre>
<pre class="deleted"><code>// FooContainer: Containing annotation type of Foo
//               Also a repeatable annotation type itself</code></pre>
<pre class="inserted"><code>// FooContainer: Containing annotation interface of Foo
//               Also a repeatable annotation interface itself</code></pre>
<pre><code>@Repeatable(FooContainerContainer.class)
@interface FooContainer { Foo[] value(); }</code></pre>
<pre class="deleted"><code>// FooContainerContainer: Containing annotation type of FooContainer</code></pre>
<pre class="inserted"><code>// FooContainerContainer: Containing annotation interface of FooContainer</code></pre>
<pre><code>@interface FooContainerContainer { FooContainer[] value(); }</code></pre>
<p>Thus, an annotation whose <del>type</del> <strong>interface</strong> is a containing annotation <del>type</del> <strong>interface</strong> may itself be repeated:</p>
<pre><code>@FooContainer({@Foo(1)}) @FooContainer({@Foo(2)})
class Test {}</code></pre>
<p>An annotation <del>type</del> <strong>interface</strong> which is both repeatable and containing is subject to the rules on mixing annotations of <em>a</em> repeatable annotation <del>type</del> <strong>interface</strong> with annotations of <em>a</em> containing annotation <del>type</del> <strong>interface</strong> (<a href="#jls-9.7.5">9.7.5</a>). For example, it is not possible to write multiple <code>@Foo</code> annotations alongside multiple <code>@FooContainer</code> annotations, nor is it possible to write multiple <code>@FooContainer</code> annotations alongside multiple <code>@FooContainerContainer</code> annotations. However, if the <code>FooContainerContainer</code> <del>type</del> <strong>annotation interface</strong> was itself repeatable, then it would be possible to write multiple <code>@Foo</code> annotations alongside multiple <code>@FooContainerContainer</code> annotations.</p>
</div>
<h4 id="jls-9.6.4">9.6.4 Predefined Annotation <del>Types</del> <strong>Interfaces</strong></h4>
<p>Several annotation <del>types</del> <strong>interfaces</strong> are predefined in the libraries of the Java SE Platform. Some of these predefined annotation <del>types</del> <strong>interfaces</strong> have special semantics. These semantics are specified in this section. This section does not provide a complete specification for the predefined annotations contained here in; that is the role of the appropriate API specifications. Only those semantics that require special behavior on the part of a Java compiler or Java Virtual Machine implementation are specified here.</p>
<h5 id="jls-9.6.4.1">9.6.4.1 <code>@Target</code></h5>
<p>An annotation of type <code>java.lang.annotation.Target</code> is used on the declaration of an annotation <del>type</del> <strong>interface</strong> <em>T</em> to specify the contexts in which <em>T</em> is <em>applicable</em>. <code>java.lang.annotation.Target</code> has a single element, <code>value</code>, of type <code>java.lang.annotation.ElementType[]</code>, to specify contexts.</p>
<p>Annotation <del>types</del> <strong>interfaces</strong> may be applicable in <em>declaration contexts</em>, where annotations apply to declarations, or in <em>type contexts</em>, where annotations apply to types used in declarations and expressions.</p>
<p>There are nine declaration contexts, each corresponding to an enum constant of <code>java.lang.annotation.ElementType</code>:</p>
<ol type="1">
<li><p>Module declarations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7">7.7</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.MODULE</code></p></li>
<li><p>Package declarations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.4.1">7.4.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PACKAGE</code></p></li>
<li><p>Type declarations: class, interface, enum, and annotation <del>type</del> declarations (<a href="#jls-8.1.1">8.1.1</a>, <a href="#jls-9.1.1">9.1.1</a>, <a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>, <a href="#jls-8.9">8.9</a>, <a href="#jls-9.6">9.6</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE</code></p>
<p>Additionally, annotation <del>type</del> declarations correspond to <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code></p></li>
<li><p>Method declarations (including elements of annotation <del>types</del> <strong>interfaces</strong>) (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.3">8.4.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="#jls-9.6.1">9.6.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.METHOD</code></p></li>
<li><p>Constructor declarations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.3">8.8.3</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.CONSTRUCTOR</code></p></li>
<li><p>Type parameter declarations of generic classes, interfaces, methods, and constructors (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code></p></li>
<li><p>Field declarations (including enum constants) (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3.1">8.3.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.3">9.3</a>, <a href="#jls-8.9.1">8.9.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.FIELD</code></p></li>
<li><p>Formal and exception parameter declarations (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PARAMETER</code></p></li>
<li><p>Local variable declarations (including loop variables of <code>for</code> statements and resource variables of <code>try</code>-with-resources statements) (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.LOCAL_VARIABLE</code></p></li>
</ol>
<p>There are 16 type contexts (<a href="#jls-4.11">4.11</a>), all represented by the enum constant <code>TYPE_USE</code> of <code>java.lang.annotation.ElementType</code>.</p>
<p>It is a compile-time error if the same enum constant appears more than once in the <code>value</code> element of an annotation of type <code>java.lang.annotation.Target</code>.</p>
<p>If an annotation of type <code>java.lang.annotation.Target</code> is not present on the declaration of an annotation <del>type</del> <strong>interface</strong> <em>T</em>, then <em>T</em> is applicable in all nine declaration contexts and in all 16 type contexts.</p>
<h5 id="jls-9.6.4.2">9.6.4.2 <code>@Retention</code></h5>
<p>Annotations may be present only in source code, or they may be present in the binary form of a class or interface. An annotation that is present in the binary form may or may not be available at run time via the reflection libraries of the Java SE Platform. The annotation <del>type</del> <strong>interface</strong> <code>java.lang.annotation.Retention</code> is used to choose among these possibilities.</p>
<p>If an annotation <em>a</em> corresponds to <del>a type</del> <strong>an annotation interface</strong> <em>T</em>, and <em>T</em> has a (meta-)annotation <em>m</em> that corresponds to <code>java.lang.annotation.Retention</code>, then:</p>
<ul>
<li><p>If <em>m</em> has an element whose value is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>, then a Java compiler must ensure that <em>a</em> is not present in the binary representation of the class or interface in which <em>a</em> appears.</p></li>
<li><p>If <em>m</em> has an element whose value is <code>java.lang.annotation.RetentionPolicy.CLASS</code> or <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>, then a Java compiler must ensure that <em>a</em> is represented in the binary representation of the class or interface in which <em>a</em> appears, unless <em>a</em> annotates a local variable declaration or <em>a</em> annotates a formal parameter declaration of a lambda expression.</p>
<p>An annotation on the declaration of a local variable, or on the declaration of a formal parameter of a lambda expression, is never retained in the binary representation. In contrast, an annotation on the type of a local variable, or on the type of a formal parameter of a lambda expression, is retained in the binary representation if the annotation <del>type</del> <strong>interface</strong> specifies a suitable retention policy.</p>
<blockquote>
<p>Note that it is not illegal for an annotation <del>type</del> <strong>interface</strong> to be meta-annotated with <code>@Target(java.lang.annotation.ElementType.LOCAL_VARIABLE)</code> <em>and</em> <code>@Retention(java.lang.annotation.RetentionPolicy.CLASS)</code> or <code>@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</code>.</p>
</blockquote>
<p>If <em>m</em> has an element whose value is <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>, the reflection libraries of the Java SE Platform must make <em>a</em> available at run time.</p></li>
</ul>
<p>If <em>T</em> does not have a (meta-)annotation <em>m</em> that corresponds to <code>java.lang.annotation.Retention</code>, then a Java compiler must treat <em>T</em> as if it does have such a meta-annotation <em>m</em> with an element whose value is <code>java.lang.annotation.RetentionPolicy.CLASS</code>.</p>
<h5 id="jls-9.6.4.3">9.6.4.3 <code>@Inherited</code></h5>
<p>The annotation <del>type</del> <strong>interface</strong> <code>java.lang.annotation.Inherited</code> is used to indicate that annotations on a class <em>C</em> corresponding to a given annotation <del>type</del> <strong>interface</strong> are inherited by subclasses of <em>C</em>.</p>
<h5 id="jls-9.6.4.4">9.6.4.4 <code>@Override</code></h5>
<p>Programmers occasionally overload a method declaration when they mean to override it, leading to subtle problems. The annotation <del>type</del> <strong>interface</strong> <code>Override</code> supports early detection of such problems.</p>
<blockquote>
<p>The classic example concerns the <code>equals</code> method. Programmers write the following in class <code>Foo</code>:</p>
<pre><code>public boolean equals(Foo that) { ... }</code></pre>
<p>when they mean to write:</p>
<pre><code>public boolean equals(Object that) { ... }</code></pre>
<p>This is perfectly legal, but class <code>Foo</code> inherits the <code>equals</code> implementation from <code>Object</code>, which can cause some subtle bugs.</p>
</blockquote>
<p>If a method declaration in <del>type</del> <strong>class or interface</strong> <em>T</em> is annotated with <code>@Override</code>, but the method does not override from <em>T</em> a method declared in a supertype of <em>T</em> (<a href="#jls-8.4.8.1">8.4.8.1</a>, <a href="#jls-9.4.1.1">9.4.1.1</a>), or is not override-equivalent to a <code>public</code> method of <code>Object</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3.2">4.3.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>), then a compile-time error occurs.</p>
<blockquote>
<p>This behavior differs from Java SE 5.0, where <code>@Override</code> only caused a compile-time error if applied to a method that implemented a method from a superinterface that was not also present in a superclass.</p>
</blockquote>
<blockquote>
<p>The clause about overriding a <code>public</code> method is motivated by use of <code>@Override</code> in an interface. Consider the following <del>type</del> declarations:</p>
<pre><code>class Foo     { @Override public int hashCode() {..} }
interface Bar { @Override int hashCode(); }</code></pre>
<p>The use of <code>@Override</code> in the class declaration is legal by the first clause, because <code>Foo.hashCode</code> overrides from <code>Foo</code> the method <code>Object.hashCode</code>.</p>
<p>For the interface declaration, consider that while an interface does not have <code>Object</code> as a supertype, an interface does have <code>public</code> <code>abstract</code> members that correspond to the <code>public</code> members of <code>Object</code> (<a href="#jls-9.2">9.2</a>). If an interface chooses to declare them explicitly (that is, to declare members that are override-equivalent to <code>public</code> methods of <code>Object</code>), then the interface is deemed to override them, and use of <code>@Override</code> is allowed.</p>
<p>However, consider an interface that attempts to use <code>@Override</code> on a <code>clone</code> method: (<code>finalize</code> could also be used in this example)</p>
<pre><code>interface Quux { @Override Object clone(); }</code></pre>
<p>Because <code>Object.clone</code> is not <code>public</code>, there is no member called <code>clone</code> implicitly declared in <code>Quux</code>. Therefore, the explicit declaration of <code>clone</code> in <code>Quux</code> is not deemed to &quot;implement&quot; any other method, and it is erroneous to use <code>@Override</code>. (The fact that <code>Quux.clone</code> is <code>public</code> is not relevant.)</p>
<p>In contrast, a class declaration that declares <code>clone</code> is simply overriding <code>Object.clone</code>, so is able to use <code>@Override</code>:</p>
<pre><code>class Beep { @Override protected Object clone() {..} }</code></pre>
</blockquote>
<h5 id="jls-9.6.4.5">9.6.4.5 <code>@SuppressWarnings</code></h5>
<p>Java compilers are increasingly capable of issuing helpful &quot;lint-like&quot; warnings. To encourage the use of such warnings, there should be some way to disable a warning in a part of the program when the programmer knows that the warning is inappropriate.</p>
<p>The annotation <del>type</del> <strong>interface</strong> <code>SuppressWarnings</code> supports programmer control over warnings otherwise issued by a Java compiler. It defines a single element that is an array of <code>String</code>.</p>
<p>If a declaration is annotated with <code>@SuppressWarnings(value = {S1, ..., Sk})</code>, then a Java compiler must suppress (that is, not report) any warning specified by one of <em>S<sub>1</sub></em> ... <em>S<sub>k</sub></em> if that warning would have been generated as a result of the annotated declaration or any of its parts.</p>
<p>The Java programming language defines four kinds of warnings that can be specified by <code>@SuppressWarnings</code>:</p>
<ul>
<li><p>Unchecked warnings (<a href="#jls-4.8">4.8</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.6">5.1.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.9">5.1.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="#jls-8.4.8.3">8.4.8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.4.2">15.12.4.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.13.2">15.13.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.27.3">15.27.3</a>) are specified by the string &quot;<code>unchecked</code>&quot;.</p></li>
<li><p>Deprecation warnings (<a href="#jls-9.6.4.6">9.6.4.6</a>) are specified by the string &quot;<code>deprecation</code>&quot;.</p></li>
<li><p>Removal warnings (<a href="#jls-9.6.4.6">9.6.4.6</a>) are specified by the string &quot;<code>removal</code>&quot;.</p></li>
<li><p>Preview warnings (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-1.html#jls-1.5">1.5</a>) are specified by the string &quot;<code>preview</code>&quot;.</p></li>
</ul>
<p>Any other string specifies a non-standard warning. A Java compiler must ignore any such string that it does not recognize.</p>
<blockquote>
<p>Compiler vendors are encouraged to document the strings they support for <code>@SuppressWarnings</code>, and to cooperate to ensure that the same strings are recognized across multiple compilers.</p>
</blockquote>
<h5 id="jls-9.6.4.6">9.6.4.6 <code>@Deprecated</code></h5>
<p>Programmers are sometimes discouraged from using certain program elements (modules, <del>types</del> <strong>classes, interfaces</strong>, fields, methods, and constructors) because they are dangerous or because a better alternative exists. The annotation <del>type</del> <strong>interface</strong> <code>Deprecated</code> allows a compiler to warn about uses of these program elements.</p>
<p>A <em>deprecated</em> program element is a module, <del>type</del> <strong>class, interface</strong>, field, method, or constructor whose declaration is annotated with <code>@Deprecated</code>. The manner in which a program element is deprecated depends on the value of the <code>forRemoval</code> element of the annotation:</p>
<ul>
<li><p>If <code>forRemoval=false</code> (the default), then the program element is <em>ordinarily deprecated</em>.</p>
<p>An ordinarily deprecated program element is not intended to be removed in a future release, but programmers should nevertheless migrate away from using it.</p></li>
<li><p>If <code>forRemoval=true</code>, then the program element is <em>terminally deprecated</em>.</p>
<p>A terminally deprecated program element is intended to be removed in a future release. Programmers should stop using it or risk source and binary incompatibilities (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-13.html#jls-13.2">13.2</a>) when upgrading to a newer release.</p></li>
</ul>
<p>A Java compiler must produce a <em>deprecation warning</em> when an ordinarily deprecated program element is used (overridden, invoked, or referenced by name) in the declaration of a program element (whether explicitly or implicitly declared), unless:</p>
<ul>
<li><p>The use is within a declaration that is itself deprecated, either ordinarily or terminally; or</p></li>
<li><p>The use is within a declaration that is annotated to suppress deprecation warnings (<a href="#jls-9.6.4.5">9.6.4.5</a>); or</p></li>
<li><p>The declaration where the use appears and the declaration of the ordinarily deprecated program element are both within the same outermost class; or</p></li>
<li><p>The use is within an <code>import</code> declaration that imports the ordinarily deprecated type or member; or</p></li>
<li><p>The use is within an <code>exports</code> or <code>opens</code> directive (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.2">7.7.2</a>).</p></li>
</ul>
<p>A Java compiler must produce a <em>removal warning</em> when a terminally deprecated program element is used (overridden, invoked, or referenced by name) in the declaration of a program element (whether explicitly or implicitly declared), unless:</p>
<ul>
<li><p>The use is within a declaration that is annotated to suppress removal warnings (<a href="#jls-9.6.4.5">9.6.4.5</a>); or</p></li>
<li><p>The declaration where the use appears and the declaration of the terminally deprecated program element are both within the same outermost class; or</p></li>
<li><p>The use is within an <code>import</code> declaration that imports the terminally deprecated <del>type</del> <strong>class, interface,</strong> or member; or</p></li>
<li><p>The use is within an <code>exports</code> or <code>opens</code> directive.</p></li>
</ul>
<blockquote>
<p>Terminal deprecation is sufficiently urgent that the use of a terminally deprecated element will cause a removal warning <em>even if the using element is itself deprecated</em>, since there is no guarantee that both elements will be removed at the same time. To dismiss the warning but continue using the element, the programmer must manually acknowledge the risk via an <code>@SuppressWarnings</code> annotation.</p>
</blockquote>
<p>No deprecation warning or removal warning is produced when:</p>
<ul>
<li><p>a local variable or formal parameter is used (referenced by name), even if the declaration of the local variable or formal parameter is annotated with <code>@Deprecated</code>.</p></li>
<li><p>the name of a package is used (referenced by a qualified type name, or an <code>import</code> declaration, or an <code>exports</code> or <code>opens</code> directive), even if the declaration of the package is annotated with <code>@Deprecated</code>.</p></li>
<li><p>the name of a module is used by a qualified <code>exports</code> or <code>opens</code> directive, even if the declaration of the friend module is annotated with <code>@Deprecated</code>.</p></li>
</ul>
<blockquote>
<p>A module declaration that exports or opens a package is usually controlled by the same programmer or team that controls the package's declaration. As such, there is little benefit in warning that the package declaration is annotated with <code>@Deprecated</code> when the package is exported or opened by the module declaration. In contrast, a module declaration that exports or opens a package <em>to a friend module</em> is usually not controlled by the same programmer or team that controls the friend module. Simply exporting or opening the package does not make the module declaration rely on the friend module, so there is little value in warning if the friend module is deprecated; the programmer of the module declaration would almost always wish to suppress such a warning.</p>
</blockquote>
<blockquote>
<p>The only implicit declaration that can cause a deprecation warning or removal warning is a container annotation (<a href="#jls-9.7.5">9.7.5</a>). Namely, if <em>T</em> is a repeatable annotation <del>type</del> <strong>interface</strong> and <em>TC</em> is its containing annotation <del>type</del> <strong>interface</strong>, and <em>TC</em> is deprecated, then repeating the <code>@T</code> annotation will cause a warning. The warning is due to the implicit <code>@TC</code> container annotation. It is strongly discouraged to deprecate a containing annotation <del>type</del> <strong>interface</strong> without deprecating the corresponding repeatable annotation <del>type</del> <strong>interface</strong>.</p>
</blockquote>
<h5 id="jls-9.6.4.7">9.6.4.7 <code>@SafeVarargs</code></h5>
<p>A variable arity parameter with a non-reifiable element type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.7">4.7</a>) can cause heap pollution (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.2">4.12.2</a>) and give rise to compile-time unchecked warnings (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.9">5.1.9</a>). Such warnings are uninformative if the body of the variable arity method is well-behaved with respect to the variable arity parameter.</p>
<p>The annotation <del>type</del> <strong>interface</strong> <code>SafeVarargs</code>, when used to annotate a method or constructor declaration, makes a programmer assertion that prevents a Java compiler from reporting unchecked warnings for the declaration or invocation of a variable arity method or constructor where the compiler would otherwise do so due to the variable arity parameter having a non-reifiable element type.</p>
<blockquote>
<p>The annotation <code>@SafeVarargs</code> has non-local effects because it suppresses unchecked warnings at method invocation expressions, in addition to an unchecked warning pertaining to the declaration of the variable arity method itself (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">8.4.1</a>). In contrast, the annotation <code>@SuppressWarnings(&quot;unchecked&quot;)</code> has local effects because it only suppresses unchecked warnings pertaining to the declaration of a method.</p>
</blockquote>
<blockquote>
<p>The canonical target for <code>@SafeVarargs</code> is a method like <code>java.util.Collections.addAll</code>, whose declaration starts with:</p>
<pre><code>public static &lt;T&gt; boolean
  addAll(Collection&lt;? super T&gt; c, T... elements)</code></pre>
<p>The variable arity parameter has declared type <code>T[]</code>, which is non-reifiable. However, the method fundamentally just reads from the input array and adds the elements to a collection, both of which are safe operations with respect to the array. Therefore, any compile-time unchecked warnings at method invocation expressions for <code>java.util.Collections.addAll</code> are arguably spurious and uninformative. Applying <code>@SafeVarargs</code> to the method declaration prevents generation of these unchecked warnings at the method invocation expressions.</p>
</blockquote>
<p>It is a compile-time error if a fixed arity method or constructor declaration is annotated with the annotation <code>@SafeVarargs</code>.</p>
<p>It is a compile-time error if a variable arity method declaration that is neither <code>static</code> nor <code>final</code> nor <code>private</code> is annotated with the annotation <code>@SafeVarargs</code>.</p>
<blockquote>
<p>Since <code>@SafeVarargs</code> is only applicable to <code>static</code> methods, <code>final</code> and/or <code>private</code> instance methods, and constructors, the annotation is not usable where method overriding occurs. Annotation inheritance only works for annotations on classes (not on methods, interfaces, or constructors), so an <code>@SafeVarargs</code>-style annotation cannot be passed through instance methods in classes or through interfaces.</p>
</blockquote>
<h5 id="jls-9.6.4.8">9.6.4.8 <code>@Repeatable</code></h5>
<p>The annotation <del>type</del> <strong>interface</strong> <code>java.lang.annotation.Repeatable</code> is used on the declaration of a <em>repeatable annotation <del>type</del> <strong>interface</strong></em> to indicate its containing annotation <del>type</del> <strong>interface</strong> (<a href="#jls-9.6.3">9.6.3</a>).</p>
<blockquote>
<p>Note that an <code>@Repeatable</code> meta-annotation on the declaration of <em>T</em>, indicating <em>TC</em>, is <em>not</em> sufficient to make <em>TC</em> the containing annotation <del>type</del> <strong>interface</strong> of <em>T</em>. There are numerous well-formedness rules for <em>TC</em> to be considered the containing annotation <del>type</del> <strong>interface</strong> of <em>T</em>.</p>
</blockquote>
<h5 id="jls-9.6.4.9">9.6.4.9 <code>@FunctionalInterface</code></h5>
<p>The annotation <del>type</del> <strong>interface</strong> <code>FunctionalInterface</code> is used to indicate that an interface is meant to be a functional interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.8">9.8</a>). It facilitates early detection of inappropriate method declarations appearing in or inherited by an interface that is meant to be functional.</p>
<p>It is a compile-time error if an interface declaration is annotated with <code>@FunctionalInterface</code> but is not, in fact, a functional interface.</p>
<p>Because some interfaces are functional incidentally, it is not necessary or desirable that all declarations of functional interfaces be annotated with <code>@FunctionalInterface</code>.</p>
<h3 id="jls-9.7">9.7 Annotations</h3>
<p>An <em>annotation</em> is a marker which associates information with a program construct, but has no effect at run time. An annotation denotes a specific <del>invocation</del> <strong>instance</strong> of an annotation <del>type</del> <strong>interface</strong> (<a href="#jls-9.6">9.6</a>) and usually provides values for the elements of that <del>type</del> <strong>interface</strong>.</p>
<p>There are three kinds of annotations. The first kind is the most general, while the other kinds are merely shorthands for the first kind.</p>
<dl>
<dt><em>Annotation:</em></dt>
<dd><em>NormalAnnotation</em>
</dd>
<dd><em>MarkerAnnotation</em>
</dd>
<dd><em>SingleElementAnnotation</em>
</dd>
</dl>
<p>Normal annotations are described in <a href="#jls-9.7.1">9.7.1</a>, marker annotations in <a href="#jls-9.7.2">9.7.2</a>, and single element annotations in <a href="#jls-9.7.3">9.7.3</a>. Annotations may appear at various syntactic locations in a program, as described in <a href="#jls-9.7.4">9.7.4</a>. The number of annotations of the same <del>type</del> <strong>interface</strong> that may appear at a location is determined by <del>their type</del> <strong>the interface declaration</strong>, as described in <a href="#jls-9.7.5">9.7.5</a>.</p>
<h4 id="jls-9.7.1">9.7.1 Normal Annotations</h4>
<p>A <em>normal annotation</em> specifies the name of an annotation <del>type</del> <strong>interface</strong> and optionally a list of comma-separated <em>element-value pairs</em>. Each pair contains an <em>element value</em> that is associated with an element of the annotation <del>type</del> <strong>interface</strong> (<a href="#jls-9.6.1">9.6.1</a>).</p>
<dl>
<dt><em>NormalAnnotation:</em></dt>
<dd><code>@</code> <em>TypeName</em> <code>(</code> [<em>ElementValuePairList</em>] <code>)</code>
</dd>
<dt><em>ElementValuePairList:</em></dt>
<dd><em>ElementValuePair</em> {<code>,</code> <em>ElementValuePair</em>}
</dd>
<dt><em>ElementValuePair:</em></dt>
<dd><em>Identifier</em> <code>=</code> <em>ElementValue</em>
</dd>
<dt><em>ElementValue:</em></dt>
<dd><em>ConditionalExpression</em>
</dd>
<dd><em>ElementValueArrayInitializer</em>
</dd>
<dd><em>Annotation</em>
</dd>
<dt><em>ElementValueArrayInitializer:</em></dt>
<dd><code>{</code> [<em>ElementValueList</em>] [<code>,</code>] <code>}</code>
</dd>
<dt><em>ElementValueList:</em></dt>
<dd><em>ElementValue</em> {<code>,</code> <em>ElementValue</em>}
</dd>
</dl>
<blockquote>
<p>Note that the at-sign (<code>@</code>) is a token unto itself (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.11">3.11</a>). It is possible to put whitespace between it and the <em>TypeName</em>, but this is discouraged as a matter of style.</p>
</blockquote>
<p>The <em>TypeName</em> specifies the annotation <del>type</del> <strong>interface</strong> corresponding to the annotation. The annotation is said to be &quot;of&quot; that <del>type</del> <strong>interface</strong>.</p>
<p>The <em>TypeName</em> must name an accessible annotation <del>type</del> <strong>interface</strong> (<a href="#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>The <em>Identifier</em> in an element-value pair must be the simple name of one of the elements (that is, methods) of the annotation <del>type</del> <strong>interface</strong>, or a compile-time error occurs.</p>
<p>The return type of this method defines the <em>element type</em> of the element-value pair.</p>
<p>If the element type is an array type, then it is not required to use curly braces to specify the element value of the element-value pair. If the element value is not an <em>ElementValueArrayInitializer</em>, then an array value whose sole element is the element value is associated with the element. If the element value is an <em>ElementValueArrayInitializer</em>, then the array value represented by the <em>ElementValueArrayInitializer</em> is associated with the element.</p>
<p>It is a compile-time error if the element type is not <em>commensurate</em> with the element value. An element type <em>T</em> is commensurate with an element value <em>V</em> if and only if one of the following is true:</p>
<ul>
<li><p><em>T</em> is an array type <em>E</em><code>[]</code>, and either:</p>
<ul>
<li><p>If <em>V</em> is a <em>ConditionalExpression</em> or an <em>Annotation</em>, then <em>V</em> is commensurate with <em>E</em>; or</p></li>
<li><p>If <em>V</em> is an <em>ElementValueArrayInitializer</em>, then each element value that <em>V</em> contains is commensurate with <em>E</em>.</p>
<blockquote>
<p>An <em>ElementValueArrayInitializer</em> is similar to a normal array initializer ([10.6]), except that an <em>ElementValueArrayInitializer</em> may syntactically contain annotations as well as expressions and nested initializers. However, nested initializers are not semantically legal in an <em>ElementValueArrayInitializer</em> because they are never commensurate with array-typed elements in annotation <del>type</del> <strong>interface</strong> declarations (nested array types not permitted).</p>
</blockquote></li>
</ul></li>
<li><p><em>T</em> is not an array type, and the type of <em>V</em> is assignment compatible ([5.2]) with <em>T</em>, and:</p>
<ul>
<li><p>If <em>T</em> is a primitive type or <code>String</code>, then <em>V</em> is a constant expression ([15.29]).</p></li>
<li><p>If <em>T</em> is <code>Class</code> or an invocation of <code>Class</code> (<a href="#jls-4.5">4.5</a>), then <em>V</em> is a class literal (<a href="#jls-15.8.2">15.8.2</a>).</p></li>
<li><p>If <em>T</em> is an enum <strong>class</strong> type (<a href="#jls-8.9">8.9</a>), then <em>V</em> is an enum constant (<a href="#jls-8.9.1">8.9.1</a>).</p></li>
<li><p><em>V</em> is not <code>null</code>.</p></li>
</ul></li>
</ul>
<blockquote>
<p>Note that if <em>T</em> is not an array type or an annotation <strong>interface</strong> type, the element value must be a <em>ConditionalExpression</em> ([15.25]). The use of <em>ConditionalExpression</em> rather than a more general production like <em>Expression</em> is a syntactic trick to prevent assignment expressions as element values. Since an assignment expression is not a constant expression, it cannot be a commensurate element value for a primitive or <code>String</code>-typed element.</p>
</blockquote>
<blockquote>
<p>Formally, it is invalid to speak of an <em>ElementValue</em> as FP-strict (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.4">15.4</a>) because it might be an annotation or a class literal. Still, we can speak informally of <em>ElementValue</em> as FP-strict when it is either a constant expression or an array of constant expressions or an annotation whose element values are (recursively) found to be constant expressions; after all, every constant expression is FP-strict.</p>
</blockquote>
<p>A normal annotation must contain an element-value pair for every element of the corresponding annotation <del>type</del> <strong>interface</strong>, except for those elements with default values, or a compile-time error occurs.</p>
<p>A normal annotation may, but is not required to, contain element-value pairs for elements with default values.</p>
<blockquote>
<p>It is customary, though not required, that element-value pairs in an annotation are presented in the same order as the corresponding elements in the annotation <del>type</del> declaration.</p>
</blockquote>
<p>An annotation on an annotation <del>type</del> declaration is known as a <em>meta-annotation</em>.</p>
<p>An annotation of <del>type <em>T</em></del> <strong>interface <em>A</em></strong> may appear as a meta-annotation on the declaration of <del>type <em>T</em></del> <strong>the interface <em>A</em></strong> itself. More generally, circularities in the transitive closure of the &quot;annotates&quot; relation are permitted.</p>
<blockquote>
<p>For example, it is legal to annotate the declaration of an annotation <del>type</del> <strong>interface</strong> <em>S</em> with a meta-annotation of <del>type</del> <strong>interface</strong> <em>T</em>, and to annotate <em>T</em>'s own declaration with a meta-annotation of <del>type</del> <strong>interface</strong> <em>S</em>. The pre-defined annotation <del>types</del> <strong>interfaces</strong> contain several such circularities.</p>
</blockquote>
<div class="example">
<p>Example 9.7.1-1. Normal Annotations</p>
<p>Here is an example of a normal annotation using the annotation <del>type</del> <strong>interface</strong> from <a href="#jls-9.6.1">9.6.1</a>:</p>
<pre><code>@RequestForEnhancement(
    id       = 2868724,
    synopsis = &quot;Provide time-travel functionality&quot;,
    engineer = &quot;Mr. Peabody&quot;,
    date     = &quot;4/1/2004&quot;
)
public static void travelThroughTime(Date destination) { ... }</code></pre>
<p>Here is an example of a normal annotation that takes advantage of default values, using the annotation <del>type</del> <strong>interface</strong> from <a href="#jls-9.6.2">9.6.2</a>:</p>
<pre><code>@RequestForEnhancement(
    id       = 4561414,
    synopsis = &quot;Balance the federal budget&quot;
)
public static void balanceFederalBudget() {
    throw new UnsupportedOperationException(&quot;Not implemented&quot;);
}</code></pre>
</div>
<h4 id="jls-9.7.2">9.7.2 Marker Annotations</h4>
<p>A <em>marker annotation</em> is a shorthand designed for use with marker annotation <del>types</del> <strong>interfaces</strong> (<a href="#jls-9.6.1">9.6.1</a>).</p>
<dl>
<dt><em>MarkerAnnotation:</em></dt>
<dd><code>@</code> <em>TypeName</em>
</dd>
</dl>
<p>It is shorthand for the normal annotation:</p>
<pre><code>@*TypeName*()</code></pre>
<p>It is legal to use marker annotations for annotation <del>types</del> <strong>interfaces</strong> with elements, so long as all the elements have default values (<a href="#jls-9.6.2">9.6.2</a>).</p>
<div class="example">
<p>Example 9.7.2-1. Marker Annotations</p>
<p>Here is an example using the <code>Preliminary</code> marker annotation <del>type</del> <strong>interface</strong> from <a href="#jls-9.6.1">9.6.1</a>:</p>
<pre><code>@Preliminary public class TimeTravel { ... }</code></pre>
</div>
<h4 id="jls-9.7.3">9.7.3 Single-Element Annotations</h4>
<p>A <em>single-element annotation</em>, is a shorthand designed for use with single-element annotation <del>types</del> <strong>interfaces</strong> (<a href="#jls-9.6.1">9.6.1</a>).</p>
<dl>
<dt><em>SingleElementAnnotation:</em></dt>
<dd><code>@</code> <em>TypeName</em> <code>(</code> <em>ElementValue</em> <code>)</code>
</dd>
</dl>
<p>It is shorthand for the normal annotation:</p>
<pre><code>@*TypeName*(value = *ElementValue*)</code></pre>
<p>It is legal to use single-element annotations for annotation <del>types</del> <strong>interfaces</strong> with multiple elements, so long as one element is named <code>value</code> and all other elements have default values (<a href="#jls-9.6.2">9.6.2</a>).</p>
<div class="example">
<p>Example 9.7.3-1. Single-Element Annotations</p>
<p>The following annotations all use the single-element annotation <del>types</del> <strong>interfaces</strong> from <a href="#jls-9.6.1">9.6.1</a>.</p>
<p>Here is an example of a single-element annotation:</p>
<pre><code>@Copyright(&quot;2002 Yoyodyne Propulsion Systems, Inc.&quot;)
public class OscillationOverthruster { ... }</code></pre>
<p>Here is an example of an array-valued single-element annotation:</p>
<pre><code>@Endorsers({&quot;Children&quot;, &quot;Unscrupulous dentists&quot;})
public class Lollipop { ... }</code></pre>
<p>Here is an example of a single-element array-valued single-element annotation: (note that the curly braces are omitted)</p>
<pre><code>@Endorsers(&quot;Epicurus&quot;)
public class Pleasure { ... }</code></pre>
<p>Here is an example of a single-element annotation with a <code>Class</code>-typed element whose value is constrained by a bounded wildcard.</p>
<pre><code>class GorgeousFormatter implements Formatter { ... }

@PrettyPrinter(GorgeousFormatter.class)
public class Petunia { ... }

// Illegal; String is not a subtype of Formatter
@PrettyPrinter(String.class)
public class Begonia { ... }</code></pre>
<p>Here is an example <del>with</del> of a single-element annotation that contains a normal annotation:</p>
<pre><code>@Author(@Name(first = &quot;Joe&quot;, last = &quot;Hacker&quot;))
public class BitTwiddle { ... }</code></pre>
<p>Here is an example of a single-element annotation that uses an enum <del>type</del> <strong>class</strong> defined inside the annotation <del>type</del> <strong>declaration</strong>:</p>
<pre><code>@Quality(Quality.Level.GOOD)
public class Karma { ... }</code></pre>
</div>
<h4 id="jls-9.7.4">9.7.4 Where Annotations May Appear</h4>
<p>A <em>declaration annotation</em> is an annotation that applies to a declaration, and whose <del>own type</del> <strong>annotation interface</strong> is applicable in the declaration context (<a href="#jls-9.6.4.1">9.6.4.1</a>) represented by that declaration; or an annotation that applies to a class, interface, <del>enum, annotation type,</del> or type parameter declaration, and whose <del>own type</del> <strong>annotation interface</strong> is applicable in type contexts (<a href="#jls-4.11">4.11</a>).</p>
<p>A <em>type annotation</em> is an annotation that applies to a type (or any part of a type), and whose <del>own type</del> <strong>annotation interface</strong> is applicable in type contexts.</p>
<blockquote>
<p>For example, given the field declaration:</p>
<pre><code>@Foo int f;</code></pre>
<p><code>@Foo</code> is a declaration annotation on <code>f</code> if <code>Foo</code> is meta-annotated by <code>@Target(ElementType.FIELD)</code>, and a type annotation on <code>int</code> if <code>Foo</code> is meta-annotated by <code>@Target(ElementType.TYPE_USE)</code>. It is possible for <code>@Foo</code> to be both a declaration annotation and a type annotation simultaneously.</p>
<p>Type annotations can apply to an array type or any component type thereof (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.1">10.1</a>). For example, assuming that <code>A</code>, <code>B</code>, and <code>C</code> are annotation <del>types</del> <strong>interfaces</strong> meta-annotated with <code>@Target(ElementType.TYPE_USE)</code>, then given the field declaration:</p>
<pre><code>@C int @A [] @B [] f;</code></pre>
<p><code>@A</code> applies to the array type <code>int[][]</code>, <code>@B</code> applies to its component type <code>int[]</code>, and <code>@C</code> applies to the element type <code>int</code>. For more examples, see <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html#jls-10.2">10.2</a>.</p>
<p>An important property of this syntax is that, in two declarations that differ only in the number of array levels, the annotations to the left of the type refer to the same type. For example, <code>@C</code> applies to the type <code>int</code> in all of the following declarations:</p>
<pre><code>@C int f;
@C int[] f;
@C int[][] f;</code></pre>
</blockquote>
<blockquote>
<p>It is customary, though not required, to write declaration annotations before all other modifiers, and type annotations immediately before the type to which they apply.</p>
</blockquote>
<p>It is possible for an annotation to appear at a syntactic location in a program where it could plausibly apply to a declaration, or a type, or both. This can happen in any of the five declaration contexts where modifiers immediately precede the type of the declared entity:</p>
<ul>
<li><p>Method declarations (including elements of annotation <del>types</del> <strong>interfaces</strong>)</p></li>
<li><p>Constructor declarations</p></li>
<li><p>Field declarations (including enum constants)</p></li>
<li><p>Formal and exception parameter declarations</p></li>
<li><p>Local variable declarations (including loop variables of <code>for</code> statements and resource variables of <code>try</code>-with-resources statements)</p></li>
</ul>
<p>The grammar of the Java programming language unambiguously treats annotations at these locations as modifiers for a declaration (<a href="#jls-8.3">8.3</a>), but that is purely a syntactic matter. Whether an annotation applies to the declaration or to the type of the declared entity - and thus, whether the annotation is a <em>declaration annotation</em> or a <em>type annotation</em> - depends on the applicability of the annotation's <del>type</del> <strong>interface</strong>:</p>
<ul>
<li><p>If the annotation's <del>type</del> <strong>interface</strong> is applicable in the declaration context corresponding to the declaration, and not in type contexts, then the annotation is deemed to apply only to the declaration.</p></li>
<li><p>If the annotation's <del>type</del> <strong>interface</strong> is applicable in type contexts, and not in the declaration context corresponding to the declaration, then the annotation is deemed to apply only to the type which is closest to the annotation.</p></li>
<li><p>If the annotation's <del>type</del> <strong>interface</strong> is applicable in the declaration context corresponding to the declaration <em>and</em> in type contexts, then the annotation is deemed to apply to both the declaration <em>and</em> the type which is closest to the annotation.</p></li>
</ul>
<p>In the second and third cases above, the type which is <em>closest</em> to the annotation is determined as follows:</p>
<ul>
<li><p>If the annotation appears before a <code>void</code> method declaration or a local variable declaration that uses <code>var</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20.3">14.20.3</a>), then there is no closest type. If the annotation's <del>type</del> <strong>interface</strong> is deemed to apply only to the type which is closest to the annotation, a compile-time error occurs.</p></li>
<li><p>If the annotation appears before a constructor declaration, then the closest type is the type of the newly constructed object. The type of the newly constructed object is the fully qualified name of the type immediately enclosing the constructor declaration. Within that fully qualified name, the annotation applies to the simple type name indicated by the constructor declaration.</p></li>
<li><p>In all other cases, the closest type is the type written in source code for the declared entity; if that type is an array type, then the element type is deemed to be closest to the annotation.</p>
<blockquote>
<p>For example, in the field declaration <code>@Foo public static String f;</code>, the type which is closest to <code>@Foo</code> is <code>String</code>. (If the type of the field declaration had been written as <code>java.lang.String</code>, then <code>java.lang.String</code> would be the type closest to <code>@Foo</code>, and later rules would prohibit a type annotation from applying to the package name <code>java</code>.) In the generic method declaration <code>@Foo &lt;T&gt; int[] m() {...}</code>, the type written for the declared entity is <code>int[]</code>, so <code>@Foo</code> applies to the element type <code>int</code>.</p>
</blockquote>
<blockquote>
<p>Local variable declarations which do not use <code>var</code> are similar to formal parameter declarations of lambda expressions, in that both allow declaration annotations and type annotations in source code, but only the type annotations can be stored in the <code>class</code> file.</p>
</blockquote></li>
</ul>
<p>It is a compile-time error if an annotation of <del>type <em>T</em></del> <strong>interface <em>A</em></strong> is syntactically a modifier for:</p>
<ul>
<li><p>a module declaration, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to module declarations.</p></li>
<li><p>a package declaration, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to package declarations.</p></li>
<li><p>a class<del>,</del> <strong>or</strong> interface<del>, or enum</del> declaration, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to type declarations or type contexts; or <strong>in the case of</strong> an annotation <del>type</del> declaration, <del>but <em>T</em></del> <strong><em>A</em></strong> is not applicable to annotation type declarations or type declarations or type contexts.</p></li>
<li><p>a method declaration (including an element of an annotation <del>type</del> <strong>interface</strong>), but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to method declarations or type contexts.</p></li>
<li><p>a constructor declaration, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to constructor declarations or type contexts.</p></li>
<li><p>a type parameter declaration of a generic class, interface, method, or constructor, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to type parameter declarations or type contexts.</p></li>
<li><p>a field declaration <del>(including</del> <strong>or</strong> an enum constant<del>)</del>, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to field declarations or type contexts.</p></li>
<li><p>a formal or exception parameter declaration, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to either formal and exception parameter declarations or type contexts.</p></li>
<li><p>a receiver parameter, but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to type contexts.</p></li>
<li><p>a local variable declaration (including a loop variable of a <code>for</code> statement or a resource variable of a <code>try</code>-with-resources statement), but <del><em>T</em></del> <strong><em>A</em></strong> is not applicable to local variable declarations or type contexts.</p></li>
</ul>
<blockquote>
<p>Five of these nine clauses mention &quot;... or type contexts&quot; because they characterize the five syntactic locations where an annotation could plausibly apply either to a declaration or to the type of a declared entity. Furthermore, two of the nine clauses - for class<del>,</del> <strong>and</strong> interface<del>, enum, and annotation type</del> declarations, and for type parameter declarations - mention &quot;... or type contexts&quot; because it may be convenient to apply an annotation whose <del>type</del> <strong>interface</strong> is meta-annotated with <code>@Target(ElementType.TYPE_USE)</code> (thus, applicable in type contexts) to a <del>type</del> <strong>class, interface, or type parameter</strong> declaration.</p>
</blockquote>
<p>A type annotation is <em>admissible</em> if both of the following are true:</p>
<ul>
<li><p>The simple name to which the annotation is closest is classified as a <em>TypeName</em>, not a <em>PackageName</em>.</p></li>
<li><p>If the simple name to which the annotation is closest is followed by &quot;<code>.</code>&quot; and another <em>TypeName</em> - that is, the annotation appears as <code>@Foo T.U</code> - then <code>U</code> denotes an inner class of <code>T</code>.</p></li>
</ul>
<blockquote>
<p>The intuition behind the second clause is that if <code>Outer.this</code> is legal in a nested class enclosed by <code>Outer</code>, then <code>Outer</code> may be annotated because it represents the type of some object at run time. On the other hand, if <code>Outer.this</code> is not legal - because the class where it appears has no enclosing instance of <code>Outer</code> at run time - then <code>Outer</code> may not be annotated because it is logically just a name, akin to components of a package name in a fully qualified type name.</p>
</blockquote>
<blockquote>
<p>For example, in the following program, it is not possible to write <code>A.this</code> in the body of <code>B</code>, as <code>B</code> has no lexically enclosing instances (<a href="#jls-8.5.1">8.5.1</a>). Therefore, it is not possible to apply <code>@Foo</code> to <code>A</code> in the type <code>A.B</code>, because <code>A</code> is logically just a name, not a type.</p>
<pre><code>@Target(ElementType.TYPE_USE)
@interface Foo {}

class A {
    static class B {}
}

@Foo A.B x;  // Illegal </code></pre>
<p>On the other hand, in the following program, it is possible to write <code>C.this</code> in the body of <code>D</code>. Therefore, it is possible to apply <code>@Foo</code> to <code>C</code> in the type <code>C.D</code>, because <code>C</code> represents the type of some object at run time.</p>
<pre><code>@Target(ElementType.TYPE_USE)
@interface Foo {}

class Test {
    static class C {
        class D {}
    }

    @Foo C.D x;  // Legal 
}</code></pre>
</blockquote>
<p>It is a compile-time error if an annotation of <del>type <em>T</em></del> <strong>interface <em>A</em></strong> applies to the outermost level of a type in a type context, and <del><em>T</em></del> <strong><em>A</em></strong> is not applicable in type contexts or the declaration context (if any) which occupies the same syntactic location.</p>
<p>It is a compile-time error if an annotation of <del>type <em>T</em></del> <strong>interface <em>A</em></strong> applies to a part of a type (that is, not the outermost level) in a type context, and <del><em>T</em></del> <strong><em>A</em></strong> is not applicable in type contexts.</p>
<p>It is a compile-time error if an annotation of <del>type <em>T</em></del> <strong>interface <em>A</em></strong> applies to a type (or any part of a type) in a type context, and <del><em>T</em></del> <strong><em>A</em></strong> is applicable in type contexts, <del>and</del> <strong>but</strong> the annotation is not admissible.</p>
<blockquote>
<p>For example, assume an annotation <del>type</del> <strong>interface</strong> <code>TA</code> which is meta-annotated with just <code>@Target(ElementType.TYPE_USE)</code>. The terms <code>@TA java.lang.Object</code> and <code>java.@TA lang.Object</code> are illegal because the simple name to which <code>@TA</code> is closest is classified as a package name. On the other hand, <code>java.lang.@TA Object</code> is legal.</p>
</blockquote>
<blockquote>
<p>Note that the illegal terms are illegal &quot;everywhere&quot;. The ban on annotating package names applies broadly: to locations which are solely type contexts, such as <code>class ... extends @TA java.lang.Object {...}</code>, and to locations which are both declaration and type contexts, such as <code>@TA java.lang.Object f;</code>. (There are no locations which are solely declaration contexts where a package name could be annotated, as class, package, and type parameter declarations use only simple names.)</p>
</blockquote>
<blockquote>
<p>If <code>TA</code> is additionally meta-annotated with <code>@Target(ElementType.FIELD)</code>, then the term <code>@TA java.lang.Object</code> is legal in locations which are both declaration and type contexts, such as a field declaration <code>@TA java.lang.Object f;</code>. Here, <code>@TA</code> is deemed to apply to the declaration of <code>f</code> (and not to the type <code>java.lang.Object</code>) because <code>TA</code> is applicable in the field declaration context.</p>
</blockquote>
<h4 id="jls-9.7.5">9.7.5 Multiple Annotations of the Same <del>Type</del> <strong>Interface</strong></h4>
<p>It is a compile-time error if multiple annotations of the same <del>type <em>T</em></del> <strong>interface <em>A</em></strong> appear in a declaration context or type context, unless <del><em>T</em></del> <strong><em>A</em></strong> is repeatable (<a href="#jls-9.6.3">9.6.3</a>) and both <del><em>T</em></del> <strong><em>A</em></strong> and the containing annotation <del>type</del> <strong>interface</strong> of <del><em>T</em></del> <strong><em>A</em></strong> are applicable in the declaration context or type context (<a href="#jls-9.6.4.1">9.6.4.1</a>).</p>
<blockquote>
<p>It is customary, though not required, for multiple annotations of the same <del>type</del> <strong>interface</strong> to appear contiguously.</p>
</blockquote>
<p>If a declaration context or type context has multiple annotations of a repeatable annotation <del>type <em>T</em></del> <strong>interface <em>A</em></strong>, then it is as if the context has no explicitly declared annotations of <del>type <em>T</em></del> <strong>interface <em>A</em></strong> and one implicitly declared annotation of the containing annotation <del>type</del> <strong>interface</strong> of <del><em>T</em></del> <strong><em>A</em></strong>.</p>
<p>The implicitly declared annotation is called the <em>container annotation</em>, and the multiple annotations of <del>type <em>T</em></del> <strong>interface <em>A</em></strong> which appeared in the context are called the <em>base annotations</em>. The elements of the (array-typed) <code>value</code> element of the container annotation are all the base annotations in the left-to-right order in which they appeared in the context.</p>
<p>It is a compile-time error if, in a declaration context or type context, there are multiple annotations of a repeatable annotation <del>type <em>T</em></del> <strong>interface <em>A</em></strong> and any annotations of the containing annotation <del>type</del> <strong>interface</strong> of <del><em>T</em></del> <strong><em>A</em></strong>.</p>
<blockquote>
<p>In other words, it is not possible to repeat annotations where an annotation of the same <del>type</del> <strong>interface</strong> as their container also appears. This prohibits obtuse code like:</p>
</blockquote>
<blockquote>
<pre><code>@Foo(0) @Foo(1) @FooContainer({@Foo(2)})
class A {}</code></pre>
</blockquote>
<blockquote>
<p>If this code was legal, then multiple levels of containment would be needed: first the annotations of <del>type</del> <strong>interface</strong> <code>Foo</code> would be contained by an implicitly declared container annotation of <del>type</del> <strong>interface</strong> <code>FooContainer</code>, then that annotation and the explicitly declared annotation of <del>type</del> <strong>interface</strong> <code>FooContainer</code> would be contained in yet another implicitly declared annotation. This complexity is undesirable in the judgment of the designers of the Java programming language. Another approach, treating the annotations of <del>type</del> <strong>interface</strong> <code>Foo</code> as if they had occurred alongside <code>@Foo(2)</code> in the explicit <code>@FooContainer</code> annotation, is undesirable because it could change how reflective programs interpret the <code>@FooContainer</code> annotation.</p>
</blockquote>
<p>It is a compile-time error if, in a declaration context or type context, there is one annotation of a repeatable annotation <del>type <em>T</em></del> <strong>interface <em>A</em></strong> and multiple annotations of the containing annotation <del>type</del> <strong>interface</strong> of <del><em>T</em></del> <strong><em>A</em></strong>.</p>
<blockquote>
<p>This rule is designed to allow the following code:</p>
</blockquote>
<blockquote>
<pre><code>@Foo(1) @FooContainer({@Foo(2)})
class A {}</code></pre>
</blockquote>
<blockquote>
<p>With only one annotation of the repeatable annotation <del>type</del> <strong>interface</strong> <code>Foo</code>, no container annotation is implicitly declared, even if <code>FooContainer</code> is the containing annotation <del>type</del> <strong>interface</strong> of <code>Foo</code>. However, repeating the annotation of <del>type</del> <strong>interface</strong> <code>FooContainer</code>, as in:</p>
</blockquote>
<blockquote>
<pre><code>@Foo(1) @FooContainer({@Foo(2)}) @FooContainer({@Foo(3)})
class A {}</code></pre>
</blockquote>
<blockquote>
<p>is prohibited, even if <code>FooContainer</code> is repeatable with a containing annotation <del>type</del> <strong>interface</strong> of its own. It is obtuse to repeat annotations which are themselves containers when an annotation of the underlying repeatable <del>type</del> <strong>interface</strong> is present.</p>
</blockquote>
<h2 id="jls-12">Chapter 12: Execution</h2>
<h3 id="jls-12.2">12.2 Loading of Classes and Interfaces</h3>
<p><em>Loading</em> refers to the process of finding the binary form of a class or interface <del>type</del> with a particular name, perhaps by computing it on the fly, but more typically by retrieving a binary representation previously computed from source code by a Java compiler, and constructing, from that binary form, a <code>Class</code> object to represent the class or interface.</p>
<p>The precise semantics of loading are given in Chapter 5 of <em>The Java Virtual Machine Specification, Java SE 15 Edition</em>. Here we present an overview of the process from the viewpoint of the Java programming language.</p>
<p>The binary format of a class or interface is normally the <code>class</code> file format described in <em>The Java Virtual Machine Specification, Java SE 15 Edition</em> cited above, but other formats are possible, provided they meet the requirements specified in <a href="#jls-13.1">13.1</a>. The method <code>defineClass</code> of class <code>ClassLoader</code> may be used to construct <code>Class</code> objects from binary representations in the <code>class</code> file format.</p>
<p>Well-behaved class loaders maintain these properties:</p>
<ul>
<li><p>Given the same name, a good class loader should always return the same class object.</p></li>
<li><p>If a class loader <em>L1</em> delegates loading of a class <em>C</em> to another loader <em>L2</em>, then for any <del>type <em>T</em></del> <strong>class or interface <em>D</em></strong> that <del>occurs as</del> <strong>is named by</strong> the direct superclass <strong>type</strong> or a direct superinterface <strong>type</strong> of <em>C</em>, or <del>as</del> <strong>by</strong> the type of a field in <em>C</em>, or <del>as</del> <strong>by</strong> the type of a formal parameter of a method or constructor in <em>C</em>, or <del>as</del> <strong>by</strong> a return type of a method in <em>C</em>, <em>L1</em> and <em>L2</em> should return the same <code>Class</code> object.</p></li>
</ul>
<p>A malicious class loader could violate these properties. However, it could not undermine the security of the type system, because the Java Virtual Machine guards against this.</p>
<blockquote>
<p>For further discussion of these issues, see <em>The Java Virtual Machine Specification, Java SE 15 Edition</em> and the paper <em>Dynamic Class Loading in the Java Virtual Machine</em>, by Sheng Liang and Gilad Bracha, in <em>Proceedings of OOPSLA '98</em>, published as <em>ACM SIGPLAN Notices</em>, Volume 33, Number 10, October 1998, pages 36-44. A basic principle of the design of the Java programming language is that the run-time type system cannot be subverted by code written in the Java programming language, not even by implementations of such otherwise sensitive system classes as <code>ClassLoader</code> and <code>SecurityManager</code>.</p>
</blockquote>
<h3 id="jls-12.3">12.3 Linking of Classes and Interfaces</h3>
<p><em>Linking</em> is the process of taking a binary form of a class or interface <del>type</del> and combining it into the run-time state of the Java Virtual Machine, so that it can be executed. A class or interface <del>type</del> is always loaded before it is linked.</p>
<p>Three different activities are involved in linking: verification, preparation, and resolution of symbolic references.</p>
<p>The precise semantics of linking are given in Chapter 5 of <em>The Java Virtual Machine Specification, Java SE 15 Edition</em>. Here we present an overview of the process from the viewpoint of the Java programming language.</p>
<p>This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the Java programming language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error.</p>
<p>For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.</p>
<p>Because linking involves the allocation of new data structures, it may fail with an <code>OutOfMemoryError</code>.</p>
<h4 id="jls-12.3.3">12.3.3 Resolution of Symbolic References</h4>
<p>The binary representation of a class or interface references other classes and interfaces and their fields, methods, and constructors symbolically, using the binary names (<a href="#jls-13.1">13.1</a>) of the other classes and interfaces (<a href="#jls-13.1">13.1</a>). For fields and methods, these symbolic references include the name of the class or interface <del>type</del> of which the field or method is a member, as well as the name of the field or method itself, together with appropriate type information.</p>
<p>Before a symbolic reference can be used it must undergo resolution, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly.</p>
<p>If an error occurs during resolution, then an error will be thrown. Most typically, this will be an instance of one of the following subclasses of the class <code>IncompatibleClassChangeError</code>, but it may also be an instance of some other subclass of <code>IncompatibleClassChangeError</code> or even an instance of the class <code>IncompatibleClassChangeError</code> itself. This error may be thrown at any point in the program that uses a symbolic reference <del>to the type</del>, directly or indirectly:</p>
<div class="editorial">
<p>Could change this to &quot;class or interface&quot;, but symbolic references aren't just references to classes and interfaces.</p>
</div>
<p>...</p>
<h3 id="jls-12.5">12.5 Creation of New Class Instances</h3>
<p>...</p>
<p>Whenever a new class instance is created, memory space is allocated for it with room for all the instance variables declared in the class <del>type</del> and all the instance variables declared in each superclass of the class <del>type</del>, including all the instance variables that may be hidden (<a href="#jls-8.3">8.3</a>).</p>
<p>...</p>
<h2 id="jls-13">Chapter 13: Binary Compatibility</h2>
<h3 id="jls-13.1">13.1 The Form of a Binary</h3>
<p>Programs must be compiled either into the <code>class</code> file format specified by <em>The Java Virtual Machine Specification, Java SE 14 Edition</em>, or into a representation that can be mapped into that format by a class loader written in the Java programming language.</p>
<p>A <code>class</code> file corresponding to a class or interface declaration must have certain properties. A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility. The required properties are:</p>
<ol type="1">
<li><p>The class or interface must be named by its <em>binary name</em>, which must meet the following constraints:</p>
<ul>
<li><p>The binary name of a top level <del>type</del> <strong>class or interface</strong> (<a href="#jls-7.6">7.6</a>) is its canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>The binary name of a member <del>type</del> <strong>class or interface</strong> (<a href="#jls-8.5">8.5</a>, <a href="#jls-9.5">9.5</a>) consists of the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by the simple name of the member.</p></li>
<li><p>The binary name of a local class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.3">14.3</a>) consists of the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by a non-empty sequence of digits, followed by the simple name of the local class.</p></li>
<li><p>The binary name of an anonymous class (<a href="#jls-15.9.5">15.9.5</a>) consists of the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by a non-empty sequence of digits.</p></li>
<li><p>The binary name of a type variable declared by a generic class or interface (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.1.2">9.1.2</a>) is the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.4">8.4.4</a>) is the binary name of the <del>type</del> <strong>class or interface</strong> declaring the method, followed by <code>$</code>, followed by the descriptor of the method (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.4">8.8.4</a>) is the binary name of the <del>type</del> <strong>class</strong> declaring the constructor, followed by <code>$</code>, followed by the descriptor of the constructor (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
</ul>
<div class="editorial">
<p>It's unclear why a type variable should have a binary name at all...</p>
</div></li>
<li><p>A reference to another class or interface <del>type</del> must be symbolic, using the binary name of the <del>type</del> <strong>class or interface</strong>.</p></li>
<li><p>A reference to a field that is a constant variable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.4">4.12.4</a>) must be resolved at compile time to the value <em>V</em> denoted by the constant variable's initializer.</p>
<p>If such a field is <code>static</code>, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-12.html#jls-12.4.2">12.4.2</a>); the default initial value for the field (if different than <em>V</em>) must never be observed.</p>
<p>If such a field is non-<code>static</code>, then no reference to the field should be present in the code in a binary file, except in the class containing the field. (It will be a class rather than an interface, since an interface has only <code>static</code> fields.) The class should have code to set the field's value to <em>V</em> during instance creation (<a href="#jls-12.5">12.5</a>).</p></li>
<li><p>Given a legal expression denoting a field access in a class <em>C</em>, referencing a field named <em>f</em> that is not a constant variable and is declared in a (possibly distinct) class or interface <em>D</em>, we define the <em>qualifying <del>type</del> <strong>class or interface</strong> of the field reference</em> as follows:</p>
<ul>
<li><p>If the expression is referenced by a simple name, then if <em>f</em> is a member of the current class or interface, <em>C</em>, then let <del><em>T</em></del> <strong><em>Q</em></strong> be <em>C</em>. Otherwise, let <del><em>T</em></del> <strong><em>Q</em></strong> be the innermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of which <em>f</em> is a member. In either case, <del><em>T</em></del> <strong><em>Q</em></strong> is the qualifying <del>type</del> <strong>class or interface</strong> of the reference.</p></li>
<li><p>If the reference is of the form <em>TypeName</em><code>.</code><em>f</em>, where <em>TypeName</em> denotes a class or interface, then the class or interface denoted by <em>TypeName</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the reference.</p></li>
<li><p>If the expression is of the form <em>ExpressionName</em><code>.</code><em>f</em> or <em>Primary</em><code>.</code><em>f</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is an intersection type <em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em> (<a href="#jls-4.9">4.9</a>), then the qualifying <del>type</del> <strong>class or interface</strong> of the reference is <strong>the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of</strong> <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the <strong>erasure of the</strong> compile-time type of <em>ExpressionName</em> or <em>Primary</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the reference.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>f</em>, then the superclass of <em>C</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the reference.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.super.</code><em>f</em>, then the superclass of the class denoted by <em>TypeName</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the reference.</p></li>
</ul>
<p>The reference to <em>f</em> must be compiled into a symbolic reference to the <del>erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of the</del> qualifying <del>type</del> <strong>class or interface</strong> of the reference, plus the simple name of the field, <em>f</em>. The reference must also include a symbolic reference to the erasure of the declared type of the field so that the verifier can check that the type is as expected.</p></li>
<li><p>Given a method invocation expression or a method reference expression in a class or interface <em>C</em>, referencing a method named <em>m</em> declared (or implicitly declared (<a href="#jls-9.2">9.2</a>)) in a (possibly distinct) class or interface <em>D</em>, we define the <em>qualifying <del>type</del> <strong>class or interface</strong> of the method invocation</em> as follows:</p>
<ul>
<li><p>If <em>D</em> is <code>Object</code> then the qualifying <del>type</del> <strong>class or interface</strong> of the expression is <code>Object</code>.</p></li>
<li><p>Otherwise:</p>
<ul>
<li><p>If the method is referenced by a simple name, then if <em>m</em> is a member of the current class or interface <em>C</em>, let <del><em>T</em></del> <strong><em>Q</em></strong> be <em>C</em>; otherwise, let <del><em>T</em></del> <strong><em>Q</em></strong> be the innermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of which <em>m</em> is a member. In either case, <del><em>T</em></del> <strong><em>Q</em></strong> is the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.</code><em>m</em> or <em>ReferenceType</em><code>::</code><em>m</em>, then the <del>type</del> <strong>class or interface</strong> denoted by <em>TypeName</em><strong>,</strong> or <strong>the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of</strong> <em>ReferenceType</em><strong>,</strong> is the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation.</p></li>
<li><p>If the expression is of the form <em>ExpressionName</em><code>.</code><em>m</em> or <em>Primary</em><code>.</code><em>m</em> or <em>ExpressionName</em><code>::</code><em>m</em> or <em>Primary</em><code>::</code><em>m</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is an intersection type <em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em> (<a href="#jls-4.9">4.9</a>), then the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation is <strong>the erasure of</strong> <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the <strong>erasure of the</strong> compile-time type of <em>ExpressionName</em> or <em>Primary</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>m</em> or <code>super::</code><em>m</em>, then the superclass of <em>C</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.super.</code><em>m</em> or <em>TypeName</em><code>.super::</code><em>m</em>, then if <em>TypeName</em> denotes a class <em>X</em>, the superclass of <em>X</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation; if <em>TypeName</em> denotes an interface <em>X</em>, <em>X</em> is the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation.</p></li>
</ul></li>
</ul>
<p>A reference to a method must be resolved at compile time to a symbolic reference to the <del>erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of the</del> qualifying <del>type</del> <strong>class or interface</strong> of the invocation, plus the erasure of the <strong>declared</strong> signature (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the method. The signature of a method must include all of the following as determined by <a href="#jls-15.12.3">15.12.3</a>:</p>
<ul>
<li><p>The simple name of the method</p></li>
<li><p>The number of parameters to the method</p></li>
<li><p>A symbolic reference to the type of each parameter</p></li>
</ul>
<p>A reference to a method must also include either a symbolic reference to the erasure of the return type of the denoted method or an indication that the denoted method is declared <code>void</code> and does not return a value.</p></li>
<li><p>Given a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>) or an explicit constructor invocation statement (<a href="#jls-8.8.7.1">8.8.7.1</a>) or a method reference expression of the form <em>ClassType <code>::</code> <code>new</code></em> (<a href="#jls-15.13">15.13</a>) in a class or interface <em>C</em> referencing a constructor <em>m</em> declared in a (possibly distinct) class or interface <em>D</em>, we define the qualifying <del>type</del> <strong>class</strong> of the constructor invocation as follows:</p>
<ul>
<li><p>If the expression is of the form <code>new</code> <em>D</em><code>(...)</code> or <em>ExpressionName</em><code>.new</code> <em>D</em><code>(...)</code> or <em>Primary</em><code>.new</code> <em>D</em><code>(...)</code> or <em>D</em> <code>::</code> <code>new</code>, then the qualifying <del>type</del> <strong>class</strong> of the invocation is <em>D</em>.</p></li>
<li><p>If the expression is of the form <code>new</code> <em>D</em><code>(...){...}</code> or <em>ExpressionName</em><code>.new</code> <em>D</em><code>(...){...}</code> or <em>Primary</em><code>.new</code> <em>D</em><code>(...){...}</code>, then the qualifying <del>type</del> <strong>class</strong> of the expression is the <del>compile-time type of</del> <strong>anonymous class declared by</strong> the expression.</p></li>
<li><p>If the expression is of the form <code>super(...)</code> or <em>ExpressionName</em><code>.super(...)</code> or <em>Primary</em><code>.super(...)</code>, then the qualifying <del>type</del> <strong>class</strong> of the expression is the direct superclass of <em>C</em>.</p></li>
<li>If the expression is of the form <code>this(...)</code>, then the qualifying</li>
<li><p><del>type</del> <strong>class</strong> of the expression is <em>C</em>.</p></li>
</ul>
<p>A reference to a constructor must be resolved at compile time to a symbolic reference to the <del>erasure (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.6">4.6</a>) of the</del> qualifying <del>type</del> <strong>class</strong> of the invocation, plus the <strong>declared</strong> signature of the constructor (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.2">8.8.2</a>). The signature of a constructor must include both:</p>
<ul>
<li><p>The number of parameters of the constructor</p></li>
<li><p>A symbolic reference to the type of each formal parameter</p></li>
</ul></li>
</ol>
<p>A binary representation for a class or interface must also contain all of the following:</p>
<ol type="1">
<li><p>If it is a class and is not <code>Object</code>, then a symbolic reference to the <del>erasure of the</del> direct superclass of this class.</p></li>
<li><p>A symbolic reference to <del>the erasure of</del> each direct superinterface, if any.</p></li>
<li><p>A specification of each field declared in the class or interface, given as the simple name of the field and a symbolic reference to the erasure of the type of the field.</p></li>
<li><p>If it is a class, then the erased signature of each constructor, as described above.</p></li>
<li><p>For each method declared in the class or interface (excluding, for an interface, its implicitly declared methods (<a href="#jls-9.2">9.2</a>)), its erased signature and return type, as described above.</p></li>
<li><p>The code needed to implement the class or interface:</p>
<ul>
<li><p>For an interface, code for the field initializers and the implementation of each method with a block body (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4.3">9.4.3</a>).</p></li>
<li><p>For a class, code for the field initializers, the instance and static initializers, the implementation of each method with a block body (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.7">8.4.7</a>), and the implementation of each constructor.</p></li>
</ul></li>
<li><p>Every <del>type</del> <strong>class or interface</strong> must contain sufficient information to recover its canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>Every member <del>type</del> <strong>class or interface</strong> must have sufficient information to recover its source-level access modifier.</p></li>
<li><p>Every nested class <del>and nested</del> <strong>or</strong> interface must have a symbolic reference to its immediately enclosing <del>type</del> <strong>class or interface</strong> (<a href="#jls-8.1.3">8.1.3</a>).</p></li>
<li><p>Every class <strong>or interface</strong> must contain symbolic references to all of its member <del>types</del> <strong>classes and interfaces</strong> (<a href="#jls-8.5">8.5</a><strong>, <a href="#jls-9.5">9.5</a></strong>), and to all <del>local and anonymous classes that appear in its methods, constructors, static initializers, instance initializers, and field initializers</del> <strong>other nested classes and interfaces declared within its body</strong>.</p>
<p><del>Every interface must contain symbolic references to all of its member types (<a href="#jls-9.5">9.5</a>), and to all local and anonymous classes that appear in its default methods and field initializers.</del></p></li>
<li><p>A construct emitted by a Java compiler must be marked as <em>synthetic</em> if it does not correspond to a construct declared explicitly or implicitly in source code, unless the emitted construct is a class initialization method (JVMS §2.9).</p></li>
<li><p>A construct emitted by a Java compiler must be marked as <em>mandated</em> if it corresponds to a formal parameter declared implicitly in source code (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.9">8.8.9</a>, <a href="#jls-8.9.3">8.9.3</a>, <a href="#jls-15.9.5.1">15.9.5.1</a>).</p></li>
</ol>
<blockquote>
<p>The following formal parameters are declared implicitly in source code:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The first formal parameter of a constructor of a non-<code>private</code> inner member class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.9">8.8.9</a>).</p></li>
<li><p>The first formal parameter of an anonymous constructor of an anonymous class whose superclass is <del>inner or local</del> <strong>an inner class</strong> (not in a static context) (<a href="#jls-15.9.5.1">15.9.5.1</a>).</p></li>
<li><p>The formal parameter <code>name</code> of the <code>valueOf</code> method which is implicitly declared in an enum <del>type</del> <strong>class</strong> (<a href="#jls-8.9.3">8.9.3</a>).</p></li>
</ul>
</blockquote>
<blockquote>
<p>For reference, the following constructs are declared implicitly in source code, but are not marked as mandated because only formal parameters can be so marked in a <code>class</code> file (JVMS §4.7.24):</p>
</blockquote>
<blockquote>
<ul>
<li><p>Default constructors of classes <del>and enum types</del> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.9">8.8.9</a>, <a href="#jls-8.9.2">8.9.2</a>)</p></li>
<li><p>Anonymous constructors (<a href="#jls-15.9.5.1">15.9.5.1</a>)</p></li>
<li><p>The <code>values</code> and <code>valueOf</code> methods of enum <del>types</del> <strong>classes</strong> (<a href="#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>public</code> fields of enum <del>types</del> <strong>classes</strong> (<a href="#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>public</code> methods of interfaces (<a href="#jls-9.2">9.2</a>)</p></li>
<li><p>Container annotations (<a href="#jls-9.7.5">9.7.5</a>)</p></li>
</ul>
</blockquote>
<p>A <code>class</code> file corresponding to a module declaration must have the properties of a <code>class</code> file for a class whose binary name is <code>module-info</code> and which has no superclass, no superinterfaces, no fields, and no methods. In addition, the binary representation of the module must contain all of the following:</p>
<ul>
<li><p>A specification of the name of the module, given as a symbolic reference to the name indicated after <code>module</code>. Also, the specification must include whether the module is normal or open (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7">7.7</a>).</p></li>
<li><p>A specification of each dependence denoted by a <code>requires</code> directive, given as a symbolic reference to the name of the module indicated by the directive (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.1">7.7.1</a>). Also, the specification must include whether the dependence is <code>transitive</code> and whether the dependence is <code>static</code>.</p></li>
<li><p>A specification of each package denoted by an <code>exports</code> or <code>opens</code> directive, given as a symbolic reference to the name of the package indicated by the directive (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-7.html#jls-7.7.2">7.7.2</a>). Also, if the directive was qualified, the specification must give symbolic references to the names of the modules indicated by the directive's <code>to</code> clause.</p></li>
<li><p>A specification of each service denoted by a <code>uses</code> directive, given as a symbolic reference to the name of the <del>type</del> <strong>class or interface</strong> indicated by the directive (<a href="#jls-7.7.3">7.7.3</a>).</p></li>
<li><p>A specification of the service providers denoted by a <code>provides</code> directive, given as symbolic references to the names of the <del>types</del> <strong>classes and interfaces</strong> indicated by the directive's <code>with</code> clause (<a href="#jls-7.7.4">7.7.4</a>). Also, the specification must give a symbolic reference to the name of the <del>type</del> <strong>class or interface</strong> indicated as the service by the directive.</p></li>
</ul>
<p>The following sections discuss changes that may be made to class and interface <del>type</del> declarations without breaking compatibility with pre-existing binaries. Under the translation requirements given above, the Java Virtual Machine and its <code>class</code> file format support these changes. Any other valid binary format, such as a compressed or encrypted representation that is mapped back into <code>class</code> files by a class loader under the above requirements, will necessarily support these changes as well.</p>
<h3 id="jls-13.3">13.3 Evolution of Packages and Modules</h3>
<p>A new top level class or interface <del>type</del> may be added to a package without breaking compatibility with pre-existing binaries, provided the new <del>type</del> <strong>class or interface</strong> does not reuse a name previously given to an unrelated <del>type</del> <strong>class or interface</strong>. If a new <del>type</del> <strong>class or interface</strong> reuses a name previously given to an unrelated <del>type</del> <strong>class or interface</strong>, then a conflict may result, since binaries for both <del>types</del> <strong>classes or interfaces</strong> could not be loaded by the same class loader.</p>
<p>Changes in top level <del>class and interface types</del> <strong>classes and interfaces</strong> that are not <code>public</code> and that are not a superclass or superinterface, respectively, of a <code>public</code> <del>type</del> <strong>class or interface</strong>, affect only <del>types</del> <strong>classes and interfaces</strong> within the package in which they are declared. Such <del>types</del> <strong>classes and interfaces</strong> may be deleted or otherwise changed, even if incompatibilities are otherwise described here, provided that the affected binaries of that package are updated together.</p>
<p>If a module that was declared to export or open a package is changed to not export or open the package, or to export or open the package to a different set of friends, then an <code>IllegalAccessError</code> is thrown if a pre-existing binary is linked that needs but no longer has access to the <code>public</code> and <code>protected</code> <del>types</del> <strong>classes and interfaces</strong> of the package. Such a change is not recommended for modules that have been widely distributed.</p>
<p>If a module was not declared to export or open a given package, then changing the module to export or open the package does not break compatibility with pre-existing binaries. However, changing the module to export the package may prevent the program from starting, since any module that reads the module may also read some other module that exports a package with the same name.</p>
<p>Adding a <code>requires</code> directive to a module declaration, or adding the <code>transitive</code> modifier to a <code>requires</code> directive, does not break compatibility with pre-existing binaries. However, it may prevent the program from starting, since the module may now read multiple modules that export packages with the same name.</p>
<p>Deleting a <code>requires</code> directive in a module declaration, or deleting the <code>transitive</code> modifier from a <code>requires</code> directive, may break compatibility with any pre-existing binary that relied on the directive or modifier for readability of a given module in the course of referencing <del>types</del> <strong>classes and interfaces</strong> exported by that module. An <code>IllegalAccessError</code> may be thrown when such a reference from a pre-existing binary is linked.</p>
<p>Adding or deleting a <code>uses</code> or <code>provides</code> directive in a module declaration does not break compatibility with pre-existing binaries.</p>
<h3 id="jls-13.4">13.4 Evolution of Classes</h3>
<h4 id="jls-13.4.4">13.4.4 Superclasses and Superinterfaces</h4>
<p>A <code>ClassCircularityError</code> is thrown at load time if a class would be a superclass of itself. Changes to the class hierarchy that could result in such a circularity when newly compiled binaries are loaded with pre-existing binaries are not recommended for widely distributed classes.</p>
<p>Changing the direct superclass <strong>type</strong> or the set of direct <del>superinterfaces</del> <strong>superinterface types</strong> of a class <del>type</del> will not break compatibility with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class <del>type</del> loses no members.</p>
<blockquote>
<p><strong>As one notable example, it is a binary compatible change to replace a raw supertype of a class with a parameterization of the class or interface named by the raw type.</strong></p>
</blockquote>
<p>If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, then linkage errors may result if pre-existing binaries are loaded with the binary of the modified class. Such changes are not recommended for widely distributed classes.</p>
<div class="example">
<p>Example 13.4.4-1. Changing A Superclass</p>
<p>Suppose that the following test program:</p>
<pre><code>class Hyper { char h = &#39;h&#39;; } 
class Super extends Hyper { char s = &#39;s&#39;; }
class Test extends Super {
    public static void printH(Hyper h) {
        System.out.println(h.h);
    }
    public static void main(String[] args) {
        printH(new Super());
    }
}</code></pre>
<p>is compiled and executed, producing the output:</p>
<pre><code>h</code></pre>
<p>Suppose that a new version of class <code>Super</code> is then compiled:</p>
<pre><code>class Super { char s = &#39;s&#39;; }</code></pre>
<p>This version of class <code>Super</code> is not a subclass of <code>Hyper</code>. If we then run the existing binaries of <code>Hyper</code> and <code>Test</code> with the new version of <code>Super</code>, then a <code>VerifyError</code> is thrown at link time. The verifier objects because the result of <code>new Super()</code> cannot be passed as an argument in place of a formal parameter of type <code>Hyper</code>, because <code>Super</code> is not a subclass of <code>Hyper</code>.</p>
<p>It is instructive to consider what might happen without the verification step: the program might run and print:</p>
<pre><code>s</code></pre>
<p>This demonstrates that without the verifier, the Java type system could be defeated by linking inconsistent binary files, even though each was produced by a correct Java compiler.</p>
<p>The lesson is that an implementation that lacks a verifier or fails to use it will not maintain type safety and is, therefore, not a valid implementation.</p>
</div>
<blockquote>
<p>The requirement that alternatives in a multi-<code>catch</code> clause (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20">14.20</a>) not be subclasses or superclasses of each other is only a source restriction. Assuming the following client code is legal:</p>
<pre><code>try {
    throwAorB();
} catch(ExceptionA | ExceptionB e) {
    ...
}</code></pre>
<p>where <code>ExceptionA</code> and <code>ExceptionB</code> do not have a subclass/superclass relationship when the client is compiled, it is binary compatible with respect to the client for <code>ExceptionA</code> and <code>ExceptionB</code> to have such a relationship when the client is executed.</p>
<p>This is analogous to other situations where a class transformation that is binary compatible for a client might not be source compatible for the same client.</p>
</blockquote>
<h4 id="jls-13.4.8">13.4.8 Field Declarations</h4>
<p>Widely distributed programs should not expose any fields to their clients. Apart from the binary compatibility issues discussed below, this is generally good software engineering practice. Adding a field to a class may break compatibility with pre-existing binaries that are not recompiled.</p>
<p>Assume a reference to a field <em>f</em> with qualifying <del>type <em>T</em></del> <strong>class <em>C</em></strong>. Assume further that <em>f</em> is in fact an instance (respectively <code>static</code>) field declared in a superclass of <del><em>T</em></del> <strong><em>C</em></strong>, <em>S</em>, and that the type of <em>f</em> is <em>X</em>.</p>
<p>If a new field of type <em>X</em> with the same name as <em>f</em> is added to a subclass of <em>S</em> that is a superclass of <del><em>T</em></del> <strong><em>C</em></strong> or <del><em>T</em></del> <strong><em>C</em></strong> itself, then a linkage error may occur. Such a linkage error will occur only if, in addition to the above, either one of the following is true:</p>
<ul>
<li><p>The new field is less accessible than the old one.</p></li>
<li><p>The new field is a <code>static</code> (respectively instance) field.</p></li>
</ul>
<p>In particular, no linkage error will occur in the case where a class could no longer be recompiled because a field access previously referenced a field of a superclass with an incompatible type. The previously compiled class with such a reference will continue to reference the field declared in a superclass.</p>
<p>...</p>
<h4 id="jls-13.4.12">13.4.12 Method and Constructor Declarations</h4>
<p>Adding a method or constructor declaration to a class will not break compatibility with any pre-existing binaries, even in the case where a <del>type</del> <strong>class</strong> could no longer be recompiled because an invocation previously referenced a method or constructor of a superclass with an incompatible type. The previously compiled class with such a reference will continue to reference the method or constructor declared in a superclass.</p>
<p>Assume a reference to a method <em>m</em> with qualifying <del>type <em>T</em></del> <strong>class <em>C</em></strong>. Assume further that <em>m</em> is in fact an instance (respectively <code>static</code>) method declared in a superclass of <del><em>T</em></del> <strong><em>C</em></strong>, <em>S</em>.</p>
<p>If a new method of type <em>X</em> with the same signature and return type as <em>m</em> is added to a subclass of <em>S</em> that is a superclass of <del><em>T</em></del> <strong><em>C</em></strong> or <del><em>T</em></del> <strong><em>C</em></strong> itself, then a linkage error may occur. Such a linkage error will occur only if, in addition to the above, either one of the following is true:</p>
<ul>
<li><p>The new method is less accessible than the old one.</p></li>
<li><p>The new method is a <code>static</code> (respectively instance) method.</p></li>
</ul>
<p>...</p>
<h4 id="jls-13.4.26">13.4.26 Evolution of <del>Enums</del> <strong>Enum Classes</strong></h4>
<p>Adding or reordering constants in an enum <strong>declaration</strong> will not break compatibility with pre-existing binaries.</p>
<p><del>If a pre-existing binary attempts to access an enum constant that no longer exists, the client will fail at run time with a <code>NoSuchFieldError</code>. Therefore such a change is not recommended for widely distributed enums.</del></p>
<p><strong>Removing an enum constant will remove the corresponding implicit field declaration, with consequences described in <a href="#jls-13.4.8">13.4.8</a>.</strong></p>
<p>In all other respects, the binary compatibility rules for <del>enums</del> <strong>enum classes</strong> are identical to those for <del>classes</del> <strong>normal classes</strong>.</p>
<h3 id="jls-13.5">13.5 Evolution of Interfaces</h3>
<h4 id="jls-13.5.7">13.5.7 Evolution of Annotation <del>Types</del> <strong>Interfaces</strong></h4>
<p>Annotation <del>types</del> <strong>interfaces</strong> behave exactly like any other interface. Adding or removing an element from an annotation <del>type</del> <strong>interface</strong> is analogous to adding or removing a method. There are important considerations governing other changes to annotation <del>types</del> <strong>interfaces</strong>, such as making an annotation <del>type</del> <strong>interface</strong> repeatable (<a href="#jls-9.6.3">9.6.3</a>), but these have no effect on the linkage of binaries by the Java Virtual Machine. Rather, such changes affect the behavior of reflective APIs that manipulate annotations. The documentation of these APIs specifies their behavior when various changes are made to the underlying annotation <del>types</del> <strong>interfaces</strong>.</p>
<p>Adding or removing annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language.</p>
<h2 id="jls-15">Chapter 15: Expressions</h2>
<h3 id="jls-15.8">15.8 Primary Expressions</h3>
<h4 id="jls-15.8.2">15.8.2 Class Literals</h4>
<p>A <em>class literal</em> is an expression consisting of the name of a class, interface, array <strong>type</strong>, or primitive type, or the pseudo-type <code>void</code>, followed by a '<code>.</code>' and the token <code>class</code>.</p>
<dl>
<dt><em>ClassLiteral:</em></dt>
<dd><em>TypeName</em> {<code>[</code> <code>]</code>} <code>.</code> <code>class</code>
</dd>
<dd><em>NumericType</em> {<code>[</code> <code>]</code>} <code>.</code> <code>class</code>
</dd>
<dd><code>boolean</code> {<code>[</code> <code>]</code>} <code>.</code> <code>class</code>
</dd>
<dd><code>void</code> <code>.</code> <code>class</code>
</dd>
</dl>
<p>The <em>TypeName</em> must denote a class or interface <del>type</del> that is accessible (<a href="#jls-6.6">6.6</a>). It is a compile-time error if the <em>TypeName</em> denotes a class or interface <del>type</del> that is not accessible, or denotes a type variable.</p>
<p>The type of <em>C</em><code>.class</code>, where <em>C</em> is the name of a class, interface, or array type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3">4.3</a>), is <code>Class&lt;</code><em>C</em><code>&gt;</code>.</p>
<p>The type of <em>p</em><code>.class</code>, where <em>p</em> is the name of a primitive type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.2">4.2</a>), is <code>Class&lt;</code><em>B</em><code>&gt;</code>, where <em>B</em> is the type of an expression of type <em>p</em> after boxing conversion ([5.1.7]).</p>
<p>The type of <code>void.class</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.5">8.4.5</a>) is <code>Class&lt;Void&gt;</code>.</p>
<p>A class literal evaluates to the <code>Class</code> object for the named <del>type</del> <strong>class, interface, array type, or primitive type</strong> (or <del>for</del> <code>void</code>)<strong>,</strong> as defined by the defining class loader (<a href="#jls-12.2">12.2</a>) of the class of the current instance.</p>
<h4 id="jls-15.8.3">15.8.3 <code>this</code></h4>
<p>The keyword <code>this</code> may be used only in the following contexts:</p>
<ul>
<li><p>in the body of an instance method or default method (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.7">8.4.7</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.4.3">9.4.3</a>)</p></li>
<li><p>in the body of a constructor of a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.7">8.8.7</a>)</p></li>
<li><p>in an instance initializer of a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.6">8.6</a>)</p></li>
<li><p>in the initializer of an instance variable of a class (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.3.2">8.3.2</a>)</p></li>
<li><p>to denote a receiver parameter (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
</ul>
<p>If it appears anywhere else, a compile-time error occurs.</p>
<p>The keyword <code>this</code> may be used in a lambda expression only if it is allowed in the context in which the lambda expression appears. Otherwise, a compile-time error occurs.</p>
<p>When used as a primary expression, the keyword <code>this</code> denotes a value that is a reference to the object for which the instance method or default method was invoked (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12">15.12</a>), or to the object being constructed. The value denoted by <code>this</code> in a lambda body is the same as the value denoted by <code>this</code> in the surrounding context.</p>
<blockquote>
<p>The keyword <code>this</code> is also used in explicit constructor invocation statements (<a href="#jls-8.8.7.1">8.8.7.1</a>).</p>
</blockquote>
<p><del>The type of <code>this</code> is the class or interface type <em>T</em> within which the keyword <code>this</code> occurs.</del> <strong>Let <em>C</em> be the innermost enclosing class or interface declaration of a <code>this</code> expression. If <em>C</em> is generic, with type parameters <em>F<sub>1</sub></em>, ..., <em>F<sub>n</sub></em>, the type of <code>this</code> is <em>C&lt;F<sub>1</sub>, ..., F<sub>n</sub>&gt;</em>. Otherwise, the type of <code>this</code> is <em>C</em>.</strong></p>
<blockquote>
<p><del>Default methods provide the unique ability to access <code>this</code> inside an interface. (All other interface methods are either <code>abstract</code> or <code>static</code>, so provide no access to <code>this</code>.) As a result, it is possible for <code>this</code> to have an interface type.</del></p>
</blockquote>
<div class="editorial">
<p>It's now default methods <em>and</em> private methods. But this comment was interesting when default methods were introduced; now it's just restating the obvious: interfaces can have instance methods with bodies.</p>
</div>
<p>At run time, the class of the actual object referred to may be <del><em>T</em></del> <strong><em>C</em></strong>, if <del><em>T</em></del> <strong><em>C</em></strong> is a class <del>type</del>, or a <del>class that is a subtype of <em>T</em></del> <strong>subclass of <em>C</em></strong>.</p>
<div class="example">
<p>Example 15.8.3-1. The <code>this</code> Expression</p>
<pre><code>class IntVector {
    int[] v;
    boolean equals(IntVector other) {
        if (this == other)
            return true;
        if (v.length != other.v.length)
            return false;
        for (int i = 0; i &lt; v.length; i++) {
            if (v[i] != other.v[i]) return false;
        }
        return true;
    }
}</code></pre>
<p>Here, the class <code>IntVector</code> implements a method <code>equals</code>, which compares two vectors. If the other vector is the same vector object as the one for which the <code>equals</code> method was invoked, then the check can skip the length and value comparisons. The <code>equals</code> method implements this check by comparing the reference to the other object to <code>this</code>.</p>
</div>
<h4 id="jls-15.8.4">15.8.4 Qualified <code>this</code></h4>
<p>Any lexically enclosing instance (<a href="#jls-8.1.3">8.1.3</a>) can be referred to by explicitly qualifying the keyword <code>this</code>.</p>
<p><del>Let <em>T</em> be the type denoted by <em>TypeName</em>.</del> Let <em>n</em> be an integer such that <del><em>T</em></del> <strong><em>TypeName</em></strong> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class or interface in which the qualified <code>this</code> expression appears.</p>
<p>The value of an expression of the form <em>TypeName</em><code>.this</code> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p>
<p><strong>If <em>TypeName</em> is generic, with type parameters <em>F<sub>1</sub></em>, ..., <em>F<sub>n</sub></em>, the type of the expression is <em>TypeName&lt;F<sub>1</sub>, ..., F<sub>n</sub>&gt;</em>.</strong> <del>The</del> <strong>Otherwise, the</strong> type of the expression is <del><em>C</em></del> <strong><em>TypeName</em></strong>.</p>
<p>It is a compile-time error if <strong><em>TypeName</em> is not a lexically enclosing class or interface declaration of the expression, or if</strong> the expression occurs in a class or interface which is not an inner class of <del>class <em>T</em></del> <strong><em>TypeName</em></strong> or <del><em>T</em></del> <strong><em>TypeName</em></strong> itself.</p>
<h3 id="jls-15.9">15.9 Class Instance Creation Expressions</h3>
<h4 id="jls-15.9.1">15.9.1 Determining the Class being Instantiated</h4>
<p>If <em>ClassOrInterfaceTypeToInstantiate</em> ends with <em>TypeArguments</em> (rather than <code>&lt;&gt;</code>), then <em>ClassOrInterfaceTypeToInstantiate</em> must denote a well-formed parameterized type (<a href="#jls-4.5">4.5</a>), or a compile-time error occurs.</p>
<p>If <em>ClassOrInterfaceTypeToInstantiate</em> ends with <code>&lt;&gt;</code>, but the <del>type</del> <strong>class or interface</strong> denoted by the <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em> is not generic, then a compile-time error occurs.</p>
<p>If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class. Then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<p>The <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em> must denote either a class that is accessible, non-<code>final</code>, and not an enum <del>type</del> <strong>class</strong>, or an interface that is accessible (<a href="#jls-6.6">6.6</a>). Otherwise a compile-time error occurs.</p>
<p>If the <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em> denotes a class, <em>C</em>, then an anonymous direct subclass of <em>C</em> is declared. If <em>TypeArguments</em> is present, then <em>C</em> has type arguments given by <em>TypeArguments</em>; if <code>&lt;&gt;</code> is present, then <em>C</em> will have its type arguments inferred in <a href="#jls-15.9.3">15.9.3</a>; otherwise, <em>C</em> has no type arguments. The body of the subclass is the <em>ClassBody</em> given in the class instance creation expression. The class being instantiated is the anonymous subclass.</p>
<p>If the <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em> denotes an interface, <em>I</em>, then an anonymous direct subclass of <code>Object</code> that implements <em>I</em> is declared. If <em>TypeArguments</em> is present, then <em>I</em> has type arguments given by <em>TypeArguments</em>; if <code>&lt;&gt;</code> is present, then <em>I</em> will have its type arguments inferred in <a href="#jls-15.9.3">15.9.3</a>; otherwise, <em>I</em> has no type arguments. The body of the subclass is the <em>ClassBody</em> given in the class instance creation expression. The class being instantiated is the anonymous subclass.</p></li>
<li><p>If the class instance creation expression is qualified, then:</p>
<p>The <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em> must unambiguously denote an inner class that is accessible, non-<code>final</code>, not an enum <del>type</del> <strong>class</strong>, and a member of the compile-time type of the <em>Primary</em> expression or the <em>ExpressionName</em>. Otherwise, a compile-time error occurs.</p>
<p>Let the <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em> denote a class, <em>C</em>. An anonymous direct subclass of <em>C</em> is declared. If <em>TypeArguments</em> is present, then <em>C</em> has type arguments given by <em>TypeArguments</em>; if <code>&lt;&gt;</code> is present, then <em>C</em> will have its type arguments inferred in <a href="#jls-15.9.3">15.9.3</a>; otherwise, <em>C</em> has no type arguments. The body of the subclass is the <em>ClassBody</em> given in the class instance creation expression. The class being instantiated is the anonymous subclass.</p></li>
</ul>
<p>If a class instance creation expression does not declare an anonymous class, then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<p>The <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em> must denote a class that is accessible, non-<code>abstract</code>, and not an enum <del>type</del> <strong>class</strong>. Otherwise, a compile-time error occurs.</p>
<p>The class being instantiated is specified by the <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em>. If <em>TypeArguments</em> is present, then the class has type arguments given by <em>TypeArguments</em>; if <code>&lt;&gt;</code> is present, then the class will have its type arguments inferred in <a href="#jls-15.9.3">15.9.3</a>; otherwise, the class has no type arguments.</p></li>
<li><p>If the class instance creation expression is qualified, then:</p>
<p>The <em>ClassOrInterfaceTypeToInstantiate</em> must unambiguously denote an inner class that is accessible, non-<code>abstract</code>, not an enum <del>type</del> <strong>class</strong>, and a member of the compile-time type of the <em>Primary</em> expression or the <em>ExpressionName</em>.</p>
<p>The class being instantiated is specified by the <em>Identifier</em> in <em>ClassOrInterfaceTypeToInstantiate</em>. If <em>TypeArguments</em> is present, then the class has type arguments given by <em>TypeArguments</em>; if <code>&lt;&gt;</code> is present, then the class will have its type arguments inferred in <a href="#jls-15.9.3">15.9.3</a>; otherwise, the class has no type arguments.</p></li>
</ul>
<h4 id="jls-15.9.2">15.9.2 Determining Enclosing Instances</h4>
<p>Let <em>C</em> be the class being instantiated, and let <em>i</em> be the instance being created. If <em>C</em> is an inner class, then <em>i</em> may have an <em>immediately enclosing instance</em> (<a href="#jls-8.1.3">8.1.3</a>), determined as follows:</p>
<ul>
<li><p>If <em>C</em> is an anonymous class, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then <em>i</em> has no immediately enclosing instance.</p></li>
<li><p>Otherwise, the immediately enclosing instance of <em>i</em> is <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>C</em> is a local class, then:</p>
<ul>
<li><p>If <em>C</em> occurs in a static context, then <em>i</em> has no immediately enclosing instance.</p></li>
<li><p>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, let <em>O</em> be the immediately enclosing class <strong>or interface declaration</strong> of <em>C</em>. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>C</em> is an inner member class, then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, if <em>C</em> is a member of a class enclosing the class <strong>or interface</strong> in which the class instance creation expression appears, then let <em>O</em> be the immediately enclosing class of which <em>C</em> is a member. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the class instance creation expression is qualified, then the immediately enclosing instance of <em>i</em> is the object that is the value of the <em>Primary</em> expression or the <em>ExpressionName</em>.</p></li>
</ul></li>
</ul>
<p>If <em>C</em> is an anonymous class, and its direct superclass <em>S</em> is an inner class, then <em>i</em> may have an <em>immediately enclosing instance with respect to S</em>, determined as follows:</p>
<ul>
<li><p>If <em>S</em> is a local class, then:</p>
<ul>
<li><p>If <em>S</em> occurs in a static context, then <em>i</em> has no immediately enclosing instance with respect to <em>S</em>.</p></li>
<li><p>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, let <em>O</em> be the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>S</em>. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>S</em> is an inner member class, then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, if <em>S</em> is a member of a class enclosing the class <strong>or interface</strong> in which the class instance creation expression appears, then let <em>O</em> be the immediately enclosing class of which <em>S</em> is a member. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the class instance creation expression is qualified, then the immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the object that is the value of the <em>Primary</em> expression or the <em>ExpressionName</em>.</p></li>
</ul></li>
</ul>
<h4 id="jls-15.9.3">15.9.3 Choosing the Constructor and its Arguments</h4>
<p>Let <em>C</em> be the class being instantiated. To create an instance of <em>C</em>, <em>i</em>, a constructor of <em>C</em> is chosen at compile time by the following rules.</p>
<p>First, the actual arguments to the constructor invocation are determined:</p>
<ul>
<li><p>If <em>C</em> is an anonymous class with direct superclass <em>S</em>, then:</p>
<ul>
<li><p>If <em>S</em> is not an inner class, or if <em>S</em> is a local class that occurs in a static context, then the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.</p></li>
<li><p>Otherwise, the first argument to the constructor is the immediately enclosing instance of <em>i</em> with respect to <em>S</em> (<a href="#jls-15.9.2">15.9.2</a>), and the subsequent arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression.</p></li>
</ul></li>
<li><p>If <em>C</em> is a local class or a <code>private</code> inner member class, then the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression.</p></li>
<li><p>If <em>C</em> is a non-<code>private</code> inner member class, then the first argument to the constructor is the immediately enclosing instance of <em>i</em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="#jls-15.9.2">15.9.2</a>), and the subsequent arguments to its constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression.</p></li>
<li><p>Otherwise, the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.</p></li>
</ul>
<p>Second, a constructor of <em>C</em> and corresponding <code>throws</code> clause and return type are determined:</p>
<ul>
<li><p>If the class instance creation expression does not use <code>&lt;&gt;</code>, then:</p>
<ul>
<li><p>If <em>C</em> is not an anonymous class, then:</p>
<p>Let <em>T</em> be the type denoted by <em>C</em> followed by any class type arguments in the expression. The process specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2">15.12.2</a>, modified to handle constructors, is used to choose one of the constructors of <em>T</em> and determine its <code>throws</code> clause.</p>
<p>If there is no unique most-specific constructor in <em>T</em> that is both applicable and accessible (<a href="#jls-6.6">6.6</a>), then a compile-time error occurs (as in method invocations).</p>
<p>Otherwise, the return type corresponding to the chosen constructor is <em>T</em>.</p></li>
<li><p>If <em>C</em> is an anonymous class, then:</p>
<p>The process specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2">15.12.2</a>, modified to handle constructors, is used to choose one of the constructors of the direct superclass <strong>type</strong> of <em>C</em> and determine its <code>throws</code> clause.</p>
<p>If there is no unique most-specific constructor in the direct superclass <strong>type</strong> of <em>C</em> that is both applicable and accessible, then a compile-time error occurs (as in method invocations).</p>
<p>Otherwise, <em>C</em>'s anonymous constructor is chosen as the constructor of <em>C</em> (<a href="#jls-15.9.5.1">15.9.5.1</a>). Its body consists of an explicit constructor invocation (<a href="#jls-8.8.7.1">8.8.7.1</a>) of the constructor chosen in the direct superclass <strong>type</strong> of <em>C</em>.</p>
<p>The <code>throws</code> clause of the chosen constructor includes the exceptions in the <code>throws</code> clause of the constructor chosen in the direct superclass <strong>type</strong> of <em>C</em>.</p>
<p>The return type corresponding to the chosen constructor is the anonymous class type.</p></li>
</ul></li>
<li><p>If the class instance creation expression uses <code>&lt;&gt;</code>, then:</p>
<p>If <em>C</em> is not an anonymous class, let <em>D</em> be the same as <em>C</em>. If <em>C</em> is an anonymous class, let <em>D</em> be the superclass or superinterface of <em>C</em> named by the class instance creation expression.</p>
<div class="editorial">
<p>In this case, we are in fact talking about a superclass or superinterface, not a superclass or superinterface <em>type</em>.</p>
</div>
<p>If <em>D</em> is a class, let <em>c<sub>1</sub></em>...<em>c<sub>n</sub></em> be the constructors of class <em>D</em>. If <em>D</em> is an interface, let <em>c<sub>1</sub></em>...<em>c<sub>n</sub></em> be a singleton list (<em>n</em> = 1) containing the zero-argument constructor of class <code>Object</code>.</p>
<p>A list of methods <em>m<sub>1</sub></em>...<em>m<sub>n</sub></em> is defined for the purpose of overload resolution and type argument inference. For all <em>j</em> (1 <em>≤</em> <em>j</em> <em>≤</em> <em>n</em>), <em>m<sub>j</sub></em> is defined in terms of <em>c<sub>j</sub></em> as follows:</p>
<ul>
<li><p>A substitution <em>θ<sub>j</sub></em> is first defined to instantiate the types in <em>c<sub>j</sub></em>.</p>
<p>Let <em>F<sub>1</sub></em>...<em>F<sub>p</sub></em> be the type parameters of <em>D</em>, and let <em>G<sub>1</sub></em>...<em>G<sub>q</sub></em> be the type parameters (if any) of <em>c<sub>j</sub></em>. Let <em>X<sub>1</sub></em>...<em>X<sub>p</sub></em> and <em>Y<sub>1</sub></em>...<em>Y<sub>q</sub></em> be type variables with distinct names that are not in scope in the body of <em>D</em>.</p>
<p><em>θ<sub>j</sub></em> is <code>[F1:=X1, ..., Fp:=Xp, G1:=Y1, ..., Gq:=Yq]</code>.</p></li>
<li><p>The type parameters of <em>m<sub>j</sub></em> are <em>X<sub>1</sub></em>...<em>X<sub>p</sub></em>,<em>Y<sub>1</sub></em>...<em>Y<sub>q</sub></em>. The bound of each type parameter, if any, is <em>θ<sub>j</sub></em> applied to the corresponding type parameter bound in <em>D</em> or <em>c<sub>j</sub></em>.</p></li>
<li><p>The return type of <em>m<sub>j</sub></em> is <em>θ<sub>j</sub></em> applied to <em>D</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>p</sub></em><code>&gt;</code>.</p></li>
<li><p>The (possibly empty) list of argument types of <em>m<sub>j</sub></em> is <em>θ<sub>j</sub></em> applied to the argument types of <em>c<sub>j</sub></em>.</p></li>
<li><p>The (possibly empty) list of thrown types of <em>m<sub>j</sub></em> is <em>θ<sub>j</sub></em> applied to the thrown types of <em>c<sub>j</sub></em>.</p></li>
<li><p>The modifiers of <em>m<sub>j</sub></em> are those of <em>c<sub>j</sub></em>.</p></li>
<li><p>The name of <em>m<sub>j</sub></em> is <code>#m</code>, an automatically generated name that is distinct from all constructor and method names in <em>D</em> and is shared by <em>m<sub>1</sub></em>...<em>m<sub>n</sub></em>.</p></li>
<li><p>The body of <em>m<sub>j</sub></em> is irrelevant.</p></li>
</ul>
<p>To choose a constructor, we temporarily consider <em>m<sub>1</sub></em>...<em>m<sub>n</sub></em> to be members of <em>D</em>. One of <em>m<sub>1</sub></em>...<em>m<sub>n</sub></em> is chosen, as determined by the class instance creation expression's argument expressions, using the process specified in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2">15.12.2</a>.</p>
<p>If there is no unique most specific method that is both applicable and accessible, then a compile-time error occurs.</p>
<p>Otherwise, where <em>m<sub>j</sub></em> is the chosen method:</p>
<ul>
<li><p>If <em>C</em> is not an anonymous class, then <em>c<sub>j</sub></em> is chosen as the constructor of <em>C</em>.</p>
<p>The <code>throws</code> clause of the chosen constructor is the same as the <code>throws</code> clause determined for <em>m<sub>j</sub></em>.</p>
<p>The return type corresponding to the chosen constructor is the return type determined for <em>m<sub>j</sub></em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p></li>
<li><p>If <em>C</em> is an anonymous class, then <em>C</em>'s anonymous constructor is chosen as the constructor of <em>C</em>. Its body consists of an explicit constructor invocation (<a href="#jls-8.8.7.1">8.8.7.1</a>) of <em>c<sub>j</sub></em>.</p>
<p>The <code>throws</code> clause of the chosen constructor includes the exceptions in the <code>throws</code> clause determined for <em>m<sub>j</sub></em>.</p>
<p>The return type corresponding to the chosen constructor is the anonymous class type.</p></li>
</ul>
<p>If the class instance creation expression is a poly expression, then its compatibility with a target type is as determined by <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html#jls-18.5.2.1">18.5.2.1</a>, using <em>m<sub>j</sub></em> as the selected method <em>m</em>.</p>
<blockquote>
<p>Testing for compatibility with a target type may occur multiple times before making a final determination of the class instance creation expression's target type and the return type corresponding to the chosen constructor. For example, an enclosing method invocation expression may require testing the class instance creation expression for compatibility with different methods' formal parameter types.</p>
</blockquote>
<p>If <em>C</em> is an anonymous class, then its <strong>direct</strong> superclass <strong>type</strong> or <strong>direct</strong> superinterface <strong>type</strong> (<a href="#jls-15.9.5">15.9.5</a>) is the return type determined for <em>m<sub>j</sub></em> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p>
<p>It is a compile-time error if the <strong>direct</strong> superclass <strong>type</strong> or <strong>direct</strong> superinterface <strong>type</strong>, or any subexpression therein (&quot;subexpression&quot; includes type arguments of parameterized types, bounds of wildcard type arguments, and element types of array types, but excludes bounds of type variables), has one of the following forms:</p>
<ul>
<li><p>A type variable that was not declared as a type parameter (such as a type variable produced by capture conversion).</p></li>
<li><p>An intersection type.</p></li>
<li><p>A class or interface type, where the class or interface declaration is not accessible from the class or interface in which the class instance creation expression appears.</p></li>
</ul></li>
</ul>
<p>It is a compile-time error if an argument to a class instance creation expression is not compatible with its target type, as derived from the invocation type (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p>
<p>If the compile-time declaration is applicable by variable arity invocation (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>), then where the last formal parameter type of the invocation type of the constructor is <em>F<sub>n</sub></em><code>[]</code>, it is a compile-time error if the type which is the erasure of <em>F<sub>n</sub></em> is not accessible at the point of invocation.</p>
<p>The type of the class instance creation expression is the return type corresponding to the chosen constructor, as defined above.</p>
<h4 id="jls-15.9.4">15.9.4 Run-Time Evaluation of Class Instance Creation Expressions</h4>
<p>At run time, evaluation of a class instance creation expression is as follows.</p>
<p>First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifying expression evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the class instance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.</p>
<p>Next, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an <code>OutOfMemoryError</code>.</p>
<p>The new object contains new instances of all the fields declared in the specified class <del>type</del> and all its superclasses. As each new field instance is created, it is initialized to its default value (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12.5">4.12.5</a>).</p>
<p>Next, the actual arguments to the constructor are evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.</p>
<p>Next, the selected constructor of the specified class <del>type</del> is invoked. This results in invoking at least one constructor for each superclass of the class <del>type</del>. This process can be directed by explicit constructor invocation statements (<a href="#jls-8.8.7.1">8.8.7.1</a>) and is specified in detail in <a href="#jls-12.5">12.5</a>.</p>
<p>The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.</p>
<p>...</p>
<h4 id="jls-15.9.5">15.9.5 Anonymous Class Declarations</h4>
<p>An anonymous class <del>declaration is automatically derived from</del> <strong>is implicitly declared by</strong> a class instance creation expression <strong>or an enum constant (<a href="#jls-8.9.1">8.9.1</a>) that ends with a class body</strong> <del>by the Java compiler</del>.</p>
<p>An anonymous class is never <code>abstract</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.1.1">8.1.1.1</a>).</p>
<p>An anonymous class <strong>declared by a class instance creation expression</strong> is never <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>). <strong>An anonymous class declared by an enum constant is always <code>final</code>.</strong></p>
<div class="editorial">
<p>There is a long history of efforts to make these rules more reasonable, which I believe were abandoned due to compatibility concerns. The above reflects the actual behavior of <code>javac</code> in JDK 14.</p>
</div>
<blockquote>
<p>The <del>fact that an anonymous class is not <code>final</code></del> <strong>treatment of <code>final</code></strong> is relevant in casting, in particular the narrowing reference conversion allowed for the cast operator (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.5">5.5</a>). It is <del>also of interest in</del> <strong>not relevant to</strong> subclassing, <del>in that</del> <strong>because</strong> it is impossible to declare a subclass of an anonymous class, despite <del>an</del> <strong>the</strong> anonymous class being non-<code>final</code>, because an anonymous class cannot be named by an <code>extends</code> clause (<a href="#jls-8.1.4">8.1.4</a>).</p>
</blockquote>
<p>An anonymous class is always an inner class (<a href="#jls-8.1.3">8.1.3</a>)<del>; it is never <code>static</code> (<a href="#jls-8.1.1">8.1.1</a>, <a href="#jls-8.5.1">8.5.1</a>)</del>.</p>
<div class="editorial">
<p>The <code>static</code> modifier is only meaningful to member classes. No need to mention it here, just like there's no mention of access control.</p>
</div>
<p>The <strong>direct</strong> superclass <strong>type</strong> or <strong>direct</strong> superinterface <strong>type</strong> of an anonymous class <strong>declared by a class instance creation expression</strong> is given by the <del>class instance creation</del> expression (<a href="#jls-15.9.1">15.9.1</a>), with type arguments inferred as necessary while choosing a constructor (<a href="#jls-15.9.3">15.9.3</a>). <strong>If a direct superinterface type is given, the direct superclass type is <code>Object</code>.</strong></p>
<p><strong>The direct superclass type of an anonymous class declared by an enum constant is the type of the declaring enum class.</strong></p>
<p><strong>The <em>ClassBody</em> of the class instance creation expression or enum constant declares fields (<a href="#jls-8.3">8.3</a>), methods (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4">8.4</a>), member classes (<a href="#jls-8.5">8.5</a>), and instance initializers (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.6">8.6</a>) of the anonymous class. The constructor of an anonymous class is always implicit (<a href="#jls-15.9.5.1">15.9.5.1</a>).</strong></p>
<p>If the class instance creation expression uses <code>&lt;&gt;</code> with an anonymous class, then for all non-<code>private</code> methods declared in the <del>anonymous</del> class body, it is as if the method declaration is annotated with <code>@Override</code> (<a href="#jls-9.6.4.4">9.6.4.4</a>).</p>
<blockquote>
<p>When <code>&lt;&gt;</code> is used, the inferred type arguments may not be as anticipated by the programmer. Consequently, the supertype of the anonymous class may not be as anticipated, and methods declared in the anonymous class may not override supertype methods as intended. Treating such methods as if annotated with <code>@Override</code> (if they are not explicitly annotated with <code>@Override</code>) helps avoid silently incorrect programs.</p>
</blockquote>
<h5 id="jls-15.9.5.1">15.9.5.1 Anonymous Constructors</h5>
<p>An anonymous class cannot have an explicitly declared constructor. Instead, an anonymous constructor is implicitly declared for an anonymous class. The form of the anonymous constructor for an anonymous class <em>C</em> with direct superclass <del><em>S</em></del> <strong><em>A</em></strong> is as follows:</p>
<div class="editorial">
<p><a href="#jls-15.9.3">15.9.3</a> uses <em>S</em> to talk about the superclass type. Here, we want to talk about the class named by that type. It's helpful to distinguish the two by using a different letter, <em>A</em>.</p>
</div>
<ul>
<li><p>If <del><em>S</em></del> <strong><em>A</em></strong> is not an inner class, or if <del><em>S</em></del> <strong><em>A</em></strong> is a local class that occurs in a static context, then the anonymous constructor has one formal parameter for each actual argument to the class instance creation expression <strong>or enum constant</strong> in which <em>C</em> is declared.</p>
<p>The actual arguments to the class instance creation expression <strong>or enum constant</strong> are used to determine a constructor <del><em>cs</em></del> <strong><em>ca</em></strong> of <del><em>S</em></del> <strong><em>A</em></strong>, as specified by <a href="#jls-15.9.3">15.9.3</a>. The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of <del><em>cs</em></del> <strong><em>ca</em></strong>.</p>
<p>The constructor body consists of an explicit constructor invocation (<a href="#jls-8.8.7.1">8.8.7.1</a>) of the form <code>super(...)</code>, where the actual arguments are the formal parameters of the constructor, in the order they were declared. The superclass constructor to be invoked is <del><em>cs</em></del> <strong><em>ca</em></strong>.</p></li>
<li><p>Otherwise, the first formal parameter of the constructor of <em>C</em> represents the value of the immediately enclosing instance of <em>i</em> with respect to <del><em>S</em></del> <strong><em>A</em></strong> (<a href="#jls-15.9.2">15.9.2</a>, <a href="#jls-15.9.3">15.9.3</a>). The type of this parameter is the class type that immediately encloses the declaration of <del><em>S</em></del> <strong><em>A</em></strong>.</p>
<p>The constructor has an additional formal parameter for each actual argument to the class instance creation expression that declared the anonymous class. The <em>n</em>'th formal parameter <em>e</em> corresponds to the <em>n-1</em>'th actual argument.</p>
<p>The actual arguments to the class instance creation expression are used to determine a constructor <del><em>cs</em></del> <strong><em>ca</em></strong> of <del><em>S</em></del> <strong><em>A</em></strong>, as specified by <a href="#jls-15.9.3">15.9.3</a>. The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of <del><em>cs</em></del> <strong><em>ca</em></strong>.</p>
<p>The constructor body consists of an explicit constructor invocation (<a href="#jls-8.8.7.1">8.8.7.1</a>) of the form <code>o.super(...)</code>, where <code>o</code> is the first formal parameter of the constructor, and the actual arguments are the subsequent formal parameters of the constructor, in the order they were declared. The superclass constructor to be invoked is <del><em>cs</em></del> <strong><em>ca</em>.</strong></p></li>
</ul>
<p>In all cases, the <code>throws</code> clause of an anonymous constructor <del>must list</del> <strong>lists</strong> all the checked exceptions thrown by the explicit superclass constructor invocation statement contained within the anonymous constructor, as specified in <a href="#jls-15.9.3">15.9.3</a>, and all checked exceptions thrown by any instance initializers or instance variable initializers of the anonymous class.</p>
<p>Note that it is possible for the signature of the anonymous constructor to refer to an inaccessible type (for example, if such a type occurred in the signature of the superclass constructor <em>cs</em>). This does not, in itself, cause any errors at either compile-time or run-time.</p>
<h3 id="jls-15.12">15.12 Method Invocation Expressions</h3>
<h4 id="jls-15.12.1">15.12.1 Compile-Time Step 1: Determine <del>Class or Interface</del> <strong>Type</strong> to Search</h4>
<p>The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which <del>class or interface</del> <strong>type</strong> to search for definitions of methods of that name.</p>
<p>The name of the method is specified by the <em>MethodName</em> or <em>Identifier</em> which immediately precedes the left parenthesis of the <em>MethodInvocation</em>.</p>
<p>For the <del>class or interface</del> <strong>type</strong> to search, there are six cases to consider, depending on the form that precedes the left parenthesis of the <em>MethodInvocation</em>:</p>
<ul>
<li><p>If the form is <em>MethodName</em>, that is, just an <em>Identifier</em>, then:</p>
<p>If the <em>Identifier</em> appears in the scope of a method declaration with that name (<a href="#jls-6.3">6.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.4.1">6.4.1</a>), then:</p>
<ul>
<li><p>If there is an enclosing <del>type</del> <strong>class or interface</strong> declaration of which that method is a member, let <del><em>T</em></del> <strong><em>E</em></strong> be the innermost such <del>type</del> <strong>class or interface</strong> declaration. The <del>class or interface</del> <strong>type</strong> to search is <del><em>T</em></del> <strong>the type of <em>E</em>.<code>this</code> (<a href="#jls-15.8.4">15.8.4</a>)</strong>.</p>
<blockquote>
<p>This search policy is called the &quot;comb rule&quot;. It effectively looks for methods in a nested class's superclass hierarchy before looking for methods in an enclosing class and its superclass hierarchy. See <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-6.html#jls-6.5.7.1">6.5.7.1</a> for an example.</p>
</blockquote></li>
<li><p>Otherwise, the method declaration may be in scope due to one or more single-static-import or static-import-on-demand declarations. There is no <del>class or interface</del> <strong>type</strong> to search, as the method to be invoked is determined later (<a href="#jls-15.12.2.1">15.12.2.1</a>).</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the type to search is the <strong>(possibly raw)</strong> type denoted by <em>TypeName</em>.</p></li>
<li><p>If the form is <em>ExpressionName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the <del>class or interface</del> <strong>type</strong> to search is the declared type <em>T</em> of the variable denoted by <em>ExpressionName</em> if <em>T</em> is a class or interface type, or the upper bound of <em>T</em> if <em>T</em> is a type variable.</p></li>
<li><p>If the form is <em>Primary</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then let <em>T</em> be the type of the <em>Primary</em> expression. The <del>class or interface</del> <strong>type</strong> to search is <em>T</em> if <em>T</em> is a class or interface type, or the upper bound of <em>T</em> if <em>T</em> is a type variable.</p>
<p>It is a compile-time error if <em>T</em> is not a reference type.</p></li>
<li><p>If the form is <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the <del>class</del> <strong>type</strong> to search is the <strong>direct</strong> superclass <strong>type</strong> of the class whose declaration contains the method invocation.</p>
<p>Let <del><em>T</em></del> <strong><em>E</em></strong> be the <del>type declaration</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation. It is a compile-time error if <del><em>T</em></del> <strong><em>E</em></strong> is the class <code>Object</code> or <del><em>T</em></del> <strong><em>E</em></strong> is an interface.</p></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if <em>TypeName</em> denotes neither a class nor an interface.</p></li>
<li><p>If <em>TypeName</em> denote a class, <em>C</em>, then the <del>class</del> <strong>type</strong> to search is the <strong>direct</strong> superclass <strong>type</strong> of <em>C</em>.</p>
<p>It is a compile-time error if <em>C</em> is not a lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the current class <strong>or interface</strong>, or if <em>C</em> is the class <code>Object</code>.</p>
<p>Let <del><em>T</em></del> <strong><em>E</em></strong> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation. It is a compile-time error if <del><em>T</em></del> <strong><em>E</em></strong> is the class <code>Object</code>.</p></li>
<li><p>Otherwise, <em>TypeName</em> denotes <del>the interface to be searched</del> <strong>an interface</strong>, <em>I</em>.</p>
<p>Let <del><em>T</em></del> <strong><em>E</em></strong> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation.<br />
It is a compile-time error if <em>I</em> is not a direct superinterface of <del><em>T</em></del> <strong><em>E</em></strong>, or if there exists some other direct superclass or direct superinterface of <del><em>T</em></del> <strong><em>E</em></strong>, <em>J</em>, such that <em>J</em> is <del>a subtype</del> <strong>a subclass or subinterface</strong> of <em>I</em>.</p>
<p><strong>The type to search is the type of <em>I</em> that is a direct superinterface type of <em>E</em>.</strong></p></li>
</ul></li>
</ul>
<blockquote>
<p>The <em>TypeName</em> <code>.</code> <code>super</code> syntax is overloaded: traditionally, the <em>TypeName</em> refers to a lexically enclosing <del>type</del> <strong>class</strong> declaration <del>which is a class</del>, and the target is the superclass of this class, as if the invocation were an unqualified <code>super</code> in the lexically enclosing <del>type</del> <strong>class</strong> declaration.</p>
<pre><code>class Superclass {
    void foo() { System.out.println(&quot;Hi&quot;); }
}

class Subclass1 extends Superclass {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass1.super.foo();  // Gets the &#39;println&#39; behavior
        }
    };
}</code></pre>
<p>To support invocation of default methods in superinterfaces, the <em>TypeName</em> may also refer to a direct superinterface of the current class or interface, and the target is that superinterface.</p>
<pre><code>interface Superinterface {
    default void foo() { System.out.println(&quot;Hi&quot;); }
}

class Subclass2 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    void tweak() {
        Superinterface.super.foo();  // Gets the &#39;println&#39; behavior
    }
}</code></pre>
<p>No syntax supports a combination of these forms, that is, invoking a superinterface method of a lexically enclosing <del>type</del> <strong>class</strong> declaration <del>which is a class</del>, as if the invocation were of the form <em>InterfaceName</em> <code>.</code> <code>super</code> in the lexically enclosing <del>type</del> <strong>class</strong> declaration.</p>
<pre><code>class Subclass3 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass3.Superinterface.super.foo();  // Illegal
        }
    };
}</code></pre>
<p>A workaround is to introduce a <code>private</code> method in the lexically enclosing <del>type</del> <strong>class</strong> declaration<del>,</del> that performs the interface <code>super</code> call.</p>
</blockquote>
<h4 id="jls-15.12.2">15.12.2 Compile-Time Step 2: Determine Method Signature</h4>
<h5 id="jls-15.12.2.1">15.12.2.1 Identify Potentially Applicable Methods</h5>
<p>The <del>class or interface</del> <strong>type</strong> determined by compile-time step 1 (<a href="#jls-15.12.1">15.12.1</a>) is searched for all member methods that are potentially applicable to this method invocation; members inherited from superclasses and superinterfaces are included in this search.</p>
<p>...</p>
<h4 id="jls-15.12.3">15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?</h4>
<p>If there is a most specific method declaration for a method invocation, it is called the <em>compile-time declaration</em> for the method invocation.</p>
<p>It is a compile-time error if an argument to a method invocation is not compatible with its target type, as derived from the invocation type of the compile-time declaration.</p>
<p>If the compile-time declaration is applicable by variable arity invocation, then where the last formal parameter type of the invocation type of the method is <em>F<sub>n</sub></em><code>[]</code>, it is a compile-time error if the type which is the erasure of <em>F<sub>n</sub></em> is not accessible (<a href="#jls-6.6">6.6</a>) at the point of invocation.</p>
<p>If the compile-time declaration is <code>void</code>, then the method invocation must be a top level expression (that is, the <em>Expression</em> in an expression statement or in the <em>ForInit</em> or <em>ForUpdate</em> part of a <code>for</code> statement), or a compile-time error occurs. Such a method invocation produces no value and so must be used only in a situation where a value is not needed.</p>
<p>In addition, whether the compile-time declaration is appropriate may depend on the form of the method invocation expression before the left parenthesis, as follows:</p>
<ul>
<li><p>If the form is <em>MethodName</em> - that is, just an <em>Identifier</em> - and the compile-time declaration is an instance method, then:</p>
<ul>
<li><p>It is a compile-time error if the method invocation occurs in a static context (<a href="#jls-8.1.3">8.1.3</a>).</p></li>
<li><p>Otherwise, let <em>C</em> be the immediately enclosing class <strong>or interface declaration</strong> of which the compile-time declaration is a member. If the method invocation is not directly enclosed by <em>C</em> or an inner class of <em>C</em>, then a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the compile-time declaration must be <code>static</code>, or a compile-time error occurs.</p></li>
<li><p>If the form is <em>ExpressionName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>Primary</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the compile-time declaration must not be a <code>static</code> method declared in an interface, or a compile-time error occurs.</p></li>
<li><p>If the form is <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if the compile-time declaration is <code>abstract</code>.</p></li>
<li><p>It is a compile-time error if the method invocation occurs in a static context.</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if the compile-time declaration is <code>abstract</code>.</p></li>
<li><p>It is a compile-time error if the method invocation occurs in a static context.</p></li>
<li><p>If <em>TypeName</em> denotes a class <em>C</em>, then if the method invocation is not directly enclosed by <em>C</em> or an inner class of <em>C</em>, a compile-time error occurs.</p></li>
<li><p>If <em>TypeName</em> denotes an interface, let <del><em>T</em></del> <strong><em>E</em></strong> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation. A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides (<a href="#jls-9.4.1">9.4.1</a>) the compile-time declaration from a direct superclass or direct superinterface of <del><em>T</em></del> <strong><em>E</em></strong>.</p>
<blockquote>
<p>In the case that a superinterface overrides a method declared in a grandparent interface, this rule prevents the child interface from &quot;skipping&quot; the override by simply adding the grandparent to its list of direct superinterfaces. The appropriate way to access functionality of a grandparent is through the direct superinterface, and only if that interface chooses to expose the desired behavior. (Alternately, the programmer is free to define an additional superinterface that exposes the desired behavior with a <code>super</code> method invocation.)</p>
</blockquote></li>
</ul></li>
</ul>
<p>...</p>
<h5 id="jls-15.12.4.3">15.12.4.3 Check Accessibility of Type and Method</h5>
<p>In this section:</p>
<ul>
<li><p>Let <em>D</em> be the class containing the method invocation.</p></li>
<li><p>Let <del><em>T</em></del> <strong><em>Q</em></strong> be the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation (<a href="#jls-13.1">13.1</a>).</p></li>
<li><p>Let <em>m</em> be the name of the method as determined at compile time (<a href="#jls-15.12.3">15.12.3</a>).</p></li>
</ul>
<p>An implementation of the Java programming language must ensure, as part of linkage, that the <del>type <em>T</em></del> <strong>class or interface <em>Q</em></strong> is accessible:</p>
<ul>
<li><p>If <del><em>T</em></del> <strong><em>Q</em></strong> is in the same package as <em>D</em>, then <del><em>T</em></del> <strong><em>Q</em></strong> is accessible.</p></li>
<li><p>If <del><em>T</em></del> <strong><em>Q</em></strong> is in a different package than <em>D</em>, and their packages are in the same module, and <del><em>T</em></del> <strong><em>Q</em></strong> is <code>public</code> or <code>protected</code>, then <del><em>T</em></del> <strong><em>Q</em></strong> is accessible.</p></li>
<li><p>If <del><em>T</em></del> <strong><em>Q</em></strong> is in a different package than <em>D</em>, and their packages are in different modules, and <del><em>T</em></del> <strong><em>Q</em></strong>'s module exports <del><em>T</em></del> <strong><em>Q</em></strong>'s package to <em>D</em>'s module, and <del><em>T</em></del> <strong><em>Q</em></strong> is <code>public</code> or <code>protected</code>, then <del><em>T</em></del> <strong><em>Q</em></strong> is accessible.</p></li>
</ul>
<blockquote>
<p>If <del><em>T</em></del> <strong><em>Q</em></strong> is <code>protected</code>, it is necessarily a nested <del>type</del> <strong>class or interface</strong>, so at compile time, its accessibility is affected by the accessibility of <del>types</del> <strong>classes and interfaces</strong> enclosing its declaration. However, during linkage, its accessibility is not affected by the accessibility of <del>types</del> <strong>classes and interfaces</strong> enclosing its declaration. Moreover, during linkage, a <code>protected</code> <del><em>T</em></del> <strong><em>Q</em></strong> is as accessible as a <code>public</code> <del><em>T</em></del> <strong><em>Q</em></strong>. These discrepancies between access control at compile time (<a href="#jls-6.6">6.6</a>) and access control at run time are due to limitations in the Java Virtual Machine.</p>
</blockquote>
<p>The implementation must also ensure, during linkage, that the method <em>m</em> can still be found in <del><em>T</em></del> <strong><em>Q</em></strong> or a <del>supertype</del> <strong>superclass or superinterface</strong> of <del><em>T</em></del> <strong><em>Q</em></strong>. If <em>m</em> cannot be found, then a <code>NoSuchMethodError</code> (which is a subclass of <code>IncompatibleClassChangeError</code>) occurs. If <em>m</em> can be found, then let <em>C</em> be the <del>type</del> <strong>class or interface</strong> that declares <em>m</em>. The implementation must ensure, during linkage, that the declaration of <em>m</em> in <em>C</em> is accessible to <em>D</em>:</p>
<ul>
<li><p>If <em>m</em> is <code>public</code>, then <em>m</em> is accessible.</p></li>
<li><p>If <em>m</em> is <code>protected</code>, then <em>m</em> is accessible iff (i) either <em>D</em> is in the same package as <em>C</em>, or <em>D</em> is a <del>subtype</del> <strong>subclass</strong> of <em>C</em> or <em>C</em> itself; and (ii) if <em>m</em> is a <code>protected</code> instance method, then <del><em>T</em></del> <strong><em>Q</em></strong> must be a <del>subtype</del> <strong>subclass</strong> of <em>D</em> or <em>D</em> itself.</p>
<blockquote>
<p>This is the only place where <del><em>T</em></del> <strong><em>Q</em></strong> is involved in checks for <em>m</em>, because a <code>protected</code> instance method may only be invoked via a qualifying <del>type</del> <strong>class or interface</strong> that aligns with the invoker's type.</p>
</blockquote></li>
<li><p>If <em>m</em> has package access, then <em>m</em> is accessible iff <em>D</em> is in the same package as <em>C</em>.</p></li>
<li><p>If <em>m</em> is <code>private</code>, then <em>m</em> is accessible iff <em>D</em> is <em>C</em>, or <em>D</em> encloses <em>C</em>, or <em>C</em> encloses <em>D</em>, or <em>C</em> and <em>D</em> are both enclosed by a third <del>type</del> <strong>class or interface</strong>.</p></li>
</ul>
<p>If either <del><em>T</em></del> <strong><em>Q</em></strong> or <em>m</em> is not accessible, then an <code>IllegalAccessError</code> occurs (<a href="#jls-12.3">12.3</a>).</p>
<p>If the invocation mode is <code>interface</code>, then the implementation must check that the target reference <del>type</del> <strong>class</strong> still implements the specified interface. If the target reference <del>type</del> <strong>class</strong> does not still implement the interface, then an <code>IncompatibleClassChangeError</code> occurs.</p>
<h5 id="jls-15.12.4.4">15.12.4.4 Locate Method to Invoke</h5>
<p>As in the previous section (<a href="#jls-15.12.4.3">15.12.4.3</a>):</p>
<ul>
<li><p>Let <del><em>T</em></del> <strong><em>Q</em></strong> be the qualifying <del>type</del> <strong>class or interface</strong> of the method invocation (<a href="#jls-13.1">13.1</a>).</p></li>
<li><p>Let <em>m</em> be the method found in <del><em>T</em></del> <strong><em>Q</em></strong> or a <del>supertype</del> <strong>superclass or superinterface</strong> of <del><em>T</em></del> <strong><em>Q</em></strong>. (Note that <em>m</em> was merely the name of the method in the previous section; here it is the actual declaration.)</p></li>
<li><p>Let <em>C</em> be the class or interface that declares <em>m</em>.</p></li>
</ul>
<p>The strategy for locating a method to invoke depends on the invocation mode:</p>
<ul>
<li><p>If the invocation mode is <code>static</code>, no target reference is needed and overriding is not allowed. Method <em>m</em> of class or interface <em>C</em> is the one to be invoked.</p></li>
<li><p>Otherwise, an instance method is to be invoked and there is a target reference. If the target reference is <code>null</code>, a <code>NullPointerException</code> is thrown at this point. Otherwise, the target reference is said to refer to a <em>target object</em> and will be used as the value of the keyword <code>this</code> in the invoked method. The other three possibilities for the invocation mode are then considered:</p>
<ul>
<li><p>If the invocation mode is <code>super</code>, overriding is not allowed. Method <em>m</em> of class or interface <em>C</em> is the one to be invoked. If <em>m</em> is <code>abstract</code>, an <code>AbstractMethodError</code> is thrown.</p></li>
<li><p>Otherwise, if the invocation mode is <code>virtual</code>, and <em>T</em> and <em>m</em> jointly indicate a signature polymorphic method (<a href="#jls-15.12.3">15.12.3</a>), then the target object is an instance of <code>java.lang.invoke.MethodHandle</code> or <code>java.lang.invoke.VarHandle</code>. The target object encapsulates state which is matched against the information associated with the method invocation at compile time. Details of this matching are given in <em>The Java Virtual Machine Specification, Java SE 15 Edition</em> and the Java SE Platform API. If matching succeeds, then either the method referenced by the <code>java.lang.invoke.MethodHandle</code> instance is directly and immediately invoked, or the variable represented by the <code>java.lang.invoke.VarHandle</code> instance is directly and immediately accessed, <em>and in either case the procedure in <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.12.4.5">15.12.4.5</a> is not executed</em>. If matching fails, then a <code>java.lang.invoke.WrongMethodTypeException</code> is thrown.</p></li>
<li><p>Otherwise, the invocation mode is <code>interface</code> or <code>virtual</code>.</p>
<p>If the method <em>m</em> of class or interface <em>C</em> is <code>private</code>, then it is the method to be invoked.</p>
<p>Otherwise, overriding may occur. A <em>dynamic method lookup</em>, specified below, is used to locate the method to invoke. The lookup procedure starts from class <em>R</em>, the actual run-time class of the target object.</p>
<blockquote>
<p>Note that for invocation mode <code>interface</code>, <em>R</em> necessarily implements <del><em>T</em></del> <strong><em>Q</em></strong>; for invocation mode <code>virtual</code>, <em>R</em> is necessarily either <del><em>T</em></del> <strong><em>Q</em></strong> or a subclass of <del><em>T</em></del> <strong><em>Q</em></strong>. If the target object is an array, then <em>R</em> is a &quot;class&quot; representing an array type.</p>
</blockquote></li>
</ul></li>
</ul>
<p>...</p>
<h3 id="jls-15.13">15.13 Method Reference Expressions</h3>
<p>A method reference expression is used to refer to the invocation of a method without actually performing the invocation. Certain forms of method reference expression also allow class instance creation (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.9">15.9</a>) or array creation (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.10">15.10</a>) to be treated as if it were a method invocation.</p>
<dl>
<dt><em>MethodReference:</em></dt>
<dd><em>ExpressionName</em> <code>::</code> [<em>TypeArguments</em>] <em>Identifier</em>
</dd>
<dd><em>Primary</em> <code>::</code> [<em>TypeArguments</em>] <em>Identifier</em>
</dd>
<dd><em>ReferenceType</em> <code>::</code> [<em>TypeArguments</em>] <em>Identifier</em>
</dd>
<dd><code>super</code> <code>::</code> [<em>TypeArguments</em>] <em>Identifier</em>
</dd>
<dd><em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> [<em>TypeArguments</em>] <em>Identifier</em>
</dd>
<dd><em>ClassType</em> <code>::</code> [<em>TypeArguments</em>] <code>new</code>
</dd>
<dd><em>ArrayType</em> <code>::</code> <code>new</code>
</dd>
</dl>
<p>If <em>TypeArguments</em> is present to the right of <code>::</code>, then it is a compile-time error if any of the type arguments are wildcards (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">4.5.1</a>).</p>
<p>If a method reference expression has the form <em>ExpressionName</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>Primary</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, it is a compile-time error if the type of the <em>ExpressionName</em> or <em>Primary</em> is not a reference type.</p>
<p>If a method reference expression has the form <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, let <del><em>T</em></del> <strong><em>E</em></strong> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method reference expression. It is a compile-time error if <del><em>T</em></del> <strong><em>E</em></strong> is the class <code>Object</code> or <del><em>T</em></del> <strong><em>E</em></strong> is an interface.</p>
<p>If a method reference expression has the form <em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>If <em>TypeName</em> denotes a class, <em>C</em>, then it is a compile-time error if <em>C</em> is not a lexically enclosing class of the current class, or if <em>C</em> is the class <code>Object</code>.</p></li>
<li><p>If <em>TypeName</em> denotes an interface, <em>I</em>, then let <del><em>T</em></del> <strong><em>E</em></strong> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method reference expression. It is a compile-time error if <em>I</em> is not <strong>named by</strong> a direct superinterface <strong>type</strong> of <del><em>T</em></del> <strong><em>E</em></strong>, or if there exists some other direct superclass <strong>type</strong> or direct superinterface <strong>type</strong> of <del><em>T</em></del> <strong><em>E</em></strong><del>,</del> <strong>naming a class or interface</strong> <em>J</em>, such that <em>J</em> is a <del>subtype</del> <strong>subclass or subinterface</strong> of <em>I</em>.</p></li>
<li><p>If <em>TypeName</em> denotes a type variable, then a compile-time error occurs.</p></li>
</ul>
<p>If a method reference expression has the form <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>TypeName</em> <code>.</code> <code>super</code> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em>, it is a compile-time error if the expression occurs in a static context.</p>
<p>If a method reference expression has the form <em>ClassType</em> <code>::</code> <em>[TypeArguments]</em> <code>new</code>, then:</p>
<ul>
<li><p><em>ClassType</em> must <del>denote</del> <strong>name</strong> a class that is accessible (<a href="#jls-6.6">6.6</a>), non-<code>abstract</code>, and not an enum <del>type</del> <strong>class</strong>, or a compile-time error occurs.</p></li>
<li><p>If <em>ClassType</em> denotes a parameterized type (<a href="#jls-4.5">4.5</a>), then it is a compile-time error if any of its type arguments are wildcards.</p></li>
<li><p>If <em>ClassType</em> denotes a raw type (<a href="#jls-4.8">4.8</a>), then it is a compile-time error if <em>TypeArguments</em> is present after the <code>::</code>.</p></li>
</ul>
<p>If a method reference expression has the form <em>ArrayType</em> <code>::</code> <code>new</code>, then <em>ArrayType</em> must denote a type that is reifiable (<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.7">4.7</a>), or a compile-time error occurs.</p>
<p>...</p>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2021, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java16.0.1speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 16.0.1+9-24 --></footer>
</body>
</html>