<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>MemorySegment (Java SE 16 &amp; JDK 16)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: jdk.incubator.foreign, package: jdk.incubator.foreign, interface: MemorySegment">
<meta name="generator" content="javadoc/ClassWriterImpl">
<meta name="keywords" content="jdk.incubator.foreign.MemorySegment interface">
<meta name="keywords" content="READ">
<meta name="keywords" content="WRITE">
<meta name="keywords" content="CLOSE">
<meta name="keywords" content="SHARE">
<meta name="keywords" content="HANDOFF">
<meta name="keywords" content="ALL_ACCESS">
<meta name="keywords" content="address()">
<meta name="keywords" content="spliterator()">
<meta name="keywords" content="ownerThread()">
<meta name="keywords" content="byteSize()">
<meta name="keywords" content="withAccessModes()">
<meta name="keywords" content="hasAccessModes()">
<meta name="keywords" content="accessModes()">
<meta name="keywords" content="asSlice()">
<meta name="keywords" content="isMapped()">
<meta name="keywords" content="isAlive()">
<meta name="keywords" content="close()">
<meta name="keywords" content="handoff()">
<meta name="keywords" content="share()">
<meta name="keywords" content="registerCleaner()">
<meta name="keywords" content="fill()">
<meta name="keywords" content="copyFrom()">
<meta name="keywords" content="mismatch()">
<meta name="keywords" content="asByteBuffer()">
<meta name="keywords" content="toByteArray()">
<meta name="keywords" content="toShortArray()">
<meta name="keywords" content="toCharArray()">
<meta name="keywords" content="toIntArray()">
<meta name="keywords" content="toFloatArray()">
<meta name="keywords" content="toLongArray()">
<meta name="keywords" content="toDoubleArray()">
<meta name="keywords" content="ofByteBuffer()">
<meta name="keywords" content="ofArray()">
<meta name="keywords" content="allocateNative()">
<meta name="keywords" content="mapFile()">
<meta name="keywords" content="ofNativeRestricted()">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 14px;"><strong>Java SE 16 &amp; JDK 16</strong> </div></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/MemorySegment.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">jdk.incubator.foreign</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">jdk.incubator.foreign</a></div>
<h1 title="Interface MemorySegment" class="title">Interface MemorySegment</h1>
</div>
<section class="description">
<dl class="notes">
<dt>All Superinterfaces:</dt>
<dd><code><a href="Addressable.html" title="interface in jdk.incubator.foreign">Addressable</a></code>, <code><a href="../../../../java.base/java/lang/AutoCloseable.html" title="interface in java.lang">AutoCloseable</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">MemorySegment</span><span class="extends-implements">
extends <a href="Addressable.html" title="interface in jdk.incubator.foreign">Addressable</a>, <a href="../../../../java.base/java/lang/AutoCloseable.html" title="interface in java.lang">AutoCloseable</a></span></div>
<div class="block">A memory segment models a contiguous region of memory. A memory segment is associated with both spatial
 and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location
 which falls <em>outside</em> the boundaries of the memory segment being accessed. Temporal bounds ensure that memory access
 operations on a segment cannot occur after a memory segment has been closed (see <a href="#close()"><code>close()</code></a>).
 <p>
 All implementations of this interface must be <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
 programmers should treat instances that are equal as interchangeable and should not
 use instances for synchronization, or unpredictable behavior may occur. For example, in a future release,
 synchronization may fail. The <code>equals</code> method should be used for comparisons.
 <p>
 Non-platform classes should not implement <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a> directly.

 <p> Unless otherwise specified, passing a <code>null</code> argument, or an array argument containing one or more <code>null</code>
 elements to a method in this class causes a <a href="../../../../java.base/java/lang/NullPointerException.html" title="class in java.lang"><code>NullPointerException</code></a> to be thrown. </p>

 <h2>Constructing memory segments</h2>

 There are multiple ways to obtain a memory segment. First, memory segments backed by off-heap memory can
 be allocated using one of the many factory methods provided (see <a href="#allocateNative(jdk.incubator.foreign.MemoryLayout)"><code>allocateNative(MemoryLayout)</code></a>,
 <a href="#allocateNative(long)"><code>allocateNative(long)</code></a> and <a href="#allocateNative(long,long)"><code>allocateNative(long, long)</code></a>). Memory segments obtained
 in this way are called <em>native memory segments</em>.
 <p>
 It is also possible to obtain a memory segment backed by an existing heap-allocated Java array,
 using one of the provided factory methods (e.g. <a href="#ofArray(int%5B%5D)"><code>ofArray(int[])</code></a>). Memory segments obtained
 in this way are called <em>array memory segments</em>.
 <p>
 It is possible to obtain a memory segment backed by an existing Java byte buffer (see <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a>),
 using the factory method <a href="#ofByteBuffer(java.nio.ByteBuffer)"><code>ofByteBuffer(ByteBuffer)</code></a>.
 Memory segments obtained in this way are called <em>buffer memory segments</em>. Note that buffer memory segments might
 be backed by native memory (as in the case of native memory segments) or heap memory (as in the case of array memory segments),
 depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory
 segment obtained from a byte buffer created with the <a href="../../../../java.base/java/nio/ByteBuffer.html#allocateDirect(int)"><code>ByteBuffer.allocateDirect(int)</code></a> method will be backed
 by native memory.
 <p>
 Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method
 <a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)"><code>mapFile(Path, long, long, FileChannel.MapMode)</code></a>. Such memory segments are called <em>mapped memory segments</em>;
 mapped memory segments are associated with an underlying file descriptor. For more operations on mapped memory segments, please refer to the
 <a href="MappedMemorySegments.html" title="class in jdk.incubator.foreign"><code>MappedMemorySegments</code></a> class.
 <p>
 Array and buffer segments are effectively <em>views</em> over existing memory regions which might outlive the
 lifecycle of the segments derived from them, and can even be manipulated directly (e.g. via array access, or direct use
 of the <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> API) by other clients. As a result, while sharing array or buffer segments is possible,
 it is strongly advised that clients wishing to do so take extra precautions to make sure that the underlying memory sources
 associated with such segments remain inaccessible, and that said memory sources are never aliased by more than one segment
 at a time - e.g. so as to prevent concurrent modifications of the contents of an array, or buffer segment.

 <h2>Explicit deallocation</h2>

 Memory segments are closed explicitly (see <a href="#close()"><code>close()</code></a>). When a segment is closed, it is no longer
 <em>alive</em> (see <a href="#isAlive()"><code>isAlive()</code></a>, and subsequent operation on the segment (or on any <a href="MemoryAddress.html" title="interface in jdk.incubator.foreign"><code>MemoryAddress</code></a> instance
 derived from it) will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 Closing a segment might trigger the releasing of the underlying memory resources associated with said segment, depending on
 the kind of memory segment being considered:
 <ul>
     <li>closing a native memory segment results in <em>freeing</em> the native memory associated with it</li>
     <li>closing a mapped memory segment results in the backing memory-mapped file to be unmapped</li>
     <li>closing a buffer, or a heap segment does not have any side-effect, other than marking the segment
     as <em>not alive</em> (see <a href="#isAlive()"><code>isAlive()</code></a>). Also, since the buffer and heap segments might keep
     strong references to the original buffer or array instance, it is the responsibility of clients to ensure that
     these segments are discarded in a timely manner, so as not to prevent garbage collection to reclaim the underlying
     objects.</li>
 </ul>

 <h2><a id="access-modes">Access modes</a></h2>

 Memory segments supports zero or more <em>access modes</em>. Supported access modes are <a href="#READ"><code>READ</code></a>,
 <a href="#WRITE"><code>WRITE</code></a>, <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#SHARE"><code>SHARE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>. The set of access modes supported by a segment alters the
 set of operations that are supported by that segment. For instance, attempting to call <a href="#close()"><code>close()</code></a> on
 a segment which does not support the <a href="#CLOSE"><code>CLOSE</code></a> access mode will result in an exception.
 <p>
 The set of supported access modes can only be made stricter (by supporting <em>fewer</em> access modes). This means
 that restricting the set of access modes supported by a segment before sharing it with other clients
 is generally a good practice if the creator of the segment wants to retain some control over how the segment
 is going to be accessed.

 <h2>Memory segment views</h2>

 Memory segments support <em>views</em>. For instance, it is possible to alter the set of supported access modes,
 by creating an <em>immutable</em> view of a memory segment, as follows:
 <blockquote><pre><code>
MemorySegment segment = ...
MemorySegment roSegment = segment.withAccessModes(segment.accessModes() &amp; ~WRITE);
 </code></pre></blockquote>
 It is also possible to create views whose spatial bounds are stricter than the ones of the original segment
 (see <a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a>).
 <p>
 Temporal bounds of the original segment are inherited by the view; that is, closing a segment view, such as a sliced
 view, will cause the original segment to be closed; as such special care must be taken when sharing views
 between multiple clients. If a client want to protect itself against early closure of a segment by
 another actor, it is the responsibility of that client to take protective measures, such as removing <a href="#CLOSE"><code>CLOSE</code></a>
 from the set of supported access modes, before sharing the view with another client.
 <p>
 To allow for interoperability with existing code, a byte buffer view can be obtained from a memory segment
 (see <a href="#asByteBuffer()"><code>asByteBuffer()</code></a>). This can be useful, for instance, for those clients that want to keep using the
 <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> API, but need to operate on large memory segments. Byte buffers obtained in such a way support
 the same spatial and temporal access restrictions associated to the memory segment from which they originated.

 <h2><a id="thread-confinement">Thread confinement</a></h2>

 Memory segments support strong thread-confinement guarantees. Upon creation, they are assigned an <em>owner thread</em>,
 typically the thread which initiated the creation operation. After creation, only the owner thread will be allowed
 to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
 the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
 owner thread will result in a runtime failure.
 <p>
 The <a href="#handoff(java.lang.Thread)"><code>handoff(Thread)</code></a> method can be used to change the thread-confinement properties of a memory segment.
 This method is, like <a href="#close()"><code>close()</code></a>, a <em>terminal operation</em> which marks the original segment as not alive
 (see <a href="#isAlive()"><code>isAlive()</code></a>) and creates a <em>new</em> segment with the desired thread-confinement properties. Calling
 <a href="#handoff(java.lang.Thread)"><code>handoff(Thread)</code></a> is only possible if the segment features the corresponding <a href="#HANDOFF"><code>HANDOFF</code></a> access mode.
 <p>
 For instance, if a client wants to transfer ownership of a segment to another (known) thread, it can do so as follows:

 <blockquote><pre><code>
MemorySegment segment = ...
MemorySegment aSegment = segment.handoff(threadA);
 </code></pre></blockquote>

 By doing so, the original segment is marked as not alive, and a new segment is returned whose owner thread
 is <code>threadA</code>; this allows, for instance, for two threads <code>A</code> and <code>B</code> to share
 a segment in a controlled, cooperative and race-free fashion (also known as <em>serial thread confinement</em>).
 <p>
 Alternatively, the <a href="#share()"><code>share()</code></a> method can be used to remove thread ownership altogether; this is only possible
 if the segment features the corresponding <a href="#SHARE"><code>SHARE</code></a> access mode. The following code shows how clients can
 obtain a shared segment:

 <blockquote><pre><code>
MemorySegment segment = ...
MemorySegment sharedSegment = segment.share();
 </code></pre></blockquote>

 Again here, the original segment is marked as not alive, and a new <em>shared</em> segment is returned which features no owner
 thread (e.g. <a href="#ownerThread()"><code>ownerThread()</code></a> returns <code>null</code>). This might be useful when multiple threads need to process
 the contents of the same memory segment concurrently (e.g. in the case of parallel processing). For instance, a client
 might obtain a <a href="../../../../java.base/java/util/Spliterator.html" title="interface in java.util"><code>Spliterator</code></a> from a shared segment, which can then be used to slice the segment and allow multiple
 threads to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:

 <blockquote><pre><code>
SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).share()) {
    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)
                           .mapToInt(s -&gt; (int)VH_int.get(s.address()))
                           .sum();
}
 </code></pre></blockquote>

 Once shared, a segment can be claimed back by a given thread (again using <a href="#handoff(java.lang.Thread)"><code>handoff(Thread)</code></a>); in fact, many threads
 can attempt to gain ownership of the same segment, concurrently, and only one of them is guaranteed to succeed.
 <p>
 When using shared segments, clients should make sure that no other thread is accessing the segment while
 the segment is being closed. If one or more threads attempts to access a segment concurrently while the
 segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should
 refrain from attempting to close a segment repeatedly (e.g. keep calling <a href="#close()"><code>close()</code></a> until no exception is thrown);
 such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads
 accessing/closing the segment.

 <h2>Implicit deallocation</h2>

 Clients can register a memory segment against a <a href="../../../../java.base/java/lang/ref/Cleaner.html" title="class in java.lang.ref"><code>Cleaner</code></a>, to make sure that underlying resources associated with
 that segment will be released when the segment becomes <em>unreachable</em>, which can be useful to prevent native memory
 leaks. This can be achieved using the <a href="#registerCleaner(java.lang.ref.Cleaner)"><code>registerCleaner(Cleaner)</code></a> method, as follows:

 <blockquote><pre><code>
MemorySegment segment = ...
MemorySegment gcSegment = segment.registerCleaner(cleaner);
 </code></pre></blockquote>

 Here, the original segment is marked as not alive, and a new segment is returned (the owner thread of the returned
 segment set is set to that of the current thread, see <a href="#ownerThread()"><code>ownerThread()</code></a>); the new segment
 will also be registered with the the <a href="../../../../java.base/java/lang/ref/Cleaner.html" title="class in java.lang.ref"><code>Cleaner</code></a> instance provided to the <a href="#registerCleaner(java.lang.ref.Cleaner)"><code>registerCleaner(Cleaner)</code></a> method;
 as such, if not closed explicitly (see <a href="#close()"><code>close()</code></a>), the new segment will be automatically closed by the cleaner.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>In the future, if the Java language permits, <a href="MemorySegment.html" title="interface in jdk.incubator.foreign"><code>MemorySegment</code></a>
 may become a <code>sealed</code> interface, which would prohibit subclassing except by other explicitly permitted subtypes.</dd>
<dt>Implementation Requirements:</dt>
<dd>Implementations of this interface are immutable, thread-safe and <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static int</code></div>
<div class="col-second even-row-color"><code><span class="member-name-link"><a href="#ALL_ACCESS">ALL_ACCESS</a></span></code></div>
<div class="col-last even-row-color">
<div class="block">Default access mode; this is a union of all the access modes supported by memory segments.</div>
</div>
<div class="col-first odd-row-color"><code>static int</code></div>
<div class="col-second odd-row-color"><code><span class="member-name-link"><a href="#CLOSE">CLOSE</a></span></code></div>
<div class="col-last odd-row-color">
<div class="block">Close access mode; calling <a href="#close()"><code>close()</code></a> is supported by a segment which supports this access mode.</div>
</div>
<div class="col-first even-row-color"><code>static int</code></div>
<div class="col-second even-row-color"><code><span class="member-name-link"><a href="#HANDOFF">HANDOFF</a></span></code></div>
<div class="col-last even-row-color">
<div class="block">Handoff access mode; this segment support serial thread-confinement via thread ownership changes
 (see <a href="#handoff(jdk.incubator.foreign.NativeScope)"><code>handoff(NativeScope)</code></a> and <a href="#handoff(java.lang.Thread)"><code>handoff(Thread)</code></a>).</div>
</div>
<div class="col-first odd-row-color"><code>static int</code></div>
<div class="col-second odd-row-color"><code><span class="member-name-link"><a href="#READ">READ</a></span></code></div>
<div class="col-last odd-row-color">
<div class="block">Read access mode; read operations are supported by a segment which supports this access mode.</div>
</div>
<div class="col-first even-row-color"><code>static int</code></div>
<div class="col-second even-row-color"><code><span class="member-name-link"><a href="#SHARE">SHARE</a></span></code></div>
<div class="col-last even-row-color">
<div class="block">Share access mode; this segment support sharing with threads other than the owner thread (see <a href="#share()"><code>share()</code></a>).</div>
</div>
<div class="col-first odd-row-color"><code>static int</code></div>
<div class="col-second odd-row-color"><code><span class="member-name-link"><a href="#WRITE">WRITE</a></span></code></div>
<div class="col-last odd-row-color">
<div class="block">Write access mode; write operations are supported by a segment which supports this access mode.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button><button id="method-summary-table-tab5" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab5', 3)" class="table-tab">Default Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>int</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#accessModes()">accessModes</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
 <a href="#READ"><code>READ</code></a>, <a href="#WRITE"><code>WRITE</code></a>, <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#SHARE"><code>SHARE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#address()">address</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">The base memory address associated with this memory segment.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#allocateNative(long)">allocateNative</a></span>&#8203;(long&nbsp;bytesSize)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#allocateNative(long,long)">allocateNative</a></span>&#8203;(long&nbsp;bytesSize,
 long&nbsp;alignmentBytes)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size and
 alignment constraint (in bytes).</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#allocateNative(jdk.incubator.foreign.MemoryLayout)">allocateNative</a></span>&#8203;(<a href="MemoryLayout.html" title="interface in jdk.incubator.foreign">MemoryLayout</a>&nbsp;layout)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#asByteBuffer()">asByteBuffer</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Wraps this segment in a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table"><code>default <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table"><code><span class="member-name-link"><a href="#asSlice(long)">asSlice</a></span>&#8203;(long&nbsp;offset)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table">
<div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
 and whose new size is computed by subtracting the specified offset from this segment size.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#asSlice(long,long)">asSlice</a></span>&#8203;(long&nbsp;offset,
 long&nbsp;newSize)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
 and whose new size is specified by the given argument.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table"><code>default <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table"><code><span class="member-name-link"><a href="#asSlice(jdk.incubator.foreign.MemoryAddress)">asSlice</a></span>&#8203;(<a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a>&nbsp;newBase)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table">
<div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting
 the address offset relative to this segment (see <a href="MemoryAddress.html#segmentOffset(jdk.incubator.foreign.MemorySegment)"><code>MemoryAddress.segmentOffset(MemorySegment)</code></a>) from this segment size.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table"><code>default <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table"><code><span class="member-name-link"><a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)">asSlice</a></span>&#8203;(<a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a>&nbsp;newBase,
 long&nbsp;newSize)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table-tab5 method-summary-table">
<div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>long</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#byteSize()">byteSize</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">The size (in bytes) of this memory segment.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#close()">close</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Closes this memory segment.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>void</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#copyFrom(jdk.incubator.foreign.MemorySegment)">copyFrom</a></span>&#8203;(<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Performs a bulk copy from given source segment to this segment.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#fill(byte)">fill</a></span>&#8203;(byte&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Fills a value into this memory segment.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#handoff(java.lang.Thread)">handoff</a></span>&#8203;(<a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a>&nbsp;thread)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Obtains a new confined memory segment backed by the same underlying memory region as this segment.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#handoff(jdk.incubator.foreign.NativeScope)">handoff</a></span>&#8203;(<a href="NativeScope.html" title="interface in jdk.incubator.foreign">NativeScope</a>&nbsp;nativeScope)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Obtains a new confined memory segment backed by the same underlying memory region as this segment, but whose
 temporal bounds are controlled by the provided <a href="NativeScope.html" title="interface in jdk.incubator.foreign"><code>NativeScope</code></a> instance.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#hasAccessModes(int)">hasAccessModes</a></span>&#8203;(int&nbsp;accessModes)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Does this segment support a given set of access modes?</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#isAlive()">isAlive</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Is this segment alive?</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#isMapped()">isMapped</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Is this a mapped segment?</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)">mapFile</a></span>&#8203;(<a href="../../../../java.base/java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path,
 long&nbsp;bytesOffset,
 long&nbsp;bytesSize,
 <a href="../../../../java.base/java/nio/channels/FileChannel.MapMode.html" title="class in java.nio.channels">FileChannel.MapMode</a>&nbsp;mapMode)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined mapped memory segment that models a memory-mapped region of a file from a given path.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>long</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#mismatch(jdk.incubator.foreign.MemorySegment)">mismatch</a></span>&#8203;(<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;other)</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Finds and returns the offset, in bytes, of the first mismatch between
 this segment and a given other segment.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofArray(byte%5B%5D)">ofArray</a></span>&#8203;(byte[]&nbsp;arr)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofArray(char%5B%5D)">ofArray</a></span>&#8203;(char[]&nbsp;arr)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofArray(double%5B%5D)">ofArray</a></span>&#8203;(double[]&nbsp;arr)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofArray(float%5B%5D)">ofArray</a></span>&#8203;(float[]&nbsp;arr)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofArray(int%5B%5D)">ofArray</a></span>&#8203;(int[]&nbsp;arr)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofArray(long%5B%5D)">ofArray</a></span>&#8203;(long[]&nbsp;arr)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofArray(short%5B%5D)">ofArray</a></span>&#8203;(short[]&nbsp;arr)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofByteBuffer(java.nio.ByteBuffer)">ofByteBuffer</a></span>&#8203;(<a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;bb)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Creates a new confined buffer memory segment that models the memory associated with the given byte
 buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table"><code><span class="member-name-link"><a href="#ofNativeRestricted()">ofNativeRestricted</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table">
<div class="block">Returns a shared native memory segment whose base address is <a href="MemoryAddress.html#NULL"><code>MemoryAddress.NULL</code></a> and whose size is <a href="../../../../java.base/java/lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a></code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#ownerThread()">ownerThread</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">The thread owning this segment.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#registerCleaner(java.lang.ref.Cleaner)">registerCleaner</a></span>&#8203;(<a href="../../../../java.base/java/lang/ref/Cleaner.html" title="class in java.lang.ref">Cleaner</a>&nbsp;cleaner)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Register this memory segment instance against a <a href="../../../../java.base/java/lang/ref/Cleaner.html" title="class in java.lang.ref"><code>Cleaner</code></a> object, by returning a new memory segment backed
 by the same underlying memory region as this segment.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#share()">share</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Obtains a new shared memory segment backed by the same underlying memory region as this segment.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="../../../../java.base/java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#spliterator(jdk.incubator.foreign.SequenceLayout)">spliterator</a></span>&#8203;(<a href="SequenceLayout.html" title="class in jdk.incubator.foreign">SequenceLayout</a>&nbsp;layout)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Returns a spliterator for this memory segment.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>byte[]</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#toByteArray()">toByteArray</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Copy the contents of this memory segment into a fresh byte array.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>char[]</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#toCharArray()">toCharArray</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Copy the contents of this memory segment into a fresh char array.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>double[]</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#toDoubleArray()">toDoubleArray</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Copy the contents of this memory segment into a fresh double array.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>float[]</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#toFloatArray()">toFloatArray</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Copy the contents of this memory segment into a fresh float array.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>int[]</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#toIntArray()">toIntArray</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Copy the contents of this memory segment into a fresh int array.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>long[]</code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#toLongArray()">toLongArray</a></span>()</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Copy the contents of this memory segment into a fresh long array.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code>short[]</code></div>
<div class="col-second even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#toShortArray()">toShortArray</a></span>()</code></div>
<div class="col-last even-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Copy the contents of this memory segment into a fresh short array.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3"><code><span class="member-name-link"><a href="#withAccessModes(int)">withAccessModes</a></span>&#8203;(int&nbsp;accessModes)</code></div>
<div class="col-last odd-row-color method-summary-table-tab2 method-summary-table method-summary-table-tab3">
<div class="block">Obtains a segment view with specific <a href="#access-modes">access modes</a>.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="READ">
<h3>READ</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">READ</span></div>
<div class="block">Read access mode; read operations are supported by a segment which supports this access mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.READ">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="WRITE">
<h3>WRITE</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">WRITE</span></div>
<div class="block">Write access mode; write operations are supported by a segment which supports this access mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.WRITE">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="CLOSE">
<h3>CLOSE</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">CLOSE</span></div>
<div class="block">Close access mode; calling <a href="#close()"><code>close()</code></a> is supported by a segment which supports this access mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.CLOSE">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="SHARE">
<h3>SHARE</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">SHARE</span></div>
<div class="block">Share access mode; this segment support sharing with threads other than the owner thread (see <a href="#share()"><code>share()</code></a>).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.SHARE">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="HANDOFF">
<h3>HANDOFF</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">HANDOFF</span></div>
<div class="block">Handoff access mode; this segment support serial thread-confinement via thread ownership changes
 (see <a href="#handoff(jdk.incubator.foreign.NativeScope)"><code>handoff(NativeScope)</code></a> and <a href="#handoff(java.lang.Thread)"><code>handoff(Thread)</code></a>).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.HANDOFF">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ALL_ACCESS">
<h3>ALL_ACCESS</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ALL_ACCESS</span></div>
<div class="block">Default access mode; this is a union of all the access modes supported by memory segments.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.ALL_ACCESS">Constant Field Values</a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="address()">
<h3>address</h3>
<div class="member-signature"><span class="return-type"><a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a></span>&nbsp;<span class="element-name">address</span>()</div>
<div class="block">The base memory address associated with this memory segment. The returned address is
 a <em>checked</em> memory address and can therefore be used in dereference operations
 (see <a href="MemoryAddress.html" title="interface in jdk.incubator.foreign"><code>MemoryAddress</code></a>).</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="Addressable.html#address()">address</a></code>&nbsp;in interface&nbsp;<code><a href="Addressable.html" title="interface in jdk.incubator.foreign">Addressable</a></code></dd>
<dt>Returns:</dt>
<dd>The base memory address.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="spliterator(jdk.incubator.foreign.SequenceLayout)">
<h3>spliterator</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../java.base/java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&gt;</span>&nbsp;<span class="element-name">spliterator</span>&#8203;<span class="parameters">(<a href="SequenceLayout.html" title="class in jdk.incubator.foreign">SequenceLayout</a>&nbsp;layout)</span></div>
<div class="block">Returns a spliterator for this memory segment. The returned spliterator reports <a href="../../../../java.base/java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a>,
 <a href="../../../../java.base/java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="../../../../java.base/java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>, <a href="../../../../java.base/java/util/Spliterator.html#NONNULL"><code>Spliterator.NONNULL</code></a> and <a href="../../../../java.base/java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>
 characteristics.
 <p>
 The returned spliterator splits this segment according to the specified sequence layout; that is,
 if the supplied layout is a sequence layout whose element count is <code>N</code>, then calling <a href="../../../../java.base/java/util/Spliterator.html#trySplit()"><code>Spliterator.trySplit()</code></a>
 will result in a spliterator serving approximatively <code>N/2</code> elements (depending on whether N is even or not).
 As such, splitting is possible as long as <code>N &gt;= 2</code>. The spliterator returns segments that feature the same
 <a href="#access-modes">access modes</a> as the given segment less the <a href="#CLOSE"><code>CLOSE</code></a> access mode.
 <p>
 The returned spliterator effectively allows to slice this segment into disjoint sub-segments, which can then
 be processed in parallel by multiple threads (if the segment is shared).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>layout</code> - the layout to be used for splitting.</dd>
<dt>Returns:</dt>
<dd>the element spliterator for this segment</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if the segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ownerThread()">
<h3>ownerThread</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a></span>&nbsp;<span class="element-name">ownerThread</span>()</div>
<div class="block">The thread owning this segment.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="byteSize()">
<h3>byteSize</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="element-name">byteSize</span>()</div>
<div class="block">The size (in bytes) of this memory segment.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The size (in bytes) of this memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="withAccessModes(int)">
<h3>withAccessModes</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">withAccessModes</span>&#8203;<span class="parameters">(int&nbsp;accessModes)</span></div>
<div class="block">Obtains a segment view with specific <a href="#access-modes">access modes</a>. Supported access modes are <a href="#READ"><code>READ</code></a>, <a href="#WRITE"><code>WRITE</code></a>,
 <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#SHARE"><code>SHARE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>. It is generally not possible to go from a segment with stricter access modes
 to one with less strict access modes. For instance, attempting to add <a href="#WRITE"><code>WRITE</code></a> access mode to a read-only segment
 will be met with an exception.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>accessModes</code> - an ORed mask of zero or more access modes.</dd>
<dt>Returns:</dt>
<dd>a segment view with specific access modes.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - when <code>mask</code> is an access mask which is less strict than the one supported by this
 segment, or when <code>mask</code> contains bits not associated with any of the supported access modes.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasAccessModes(int)">
<h3>hasAccessModes</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasAccessModes</span>&#8203;<span class="parameters">(int&nbsp;accessModes)</span></div>
<div class="block">Does this segment support a given set of access modes?</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>accessModes</code> - an ORed mask of zero or more access modes.</dd>
<dt>Returns:</dt>
<dd>true, if the access modes in <code>accessModes</code> are stricter than the ones supported by this segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - when <code>mask</code> contains bits not associated with any of the supported access modes.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="accessModes()">
<h3>accessModes</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">accessModes</span>()</div>
<div class="block">Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
 <a href="#READ"><code>READ</code></a>, <a href="#WRITE"><code>WRITE</code></a>, <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#SHARE"><code>SHARE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the access modes associated with this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asSlice(long,long)">
<h3>asSlice</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">asSlice</span>&#8203;<span class="parameters">(long&nbsp;offset,
 long&nbsp;newSize)</span></div>
<div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
 and whose new size is specified by the given argument.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>offset</code> - The new segment base offset (relative to the current segment base address), specified in bytes.</dd>
<dd><code>newSize</code> - The new segment size, specified in bytes.</dd>
<dt>Returns:</dt>
<dd>a new memory segment view with updated base/limit addresses.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, <code>newSize &lt; 0</code>, or <code>newSize &gt; byteSize() - offset</code></dd>
<dt>See Also:</dt>
<dd><a href="#asSlice(long)"><code>asSlice(long)</code></a>, 
<a href="#asSlice(jdk.incubator.foreign.MemoryAddress)"><code>asSlice(MemoryAddress)</code></a>, 
<a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)"><code>asSlice(MemoryAddress, long)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asSlice(jdk.incubator.foreign.MemoryAddress,long)">
<h3>asSlice</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">asSlice</span>&#8203;<span class="parameters">(<a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a>&nbsp;newBase,
 long&nbsp;newSize)</span></div>
<div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.
 <p>
 Equivalent to the following code:
 <pre><code>
    asSlice(newBase.segmentOffset(this), newSize);
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>newBase</code> - The new segment base address.</dd>
<dd><code>newSize</code> - The new segment size, specified in bytes.</dd>
<dt>Returns:</dt>
<dd>a new memory segment view with updated base/limit addresses.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, <code>newSize &lt; 0</code>, or <code>newSize &gt; byteSize() - offset</code></dd>
<dt>See Also:</dt>
<dd><a href="#asSlice(long)"><code>asSlice(long)</code></a>, 
<a href="#asSlice(jdk.incubator.foreign.MemoryAddress)"><code>asSlice(MemoryAddress)</code></a>, 
<a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asSlice(long)">
<h3>asSlice</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">asSlice</span>&#8203;<span class="parameters">(long&nbsp;offset)</span></div>
<div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
 and whose new size is computed by subtracting the specified offset from this segment size.
 <p>
 Equivalent to the following code:
 <pre><code>
    asSlice(offset, byteSize() - offset);
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>offset</code> - The new segment base offset (relative to the current segment base address), specified in bytes.</dd>
<dt>Returns:</dt>
<dd>a new memory segment view with updated base/limit addresses.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, or <code>offset &gt; byteSize()</code>.</dd>
<dt>See Also:</dt>
<dd><a href="#asSlice(jdk.incubator.foreign.MemoryAddress)"><code>asSlice(MemoryAddress)</code></a>, 
<a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)"><code>asSlice(MemoryAddress, long)</code></a>, 
<a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asSlice(jdk.incubator.foreign.MemoryAddress)">
<h3>asSlice</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">asSlice</span>&#8203;<span class="parameters">(<a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a>&nbsp;newBase)</span></div>
<div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting
 the address offset relative to this segment (see <a href="MemoryAddress.html#segmentOffset(jdk.incubator.foreign.MemorySegment)"><code>MemoryAddress.segmentOffset(MemorySegment)</code></a>) from this segment size.
 <p>
 Equivalent to the following code:
 <pre><code>
    asSlice(newBase.segmentOffset(this));
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>newBase</code> - The new segment base offset (relative to the current segment base address), specified in bytes.</dd>
<dt>Returns:</dt>
<dd>a new memory segment view with updated base/limit addresses.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>address.segmentOffset(this) &lt; 0</code>, or <code>address.segmentOffset(this) &gt; byteSize()</code>.</dd>
<dt>See Also:</dt>
<dd><a href="#asSlice(long)"><code>asSlice(long)</code></a>, 
<a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)"><code>asSlice(MemoryAddress, long)</code></a>, 
<a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isMapped()">
<h3>isMapped</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">isMapped</span>()</div>
<div class="block">Is this a mapped segment? Returns true if this segment is a mapped memory segment,
 created using the <a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)"><code>mapFile(Path, long, long, FileChannel.MapMode)</code></a> factory, or a buffer segment
 derived from a <a href="../../../../java.base/java/nio/MappedByteBuffer.html" title="class in java.nio"><code>MappedByteBuffer</code></a> using the <a href="#ofByteBuffer(java.nio.ByteBuffer)"><code>ofByteBuffer(ByteBuffer)</code></a> factory.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd><code>true</code> if this segment is a mapped segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isAlive()">
<h3>isAlive</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">isAlive</span>()</div>
<div class="block">Is this segment alive?</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true, if the segment is alive.</dd>
<dt>See Also:</dt>
<dd><a href="#close()"><code>close()</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="close()">
<h3>close</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">close</span>()</div>
<div class="block">Closes this memory segment. This is a <em>terminal operation</em>; as a side-effect, if this operation completes
 without exceptions, this segment will be marked as <em>not alive</em>, and subsequent operations on this segment
 will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 Depending on the kind of memory segment being closed, calling this method further triggers deallocation of all the resources
 associated with the memory segment.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="../../../../java.base/java/lang/AutoCloseable.html#close()">close</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../java.base/java/lang/AutoCloseable.html" title="interface in java.lang">AutoCloseable</a></code></dd>
<dt>API Note:</dt>
<dd>This operation is not idempotent; that is, closing an already closed segment <em>always</em> results in an
 exception being thrown. This reflects a deliberate design choice: segment state transitions should be
 manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application
 logic. This is especially useful when reasoning about the lifecycle of dependent segment views (see <a href="#asSlice(jdk.incubator.foreign.MemoryAddress)"><code>asSlice(MemoryAddress)</code></a>,
 where closing one segment might side-effect multiple segments. In such cases it might in fact not be obvious, looking
 at the code, as to whether a given segment is alive or not.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment, or if this segment is shared and the segment is concurrently accessed while this method is
 called.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#CLOSE"><code>CLOSE</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="handoff(java.lang.Thread)">
<h3>handoff</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">handoff</span>&#8203;<span class="parameters">(<a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a>&nbsp;thread)</span></div>
<div class="block">Obtains a new confined memory segment backed by the same underlying memory region as this segment. The returned segment will
 be confined on the specified thread, and will feature the same spatial bounds and access modes (see <a href="#accessModes()"><code>accessModes()</code></a>)
 as this segment.
 <p>
 This is a <em>terminal operation</em>; as a side-effect, if this operation completes
 without exceptions, this segment will be marked as <em>not alive</em>, and subsequent operations on this segment
 will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 In case where the owner thread of the returned segment differs from that of this segment, write accesses to this
 segment's content <a href="../../../java/util/concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
 hand-over from the current owner thread to the new owner thread, which in turn <i>happens before</i> read accesses
 to the returned segment's contents on the new owner thread.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>thread</code> - the new owner thread</dd>
<dt>Returns:</dt>
<dd>a new confined memory segment whose owner thread is set to <code>thread</code>.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#HANDOFF"><code>HANDOFF</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="handoff(jdk.incubator.foreign.NativeScope)">
<h3>handoff</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">handoff</span>&#8203;<span class="parameters">(<a href="NativeScope.html" title="interface in jdk.incubator.foreign">NativeScope</a>&nbsp;nativeScope)</span></div>
<div class="block">Obtains a new confined memory segment backed by the same underlying memory region as this segment, but whose
 temporal bounds are controlled by the provided <a href="NativeScope.html" title="interface in jdk.incubator.foreign"><code>NativeScope</code></a> instance.
 <p>
 This is a <em>terminal operation</em>;
 as a side-effect, this segment will be marked as <em>not alive</em>, and subsequent operations on this segment
 will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 The returned segment will feature only <a href="#READ"><code>READ</code></a> and <a href="#WRITE"><code>WRITE</code></a> access modes
 (assuming these were available in the original segment). As such the returned segment cannot be closed directly
 using <a href="#close()"><code>close()</code></a> - but it will be closed indirectly when this native scope is closed. The
 returned segment will also be confined by the same thread as the provided native scope (see <a href="NativeScope.html#ownerThread()"><code>NativeScope.ownerThread()</code></a>).
 <p>
 In case where the owner thread of the returned segment differs from that of this segment, write accesses to this
 segment's content <a href="../../../java/util/concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
 hand-over from the current owner thread to the new owner thread, which in turn <i>happens before</i> read accesses
 to the returned segment's contents on the new owner thread.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>nativeScope</code> - the native scope.</dd>
<dt>Returns:</dt>
<dd>a new confined memory segment backed by the same underlying memory region as this segment, but whose life-cycle
 is tied to that of <code>nativeScope</code>.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#HANDOFF"><code>HANDOFF</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="share()">
<h3>share</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">share</span>()</div>
<div class="block">Obtains a new shared memory segment backed by the same underlying memory region as this segment. The returned segment will
 not be confined on any thread and can therefore be accessed concurrently from multiple threads; moreover, the
 returned segment will feature the same spatial bounds and access modes (see <a href="#accessModes()"><code>accessModes()</code></a>)
 as this segment.
 <p>
 This is a <em>terminal operation</em>; as a side-effect, if this operation completes
 without exceptions, this segment will be marked as <em>not alive</em>, and subsequent operations on this segment
 will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 Write accesses to this segment's content <a href="../../../java/util/concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
 hand-over from the current owner thread to the new owner thread, which in turn <i>happens before</i> read accesses
 to the returned segment's contents on a new thread.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a new memory shared segment backed by the same underlying memory region as this segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="registerCleaner(java.lang.ref.Cleaner)">
<h3>registerCleaner</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">registerCleaner</span>&#8203;<span class="parameters">(<a href="../../../../java.base/java/lang/ref/Cleaner.html" title="class in java.lang.ref">Cleaner</a>&nbsp;cleaner)</span></div>
<div class="block">Register this memory segment instance against a <a href="../../../../java.base/java/lang/ref/Cleaner.html" title="class in java.lang.ref"><code>Cleaner</code></a> object, by returning a new memory segment backed
 by the same underlying memory region as this segment. The returned segment will feature the same confinement,
 spatial bounds and access modes (see <a href="#accessModes()"><code>accessModes()</code></a>) as this segment. Moreover, the returned segment
 will be associated with the specified <a href="../../../../java.base/java/lang/ref/Cleaner.html" title="class in java.lang.ref"><code>Cleaner</code></a> object; this allows for the segment to be closed
 as soon as it becomes <em>unreachable</em>, which might be helpful in preventing native memory leaks.
 <p>
 This is a <em>terminal operation</em>; as a side-effect, if this operation completes
 without exceptions, this segment will be marked as <em>not alive</em>, and subsequent operations on this segment
 will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 The implicit deallocation behavior associated with the returned segment will be preserved under terminal
 operations such as <a href="#handoff(java.lang.Thread)"><code>handoff(Thread)</code></a> and <a href="#share()"><code>share()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cleaner</code> - the cleaner object, responsible for implicit deallocation of the returned segment.</dd>
<dt>Returns:</dt>
<dd>a new memory segment backed by the same underlying memory region as this segment, which features
 implicit deallocation.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment, or if this segment is already associated with a cleaner.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#CLOSE"><code>CLOSE</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="fill(byte)">
<h3>fill</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">fill</span>&#8203;<span class="parameters">(byte&nbsp;value)</span></div>
<div class="block">Fills a value into this memory segment.
 <p>
 More specifically, the given value is filled into each address of this
 segment. Equivalent to (but likely more efficient than) the following code:

 <pre><code>
byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
for (long l = 0; l &lt; segment.byteSize(); l++) {
     byteHandle.set(segment.address(), l, value);
}
 </code></pre>

 without any regard or guarantees on the ordering of particular memory
 elements being set.
 <p>
 Fill can be useful to initialize or reset the memory of a segment.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - the value to fill into this segment</dd>
<dt>Returns:</dt>
<dd>this memory segment</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#WRITE"><code>WRITE</code></a> access mode</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="copyFrom(jdk.incubator.foreign.MemorySegment)">
<h3>copyFrom</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">copyFrom</span>&#8203;<span class="parameters">(<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;src)</span></div>
<div class="block">Performs a bulk copy from given source segment to this segment. More specifically, the bytes at
 offset <code>0</code> through <code>src.byteSize() - 1</code> in the source segment are copied into this segment
 at offset <code>0</code> through <code>src.byteSize() - 1</code>.
 If the source segment overlaps with this segment, then the copying is performed as if the bytes at
 offset <code>0</code> through <code>src.byteSize() - 1</code> in the source segment were first copied into a
 temporary segment with size <code>bytes</code>, and then the contents of the temporary segment were copied into
 this segment at offset <code>0</code> through <code>src.byteSize() - 1</code>.
 <p>
 The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment
 do not overlap, but refer to overlapping regions of the same backing storage using different addresses.
 For example, this may occur if the same file is <a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)"><code>mapped</code></a> to two segments.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>src</code> - the source segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>src.byteSize() &gt; this.byteSize()</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if either the source segment or this segment have been already closed,
 or if access occurs from a thread other than the thread owning either segment.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if either the source segment or this segment do not feature required access modes;
 more specifically, <code>src</code> should feature at least the <a href="#READ"><code>READ</code></a> access mode,
 while this segment should feature at least the <a href="#WRITE"><code>WRITE</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mismatch(jdk.incubator.foreign.MemorySegment)">
<h3>mismatch</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="element-name">mismatch</span>&#8203;<span class="parameters">(<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;other)</span></div>
<div class="block">Finds and returns the offset, in bytes, of the first mismatch between
 this segment and a given other segment. The offset is relative to the
 <a href="#address()"><code>base address</code></a> of each segment and will be in the
 range of 0 (inclusive) up to the <a href="#byteSize()"><code>size</code></a> (in bytes) of
 the smaller memory segment (exclusive).
 <p>
 If the two segments share a common prefix then the returned offset is
 the length of the common prefix and it follows that there is a mismatch
 between the two segments at that offset within the respective segments.
 If one segment is a proper prefix of the other then the returned offset is
 the smaller of the segment sizes, and it follows that the offset is only
 valid for the larger segment. Otherwise, there is no mismatch and <code>
 -1</code> is returned.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>other</code> - the segment to be tested for a mismatch with this segment</dd>
<dt>Returns:</dt>
<dd>the relative offset, in bytes, of the first mismatch between this
 and the given other segment, otherwise -1 if no mismatch</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if either this segment of the other segment
 have been already closed, or if access occurs from a thread other than the
 thread owning either segment</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if either this segment or the other
 segment does not feature at least the <a href="#READ"><code>READ</code></a> access mode</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asByteBuffer()">
<h3>asByteBuffer</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a></span>&nbsp;<span class="element-name">asByteBuffer</span>()</div>
<div class="block">Wraps this segment in a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a>. Some of the properties of the returned buffer are linked to
 the properties of this segment. For instance, if this segment is <em>immutable</em>
 (e.g. the segment has access mode <a href="#READ"><code>READ</code></a> but not <a href="#WRITE"><code>WRITE</code></a>), then the resulting buffer is <em>read-only</em>
 (see <a href="../../../../java.base/java/nio/Buffer.html#isReadOnly()"><code>Buffer.isReadOnly()</code></a>. Additionally, if this is a native memory segment, the resulting buffer is
 <em>direct</em> (see <a href="../../../../java.base/java/nio/ByteBuffer.html#isDirect()"><code>ByteBuffer.isDirect()</code></a>).
 <p>
 The returned buffer's position (see <a href="../../../../java.base/java/nio/Buffer.html#position()"><code>Buffer.position()</code></a> is initially set to zero, while
 the returned buffer's capacity and limit (see <a href="../../../../java.base/java/nio/Buffer.html#capacity()"><code>Buffer.capacity()</code></a> and <a href="../../../../java.base/java/nio/Buffer.html#limit()"><code>Buffer.limit()</code></a>, respectively)
 are set to this segment' size (see <a href="#byteSize()"><code>byteSize()</code></a>). For this reason, a byte buffer cannot be
 returned if this segment' size is greater than <a href="../../../../java.base/java/lang/Integer.html#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>.
 <p>
 The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
 is closed (see <a href="#close()"><code>close()</code></a>, accessing the returned
 buffer will throw an <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 If this segment is <em>shared</em>, calling certain I/O operations on the resulting buffer might result in
 an unspecified exception being thrown. Examples of such problematic operations are <a href="../../../../java.base/java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer)"><code>FileChannel.read(ByteBuffer)</code></a>,
 <a href="../../../../java.base/java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer)"><code>FileChannel.write(ByteBuffer)</code></a>, <a href="../../../../java.base/java/nio/channels/SocketChannel.html#read(java.nio.ByteBuffer)"><code>SocketChannel.read(ByteBuffer)</code></a> and
 <a href="../../../../java.base/java/nio/channels/SocketChannel.html#write(java.nio.ByteBuffer)"><code>SocketChannel.write(ByteBuffer)</code></a>.
 <p>
 Finally, the resulting buffer's byte order is <a href="../../../../java.base/java/nio/ByteOrder.html#BIG_ENDIAN"><code>ByteOrder.BIG_ENDIAN</code></a>; this can be changed using
 <a href="../../../../java.base/java/nio/ByteBuffer.html#order(java.nio.ByteOrder)"><code>ByteBuffer.order(java.nio.ByteOrder)</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> view of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment cannot be mapped onto a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> instance,
 e.g. because it models an heap-based segment that is not based on a <code>byte[]</code>), or if its size is greater
 than <a href="../../../../java.base/java/lang/Integer.html#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>, or if the segment does not support the <a href="#READ"><code>READ</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toByteArray()">
<h3>toByteArray</h3>
<div class="member-signature"><span class="return-type">byte[]</span>&nbsp;<span class="element-name">toByteArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh byte array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh byte array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>byte</code> instance, e.g. its size is greater than <a href="../../../../java.base/java/lang/Integer.html#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>,</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toShortArray()">
<h3>toShortArray</h3>
<div class="member-signature"><span class="return-type">short[]</span>&nbsp;<span class="element-name">toShortArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh short array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh short array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>short</code> instance, e.g. because <code>byteSize() % 2 != 0</code>,
 or <code>byteSize() / 2 &gt; Integer#MAX_VALUE</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toCharArray()">
<h3>toCharArray</h3>
<div class="member-signature"><span class="return-type">char[]</span>&nbsp;<span class="element-name">toCharArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh char array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh char array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>char</code> instance, e.g. because <code>byteSize() % 2 != 0</code>,
 or <code>byteSize() / 2 &gt; Integer#MAX_VALUE</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toIntArray()">
<h3>toIntArray</h3>
<div class="member-signature"><span class="return-type">int[]</span>&nbsp;<span class="element-name">toIntArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh int array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh int array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>int</code> instance, e.g. because <code>byteSize() % 4 != 0</code>,
 or <code>byteSize() / 4 &gt; Integer#MAX_VALUE</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toFloatArray()">
<h3>toFloatArray</h3>
<div class="member-signature"><span class="return-type">float[]</span>&nbsp;<span class="element-name">toFloatArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh float array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh float array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>float</code> instance, e.g. because <code>byteSize() % 4 != 0</code>,
 or <code>byteSize() / 4 &gt; Integer#MAX_VALUE</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toLongArray()">
<h3>toLongArray</h3>
<div class="member-signature"><span class="return-type">long[]</span>&nbsp;<span class="element-name">toLongArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh long array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh long array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>long</code> instance, e.g. because <code>byteSize() % 8 != 0</code>,
 or <code>byteSize() / 8 &gt; Integer#MAX_VALUE</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toDoubleArray()">
<h3>toDoubleArray</h3>
<div class="member-signature"><span class="return-type">double[]</span>&nbsp;<span class="element-name">toDoubleArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh double array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh double array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>double</code> instance, e.g. because <code>byteSize() % 8 != 0</code>,
 or <code>byteSize() / 8 &gt; Integer#MAX_VALUE</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofByteBuffer(java.nio.ByteBuffer)">
<h3>ofByteBuffer</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofByteBuffer</span>&#8203;<span class="parameters">(<a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;bb)</span></div>
<div class="block">Creates a new confined buffer memory segment that models the memory associated with the given byte
 buffer. The segment starts relative to the buffer's position (inclusive)
 and ends relative to the buffer's limit (exclusive).
 <p>
 The segment will feature all <a href="#access-modes">access modes</a> (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>),
 unless the given buffer is <a href="../../../../java.base/java/nio/Buffer.html#isReadOnly()">read-only</a> in which case the segment will
 not feature the <a href="#WRITE"><code>WRITE</code></a> access mode, and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).
 <p>
 The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable</em>
 for the life-time of the segment.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>bb</code> - the byte buffer backing the buffer memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined buffer memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(byte[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofArray</span>&#8203;<span class="parameters">(byte[]&nbsp;arr)</span></div>
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>), and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(char[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofArray</span>&#8203;<span class="parameters">(char[]&nbsp;arr)</span></div>
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>), and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(short[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofArray</span>&#8203;<span class="parameters">(short[]&nbsp;arr)</span></div>
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>), and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(int[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofArray</span>&#8203;<span class="parameters">(int[]&nbsp;arr)</span></div>
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>), and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(float[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofArray</span>&#8203;<span class="parameters">(float[]&nbsp;arr)</span></div>
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>), and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(long[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofArray</span>&#8203;<span class="parameters">(long[]&nbsp;arr)</span></div>
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>), and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(double[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofArray</span>&#8203;<span class="parameters">(double[]&nbsp;arr)</span></div>
<div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allocateNative(jdk.incubator.foreign.MemoryLayout)">
<h3>allocateNative</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">allocateNative</span>&#8203;<span class="parameters">(<a href="MemoryLayout.html" title="interface in jdk.incubator.foreign">MemoryLayout</a>&nbsp;layout)</span></div>
<div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout.
 <p>
 This is equivalent to the following code:
 <blockquote><pre><code>
    allocateNative(layout.bytesSize(), layout.bytesAlignment());
 </code></pre></blockquote></div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 Moreover, a client is responsible to call the <a href="#close()"><code>close()</code></a> on a native memory segment,
 to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.</dd>
<dt>Parameters:</dt>
<dd><code>layout</code> - the layout of the off-heap memory block backing the native memory segment.</dd>
<dt>Returns:</dt>
<dd>a new native memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the specified layout has illegal size or alignment constraint.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allocateNative(long)">
<h3>allocateNative</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">allocateNative</span>&#8203;<span class="parameters">(long&nbsp;bytesSize)</span></div>
<div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).
 <p>
 This is equivalent to the following code:
 <blockquote><pre><code>
allocateNative(bytesSize, 1);
 </code></pre></blockquote></div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 Moreover, a client is responsible to call the <a href="#close()"><code>close()</code></a> on a native memory segment,
 to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.</dd>
<dt>Parameters:</dt>
<dd><code>bytesSize</code> - the size (in bytes) of the off-heap memory block backing the native memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined native memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt; 0</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)">
<h3>mapFile</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">mapFile</span>&#8203;<span class="parameters">(<a href="../../../../java.base/java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path,
 long&nbsp;bytesOffset,
 long&nbsp;bytesSize,
 <a href="../../../../java.base/java/nio/channels/FileChannel.MapMode.html" title="class in java.nio.channels">FileChannel.MapMode</a>&nbsp;mapMode)</span>
                      throws <span class="exceptions"><a href="../../../../java.base/java/io/IOException.html" title="class in java.io">IOException</a></span></div>
<div class="block">Creates a new confined mapped memory segment that models a memory-mapped region of a file from a given path.
 <p>
 The segment will feature all <a href="#access-modes">access modes</a> (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>),
 unless the given mapping mode is <a href="../../../../java.base/java/nio/channels/FileChannel.MapMode.html#READ_ONLY">READ_ONLY</a>, in which case
 the segment will not feature the <a href="#WRITE"><code>WRITE</code></a> access mode, and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).
 <p>
 The content of a mapped memory segment can change at any time, for example
 if the content of the corresponding region of the mapped file is changed by
 this (or another) program.  Whether or not such changes occur, and when they
 occur, is operating-system dependent and therefore unspecified.
 <p>
 All or part of a mapped memory segment may become
 inaccessible at any time, for example if the backing mapped file is truncated.  An
 attempt to access an inaccessible region of a mapped memory segment will not
 change the segment's content and will cause an unspecified exception to be
 thrown either at the time of the access or at some later time.  It is
 therefore strongly recommended that appropriate precautions be taken to
 avoid the manipulation of a mapped file by this (or another) program, except to read or write
 the file's content.</div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
 of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.</dd>
<dt>Parameters:</dt>
<dd><code>path</code> - the path to the file to memory map.</dd>
<dd><code>bytesOffset</code> - the offset (expressed in bytes) within the file at which the mapped segment is to start.</dd>
<dd><code>bytesSize</code> - the size (in bytes) of the mapped memory backing the memory segment.</dd>
<dd><code>mapMode</code> - a file mapping mode, see <a href="../../../../java.base/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,long,long)"><code>FileChannel.map(FileChannel.MapMode, long, long)</code></a>; the chosen mapping mode
                might affect the behavior of the returned memory mapped segment (see <a href="MappedMemorySegments.html#force(jdk.incubator.foreign.MemorySegment)"><code>MappedMemorySegments.force(MemorySegment)</code></a>).</dd>
<dt>Returns:</dt>
<dd>a new confined mapped memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesOffset &lt; 0</code>, <code>bytesSize &lt; 0</code>, or if <code>path</code> is not associated
 with the default file system.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if an unsupported map mode is specified.</dd>
<dd><code><a href="../../../../java.base/java/io/IOException.html" title="class in java.io">IOException</a></code> - if the specified path does not point to an existing file, or if some other I/O error occurs.</dd>
<dd><code><a href="../../../../java.base/java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - If a security manager is installed and it denies an unspecified permission required by the implementation.
 In the case of the default provider, the <a href="../../../../java.base/java/lang/SecurityManager.html#checkRead(java.lang.String)"><code>SecurityManager.checkRead(String)</code></a> method is invoked to check
 read access if the file is opened for reading. The <a href="../../../../java.base/java/lang/SecurityManager.html#checkWrite(java.lang.String)"><code>SecurityManager.checkWrite(String)</code></a> method is invoked to check
 write access if the file is opened for writing.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allocateNative(long,long)">
<h3>allocateNative</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">allocateNative</span>&#8203;<span class="parameters">(long&nbsp;bytesSize,
 long&nbsp;alignmentBytes)</span></div>
<div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size and
 alignment constraint (in bytes). The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>), and its confinement thread is the current thread (see <a href="../../../../java.base/java/lang/Thread.html#currentThread()"><code>Thread.currentThread()</code></a>).</div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 Moreover, a client is responsible to call the <a href="#close()"><code>close()</code></a> on a native memory segment,
 to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.</dd>
<dt>Parameters:</dt>
<dd><code>bytesSize</code> - the size (in bytes) of the off-heap memory block backing the native memory segment.</dd>
<dd><code>alignmentBytes</code> - the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.</dd>
<dt>Returns:</dt>
<dd>a new confined native memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt; 0</code>, <code>alignmentBytes &lt; 0</code>, or if <code>alignmentBytes</code>
 is not a power of 2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofNativeRestricted()">
<h3>ofNativeRestricted</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">ofNativeRestricted</span>()</div>
<div class="block">Returns a shared native memory segment whose base address is <a href="MemoryAddress.html#NULL"><code>MemoryAddress.NULL</code></a> and whose size is <a href="../../../../java.base/java/lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a>.
 This method can be very useful when dereferencing memory addresses obtained when interacting with native libraries.
 The segment will feature the <a href="#READ"><code>READ</code></a> and <a href="#WRITE"><code>WRITE</code></a> <a href="#access-modes">access modes</a>.
 Equivalent to (but likely more efficient than) the following code:
 <pre><code>
    MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE)
                 .withOwnerThread(null)
                 .withAccessModes(READ | WRITE);
 </code></pre>
 <p>
 This method is <em>restricted</em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash
 the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 restricted methods, and use safe and supported functionalities, where possible.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a memory segment whose base address is <a href="MemoryAddress.html#NULL"><code>MemoryAddress.NULL</code></a> and whose size is <a href="../../../../java.base/java/lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a>.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalAccessError.html" title="class in java.lang">IllegalAccessError</a></code> - if the runtime property <code>foreign.restricted</code> is not set to either
 <code>permit</code>, <code>warn</code> or <code>debug</code> (the default value is set to <code>deny</code>).</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase16.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2021, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java16.0.1speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 16.0.1+9-24 --></small></p>
</footer>
</div>
</div>
</body>
</html>
